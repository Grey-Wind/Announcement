{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/wechat_qrcode.jpg","path":"img/wechat_qrcode.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/greywind_avatar.png","path":"img/greywind_avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/background.png","path":"img/background.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1694138908014},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1694138936581},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":1694138941493},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1694138941503},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"4bf95d52f77edf811f23f6d264a7493311a8d078","modified":1694138941492},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1694138941503},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1694138941503},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1694138941504},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1694138941504},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1694138941504},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1694138941505},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1694138941505},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1694138941506},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1694138941506},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1694138941507},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1694138941505},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1694138941507},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1694138941506},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1694138941507},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1694138941508},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1694138941508},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1694138941508},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1694138941509},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1694138941509},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1694138941510},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1694138941509},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1694138941511},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1694138941510},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1694138941513},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1694138941512},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1694138941511},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1694138941512},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1694138941513},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1694138941514},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1694138941515},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1694138936584},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1694138936586},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1694138936589},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1694138941514},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1694138936589},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1694138936590},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1694138941514},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1694138936590},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1694138940835},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1694138936592},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1694138936591},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1694138936592},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1694138936586},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":1694138936583},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1694138936592},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1694138936583},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":1694138936585},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1694138936587},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1694138936586},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1694138936587},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":1694138936588},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1694138936584},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1694138936589},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1694138936588},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1694138936583},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1694138936591},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1694138941494},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1694138936582},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1694138941492},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1694138941494},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1694138941502},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1694138936585},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1694138936587},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1694138936591},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1694138936592},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1694138941495},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1694138936590},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1694138936586},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":1694138941496},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1694138941497},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1694138941497},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1694138941499},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1694138941499},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1694138941500},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1694138941501},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1694138941502},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1694138941501},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1694138941498},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1694138941500},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1694138940933},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1694138941490},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1694138940833},{"_id":"public/2023/09/08/hello-world/index.html","hash":"7ddf1c280a9359a5fd2fa1dc25a1a6b2265ae02a","modified":1694144476669},{"_id":"public/archives/index.html","hash":"a80425857fb5165cf2424976e843c8d54f689ecb","modified":1694614275229},{"_id":"public/archives/2023/09/index.html","hash":"ed0bd6cfc7b6d53e2db7d913839ae885f3b8fdb8","modified":1694614275229},{"_id":"public/index.html","hash":"000efda06bff61325f80249853f2acc8fecfdb07","modified":1694616415821},{"_id":"public/archives/2023/index.html","hash":"37c3cc55783cb6a676eaacb8e5f0fc1495e8479b","modified":1694614275229},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1694139003446},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1694139003446},{"_id":"public/css/style.css","hash":"ddb3792605d744ab3d9f0a649c82b62e9b16daa6","modified":1694139003446},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1694139003446},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1694139003446},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1694139003446},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688287284000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1688287284000},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1688287284000},{"_id":"themes/fluid/README_en.md","hash":"49541d4ec48c4b517c5b3fe17a2e92d87090d007","modified":1688287284000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1688287284000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1688287284000},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1688287284000},{"_id":"themes/fluid/package.json","hash":"41983970c0977b3c626c3f1e3c714cf78ac6a04e","modified":1688287284000},{"_id":"themes/fluid/_config.yml","hash":"b9d7ec23c84a6ceec69d1faa3e9f9e77cb4d3acf","modified":1694616137595},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1688287284000},{"_id":"themes/fluid/README.md","hash":"49f681a203eecfa7127ac22edc13bd3b49693d0a","modified":1688287284000},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1688287284000},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1688287284000},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1688287284000},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1688287284000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"ff682cdd587cf5346bf0486943575d7121bab85a","modified":1694140539711},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1688287284000},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1688287284000},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1688287284000},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1688287284000},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1688287284000},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1688287284000},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1688287284000},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1688287284000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1688287284000},{"_id":"themes/fluid/layout/index.ejs","hash":"9b4c154462ce78de4c9ea7dd15dce4ca8e8c1cf8","modified":1688287284000},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1688287284000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1688287284000},{"_id":"themes/fluid/layout/post.ejs","hash":"75ab6958d929e92566ca580d0b8bd0eeae10649a","modified":1688287284000},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1688287284000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"c8b0d49c49e3c88872fd3b37909345ff5b2b6aa0","modified":1688287284000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1688287284000},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1688287284000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"554c0d0e086a0784d83ee71c83f8bceeb60aecc8","modified":1688287284000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"fff07ce0472afc368d388637cb9d438195da9b5b","modified":1688287284000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1688287284000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1688287284000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1688287284000},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"6f02e6440d88629229556e3fd47d0280fe2240db","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1688287284000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1688287284000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1688287284000},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1688287284000},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1688287284000},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1688287284000},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1688287284000},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1688287284000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1688287284000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1688287284000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1688287284000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1688287284000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1688287284000},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1688287284000},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1688287284000},{"_id":"themes/fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1688287284000},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1688287284000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1688287284000},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1688287284000},{"_id":"themes/fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1688287284000},{"_id":"themes/fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1688287284000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1688287284000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"0047666f996c54017e06668b5242ed8a311ebce0","modified":1688287284000},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1688287284000},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1688287284000},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1688287284000},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1688287284000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1688287284000},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1688287284000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1688287284000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"b2f61b91fffb17d11ad56811f07d52d23f012741","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"8d3ae1ec6660fbb0e563bc08c2f8deefde1f3bf6","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1688287284000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"ecf3488566b374d564ae985c61e08562ba908023","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"e413212e5a667d5b8299c4d2a39c4dfa1378d119","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1688287284000},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1688287284000},{"_id":"public/local-search.xml","hash":"c4a730cc92f2275f3cd933d85346c5d3eb5934c5","modified":1694652960905},{"_id":"public/404.html","hash":"78376c42c80c91a1cd342631504b9736049f5ad0","modified":1694150173543},{"_id":"public/tags/index.html","hash":"75355974ef6f061a1d17b6ab3e0c5b03703f9302","modified":1694614275229},{"_id":"public/categories/index.html","hash":"c3c895cfc1c285d6d127c472aeff59486972a061","modified":1694612111740},{"_id":"public/links/index.html","hash":"88dc2ae72de11fcb35d84b6b968ff34be8c68589","modified":1694150173543},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1694139654662},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1694139654662},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1694139654662},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1694139654662},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1694139654662},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1694139654662},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1694139654662},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1694139654662},{"_id":"public/css/main.css","hash":"526a4522eb54bb51772f51fb98295dc4fe03429f","modified":1694139654662},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1694139654662},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1694139654662},{"_id":"public/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1694139654662},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1694139654662},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1694139654662},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1694139654662},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1694139654662},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1694139654662},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1694139654662},{"_id":"source/about/index.md","hash":"d077c776a87f0e228f36a7f92fcc15a69ac0788f","modified":1694343315498},{"_id":"themes/fluid/source/img/wechat_qrcode.jpg","hash":"51738de396fd8396c8f516443dea460ae9b93272","modified":1694141335870},{"_id":"themes/fluid/source/img/greywind_avatar.png","hash":"3ce40793abab7f80a4eab98b39b7ca220d7f7644","modified":1694141417693},{"_id":"themes/fluid/source/img/background.png","hash":"98f0b9dfc2e89be2725564103a08ddc7f799bc5d","modified":1694149242901},{"_id":"source/_posts/针对九龙冰室的预制菜行为的反馈.md","hash":"3e8d136758f47ba5fe03458aec7816cde1a06858","modified":1694616409727},{"_id":"public/about/index.html","hash":"8c48a19784f81fc245a2c83d1518de679d02b911","modified":1694343336558},{"_id":"public/2023/09/08/针对九龙冰室的预制菜行为的反馈/index.html","hash":"27863f3081bbf6bdf1c0f7147afa7f22e2f4c47c","modified":1694616415821},{"_id":"public/img/greywind_avatar.png","hash":"3ce40793abab7f80a4eab98b39b7ca220d7f7644","modified":1694144476669},{"_id":"public/img/wechat_qrcode.jpg","hash":"51738de396fd8396c8f516443dea460ae9b93272","modified":1694144476669},{"_id":"public/img/background.png","hash":"e2f7892f4bfc4e66bbd65d434a731573df757cfc","modified":1694144476669},{"_id":"source/公告/index.md","hash":"a87b323ed28496fffcb82d45645604bcfe2de5e2","modified":1694145599346},{"_id":"public/公告/index.html","hash":"96d0cbbc8515685ca0edebad039f3ff76de30c7d","modified":1694150173543},{"_id":"public/categories/公告/index.html","hash":"4b01f2c7a150f02d341e56da39b7426a2e38506b","modified":1694150173543},{"_id":"public/tags/餐饮/index.html","hash":"993ad8acf588210eaf2d6e102e81c9efad0bba1b","modified":1694150173543},{"_id":"source/_posts/Visual-Basic调用Shell.md","hash":"871ef54daca27108c8e0d15fa16e6d6af9334050","modified":1694653027172},{"_id":"public/tags/编程/index.html","hash":"7a69ee2617fcf8dd623c6b0685c19ff52f364a02","modified":1694614275229},{"_id":"public/categories/各语言执行Shell/index.html","hash":"6ca4e4d86850ec1962a8e15c2c6df6ea37c894ef","modified":1694612111740},{"_id":"public/2023/09/09/Visual-Basic调用Shell/index.html","hash":"ec6e03001f34c2df94a17faf172bc7ee250e1f97","modified":1694653029526},{"_id":"source/_posts/C执行Shell.md","hash":"d2c9ce3b110111ee023697c51f7d4378a0cc1a32","modified":1694616287438},{"_id":"public/2023/09/09/C执行Shell/index.html","hash":"0e281d7dfec82970772b95b12cb52cacf8aff3ee","modified":1694616415821},{"_id":"source/_posts/C++执行Shell.md","hash":"73243b09947cdad25158a41e15adbb2b7e596d0a","modified":1694616285017},{"_id":"public/2023/09/09/C++执行Shell/index.html","hash":"843995c1b113a82c23c5aece6a2cfc6c70898f83","modified":1694616415821},{"_id":"source/_posts/Rust执行Shell.md","hash":"e05e1e2ce63e9ff3ba8c194c69ac678ac3229f79","modified":1694616312489},{"_id":"public/2023/09/10/Rust执行Shell/index.html","hash":"93114469636bbdd504b31c883fff809b13f4fec5","modified":1694616415821},{"_id":"source/_posts/C#执行Shell.md","hash":"f5d0885bc27df3fb8c2082059e069e9890b8096a","modified":1694339465194},{"_id":"public/2023/09/10/C#执行Shell/index.html","hash":"a6f2467bfa882e3b22d0f88fcea17fb0dbc90539","modified":1694339473122},{"_id":"source/_posts/C-Sharp执行Shell.md","hash":"cd842a1aed91f8f7309987582945119736bc85c9","modified":1694616266378},{"_id":"public/2023/09/10/C-Sharp执行Shell/index.html","hash":"ff182418062540b8e66c984219f2ea230f0a3109","modified":1694616415821},{"_id":"source/_posts/Node执行Shell.md","hash":"28b9630071704fc5c332177fbfaa112b748b228d","modified":1694616292709},{"_id":"public/2023/09/10/Node执行Shell/index.html","hash":"935c53f3705d3b0ba3a971475a6ad380c0c7dcc4","modified":1694616415821},{"_id":"source/_posts/Scala执行Shell.md","hash":"141003f66ed9de059a9552fe977466dd0627168c","modified":1694616315356},{"_id":"public/2023/09/10/Scala执行Shell/index.html","hash":"99c100df6df7215e7f2b194cf7fa7afb06251670","modified":1694616415821},{"_id":"source/_posts/Qml执行Shell.md","hash":"d229230d649b65ed7bf3deec5a483522149bb193","modified":1694616309062},{"_id":"public/2023/09/10/Qml执行Shell/index.html","hash":"15ef677ddf829b2dc876d5239b0e2f63e7154056","modified":1694616415821},{"_id":"source/_posts/Python执行Shell.md","hash":"783fdef5a383bdeae2addafefa5662259f343fc8","modified":1694616305266},{"_id":"public/2023/09/10/Python执行Shell/index.html","hash":"7a681f4215282513c4bd369a0285b0e2976ef391","modified":1694616415821},{"_id":"source/_posts/F-Sharp执行Shell.md","hash":"48f7d00011a6e2964098747006e0b530da964d56","modified":1694616290096},{"_id":"public/archives/page/2/index.html","hash":"458ad3eb386c0980f85bbc6727ff015407170422","modified":1694652960905},{"_id":"public/archives/2023/page/2/index.html","hash":"16ca96ff2cbadd6e9bcf5a38d2e3d52f7d93ebbc","modified":1694652960905},{"_id":"public/archives/2023/09/page/2/index.html","hash":"471b8d71ead911bb546bfdc8d6e6549378612c29","modified":1694652960905},{"_id":"public/page/2/index.html","hash":"e61d679f5ca95166edc91331621952592c8e0f9f","modified":1694653029526},{"_id":"public/2023/09/10/F-Sharp执行Shell/index.html","hash":"3b9d3dd819d55f03a9fb63071aec92b53968c737","modified":1694616415821},{"_id":"source/_posts/Typescript执行Shell.md","hash":"44af061216a4ee91a332597bf8ccaa7278740b13","modified":1694616318040},{"_id":"public/categories/各语言执行Shell/page/2/index.html","hash":"70277e9cf877fe864c1bcc23d8d9160073a87ea0","modified":1694652960905},{"_id":"public/tags/编程/page/2/index.html","hash":"da79245e96012b9c5c28905ae52ff55a5e0104a2","modified":1694652960905},{"_id":"public/2023/09/10/Typescript执行Shell/index.html","hash":"b7a15e592ef738558c0a9e758e5820c3c66671b1","modified":1694616415821},{"_id":"source/_posts/Objective-C执行Shell.md","hash":"73f28e49c2cbe8eb652336941fb3bd3e9af9417e","modified":1694616298379},{"_id":"public/2023/09/10/Objective-C执行Shell/index.html","hash":"d09df6ef9c9d34b19f1404c434d60119fefa8aaa","modified":1694616415821},{"_id":"source/_posts/Objective-C++执行Shell.md","hash":"c652fb91ba2efe5d7bd8faea851752ec76d044ae","modified":1694616295503},{"_id":"public/2023/09/10/Objective-C++执行Shell/index.html","hash":"7ca3290f664ca7beff2f23a87d5013b876cac688","modified":1694616415821},{"_id":"source/_posts/PHP执行Shell.md","hash":"a82fa66d65c7f8260a9971fb5e2c4bf4d8681cbc","modified":1694616302495},{"_id":"public/2023/09/13/PHP执行Shell/index.html","hash":"224e96e6fb683bc39f8f91baae717a33796f2544","modified":1694616415821},{"_id":"public/tags/C/index.html","hash":"7688347c4156e5be1f7dfa2207aca0a57f859c1d","modified":1694612317407},{"_id":"public/tags/C-Sharp/index.html","hash":"0f78c1874616c0a00464e7bc952f789e2c7e5e98","modified":1694614275229},{"_id":"source/_posts/C-WPF-NET-Framework-窗口使用HTML页面.md","hash":"b3e3be1ed00fe88f857d30d281c0964bd444d6b3","modified":1694616281862},{"_id":"public/tags/HTML/index.html","hash":"3c9190f188dc13ffc5e893dd169cf9707a83eecf","modified":1694614275229},{"_id":"public/2023/09/13/C-WPF-NET-Framework-窗口使用HTML页面/index.html","hash":"243689db4813b4790b2e28f6c783626a00916de6","modified":1694616415821}],"Category":[{"name":"公告","_id":"clma2lvt80000jk5gf9lg3c1i"},{"name":"各语言执行Shell","_id":"clmc1mnfh0001jk5g20xt7b9r"}],"Data":[],"Page":[{"title":"about","layout":"about","date":"2023-09-08T02:36:43.000Z","_content":"\n# 关于\n\n青衣的个人博客网站，偶尔会发布一些工作室的公告。\n\n通常是一些实用教程。\n","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ndate: 2023-09-08 10:36:43\n---\n\n# 关于\n\n青衣的个人博客网站，偶尔会发布一些工作室的公告。\n\n通常是一些实用教程。\n","updated":"2023-09-10T10:55:15.498Z","path":"about/index.html","_id":"clm9zmojg0000z45ghr8idlpv","comments":1,"content":"<h1 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h1><p>青衣的个人博客网站，偶尔会发布一些工作室的公告。</p>\n<p>通常是一些实用教程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h1><p>青衣的个人博客网站，偶尔会发布一些工作室的公告。</p>\n<p>通常是一些实用教程。</p>\n"}],"Post":[{"title":"针对九龙冰室的预制菜行为的反馈","date":"2023-09-08T03:29:22.000Z","author":"Sunrise Studio","_content":"\n# 针对九龙冰室不负责任的预制菜行为的回应\n\n本人(即灰风，不方便透露名字)在2023年8月31日中午十二点左右于上海市长宁区南丰城B1九龙冰室就餐，共消费62元，购买了一份鸡扒饭与灯胆奶茶。\n\n在鸡扒饭上桌后，我尝了一下，边缘的米饭是凉的，我误以为是边缘处凉的较快，在之后我吃到里面的饭也是凉的，我感到十分不可思议。\n\n在饭点，作为一家连锁粤菜餐厅，竟然上了一盘预制菜给我，这令我十分不解与震撼。当然，鸡扒饭里的肉和蛋都是当天现做，不过对于米饭预制这件事我由于当日下午还有其它事务没有与服务员过多纠缠，让他们热好就结账走了，九龙冰室服务员将他们灯胆奶茶的杯子赠与我以示歉意，我当时接受了，但我认为这是封口费。\n\n事件讲述完毕，对此，我的回应是从2023年九月开始，本人以及所有工作室成员不会再前往九龙冰室，同时，也会与周边人士通知此事，祝你们品牌关门大吉！\n","source":"_posts/针对九龙冰室的预制菜行为的反馈.md","raw":"---\ntitle: 针对九龙冰室的预制菜行为的反馈\ndate: 2023-09-08 11:29:22\nauthor: \"Sunrise Studio\"\ncategories:\n- 公告\ntags:\n- 餐饮\n---\n\n# 针对九龙冰室不负责任的预制菜行为的回应\n\n本人(即灰风，不方便透露名字)在2023年8月31日中午十二点左右于上海市长宁区南丰城B1九龙冰室就餐，共消费62元，购买了一份鸡扒饭与灯胆奶茶。\n\n在鸡扒饭上桌后，我尝了一下，边缘的米饭是凉的，我误以为是边缘处凉的较快，在之后我吃到里面的饭也是凉的，我感到十分不可思议。\n\n在饭点，作为一家连锁粤菜餐厅，竟然上了一盘预制菜给我，这令我十分不解与震撼。当然，鸡扒饭里的肉和蛋都是当天现做，不过对于米饭预制这件事我由于当日下午还有其它事务没有与服务员过多纠缠，让他们热好就结账走了，九龙冰室服务员将他们灯胆奶茶的杯子赠与我以示歉意，我当时接受了，但我认为这是封口费。\n\n事件讲述完毕，对此，我的回应是从2023年九月开始，本人以及所有工作室成员不会再前往九龙冰室，同时，也会与周边人士通知此事，祝你们品牌关门大吉！\n","slug":"针对九龙冰室的预制菜行为的反馈","published":1,"updated":"2023-09-13T14:46:49.727Z","_id":"clma1hhtg0000qk5g6pq5amt7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"针对九龙冰室不负责任的预制菜行为的回应\"><a href=\"#针对九龙冰室不负责任的预制菜行为的回应\" class=\"headerlink\" title=\"针对九龙冰室不负责任的预制菜行为的回应\"></a>针对九龙冰室不负责任的预制菜行为的回应</h1><p>本人(即灰风，不方便透露名字)在2023年8月31日中午十二点左右于上海市长宁区南丰城B1九龙冰室就餐，共消费62元，购买了一份鸡扒饭与灯胆奶茶。</p>\n<p>在鸡扒饭上桌后，我尝了一下，边缘的米饭是凉的，我误以为是边缘处凉的较快，在之后我吃到里面的饭也是凉的，我感到十分不可思议。</p>\n<p>在饭点，作为一家连锁粤菜餐厅，竟然上了一盘预制菜给我，这令我十分不解与震撼。当然，鸡扒饭里的肉和蛋都是当天现做，不过对于米饭预制这件事我由于当日下午还有其它事务没有与服务员过多纠缠，让他们热好就结账走了，九龙冰室服务员将他们灯胆奶茶的杯子赠与我以示歉意，我当时接受了，但我认为这是封口费。</p>\n<p>事件讲述完毕，对此，我的回应是从2023年九月开始，本人以及所有工作室成员不会再前往九龙冰室，同时，也会与周边人士通知此事，祝你们品牌关门大吉！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"针对九龙冰室不负责任的预制菜行为的回应\"><a href=\"#针对九龙冰室不负责任的预制菜行为的回应\" class=\"headerlink\" title=\"针对九龙冰室不负责任的预制菜行为的回应\"></a>针对九龙冰室不负责任的预制菜行为的回应</h1><p>本人(即灰风，不方便透露名字)在2023年8月31日中午十二点左右于上海市长宁区南丰城B1九龙冰室就餐，共消费62元，购买了一份鸡扒饭与灯胆奶茶。</p>\n<p>在鸡扒饭上桌后，我尝了一下，边缘的米饭是凉的，我误以为是边缘处凉的较快，在之后我吃到里面的饭也是凉的，我感到十分不可思议。</p>\n<p>在饭点，作为一家连锁粤菜餐厅，竟然上了一盘预制菜给我，这令我十分不解与震撼。当然，鸡扒饭里的肉和蛋都是当天现做，不过对于米饭预制这件事我由于当日下午还有其它事务没有与服务员过多纠缠，让他们热好就结账走了，九龙冰室服务员将他们灯胆奶茶的杯子赠与我以示歉意，我当时接受了，但我认为这是封口费。</p>\n<p>事件讲述完毕，对此，我的回应是从2023年九月开始，本人以及所有工作室成员不会再前往九龙冰室，同时，也会与周边人士通知此事，祝你们品牌关门大吉！</p>\n"},{"title":"Visual Basic执行Shell","date":"2023-09-09T11:39:11.000Z","author":"Grey-Wind","excerpt":"使用Shell或Windows Script Host对象模型来执行Shell。","_content":"\n# Visual Basic执行Shell\n\n使用Visual Studio创建一个Visual Basic项目，本文以控制台项目演示。\n\n输入以下代码\n\n```visual basic\nModule Module1\n\n    Sub Main()\n        Shell(\"cmd.exe /c echo 1&&pause\")\n    End Sub\n\nEnd Module\n```\n\nVisual Studio可能自动生成了除shell以外的代码。\n\n调整执行命令只需修改本代码段“echo 1”与“pause”即可。\n\n------\n\n当然，以下是一个自定义度更高的方法，读取输出也更加方便，但是仅限Windows平台。\n\n代码如下：\n\n```visual basic\nDim command As String\ncommand = \"dir\"\n\nDim shell As Object\nSet shell = CreateObject(\"WScript.Shell\")\n\nDim exec As Object\nSet exec = shell.Exec(\"cmd /c \" & command)\n\nDo While exec.Status = 0\n    WScript.Sleep 100\nLoop\n\nDim output As String\noutput = exec.StdOut.ReadAll\n\nWScript.Echo output\n```\n\n这段示例代码将执行 dir 命令，并在控制台输出命令的结果。你可以将需要执行的命令赋值给 command 变量。\n\n本代码使用了 Windows Script Host 对象模型，通过 CreateObject() 函数创建了一个 WScript.Shell 对象，并调用其 Exec() 方法来执行 cmd 命令。Exec() 方法返回一个 WshScriptExec 对象，该对象的 Status 属性表示当前命令执行状态，StdOut 属性是一个 TextStream 对象，可以读取命令的输出结果。\n","source":"_posts/Visual-Basic调用Shell.md","raw":"---\ntitle: Visual Basic执行Shell\ndate: 2023-09-09 19:39:11\nauthor: \"Grey-Wind\"\nexcerpt: \"使用Shell或Windows Script Host对象模型来执行Shell。\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Visual Basic执行Shell\n\n使用Visual Studio创建一个Visual Basic项目，本文以控制台项目演示。\n\n输入以下代码\n\n```visual basic\nModule Module1\n\n    Sub Main()\n        Shell(\"cmd.exe /c echo 1&&pause\")\n    End Sub\n\nEnd Module\n```\n\nVisual Studio可能自动生成了除shell以外的代码。\n\n调整执行命令只需修改本代码段“echo 1”与“pause”即可。\n\n------\n\n当然，以下是一个自定义度更高的方法，读取输出也更加方便，但是仅限Windows平台。\n\n代码如下：\n\n```visual basic\nDim command As String\ncommand = \"dir\"\n\nDim shell As Object\nSet shell = CreateObject(\"WScript.Shell\")\n\nDim exec As Object\nSet exec = shell.Exec(\"cmd /c \" & command)\n\nDo While exec.Status = 0\n    WScript.Sleep 100\nLoop\n\nDim output As String\noutput = exec.StdOut.ReadAll\n\nWScript.Echo output\n```\n\n这段示例代码将执行 dir 命令，并在控制台输出命令的结果。你可以将需要执行的命令赋值给 command 变量。\n\n本代码使用了 Windows Script Host 对象模型，通过 CreateObject() 函数创建了一个 WScript.Shell 对象，并调用其 Exec() 方法来执行 cmd 命令。Exec() 方法返回一个 WshScriptExec 对象，该对象的 Status 属性表示当前命令执行状态，StdOut 属性是一个 TextStream 对象，可以读取命令的输出结果。\n","slug":"Visual-Basic调用Shell","published":1,"updated":"2023-09-14T00:57:07.172Z","_id":"clmc1mnfd0000jk5g9x270cvu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Visual-Basic执行Shell\"><a href=\"#Visual-Basic执行Shell\" class=\"headerlink\" title=\"Visual Basic执行Shell\"></a>Visual Basic执行Shell</h1><p>使用Visual Studio创建一个Visual Basic项目，本文以控制台项目演示。</p>\n<p>输入以下代码</p>\n<figure class=\"highlight plaintext\"><figcaption><span>basic</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs visual\">Module Module1<br><br>    Sub Main()<br>        Shell(&quot;cmd.exe /c echo 1&amp;&amp;pause&quot;)<br>    End Sub<br><br>End Module<br></code></pre></td></tr></table></figure>\n\n<p>Visual Studio可能自动生成了除shell以外的代码。</p>\n<p>调整执行命令只需修改本代码段“echo 1”与“pause”即可。</p>\n<hr>\n<p>当然，以下是一个自定义度更高的方法，读取输出也更加方便，但是仅限Windows平台。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>basic</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs visual\">Dim command As String<br>command = &quot;dir&quot;<br><br>Dim shell As Object<br>Set shell = CreateObject(&quot;WScript.Shell&quot;)<br><br>Dim exec As Object<br>Set exec = shell.Exec(&quot;cmd /c &quot; &amp; command)<br><br>Do While exec.Status = 0<br>    WScript.Sleep 100<br>Loop<br><br>Dim output As String<br>output = exec.StdOut.ReadAll<br><br>WScript.Echo output<br></code></pre></td></tr></table></figure>\n\n<p>这段示例代码将执行 dir 命令，并在控制台输出命令的结果。你可以将需要执行的命令赋值给 command 变量。</p>\n<p>本代码使用了 Windows Script Host 对象模型，通过 CreateObject() 函数创建了一个 WScript.Shell 对象，并调用其 Exec() 方法来执行 cmd 命令。Exec() 方法返回一个 WshScriptExec 对象，该对象的 Status 属性表示当前命令执行状态，StdOut 属性是一个 TextStream 对象，可以读取命令的输出结果。</p>\n","site":{"data":{}},"more":"<h1 id=\"Visual-Basic执行Shell\"><a href=\"#Visual-Basic执行Shell\" class=\"headerlink\" title=\"Visual Basic执行Shell\"></a>Visual Basic执行Shell</h1><p>使用Visual Studio创建一个Visual Basic项目，本文以控制台项目演示。</p>\n<p>输入以下代码</p>\n<figure class=\"highlight plaintext\"><figcaption><span>basic</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs visual\">Module Module1<br><br>    Sub Main()<br>        Shell(&quot;cmd.exe /c echo 1&amp;&amp;pause&quot;)<br>    End Sub<br><br>End Module<br></code></pre></td></tr></table></figure>\n\n<p>Visual Studio可能自动生成了除shell以外的代码。</p>\n<p>调整执行命令只需修改本代码段“echo 1”与“pause”即可。</p>\n<hr>\n<p>当然，以下是一个自定义度更高的方法，读取输出也更加方便，但是仅限Windows平台。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>basic</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs visual\">Dim command As String<br>command = &quot;dir&quot;<br><br>Dim shell As Object<br>Set shell = CreateObject(&quot;WScript.Shell&quot;)<br><br>Dim exec As Object<br>Set exec = shell.Exec(&quot;cmd /c &quot; &amp; command)<br><br>Do While exec.Status = 0<br>    WScript.Sleep 100<br>Loop<br><br>Dim output As String<br>output = exec.StdOut.ReadAll<br><br>WScript.Echo output<br></code></pre></td></tr></table></figure>\n\n<p>这段示例代码将执行 dir 命令，并在控制台输出命令的结果。你可以将需要执行的命令赋值给 command 变量。</p>\n<p>本代码使用了 Windows Script Host 对象模型，通过 CreateObject() 函数创建了一个 WScript.Shell 对象，并调用其 Exec() 方法来执行 cmd 命令。Exec() 方法返回一个 WshScriptExec 对象，该对象的 Status 属性表示当前命令执行状态，StdOut 属性是一个 TextStream 对象，可以读取命令的输出结果。</p>\n"},{"title":"C执行Shell","date":"2023-09-09T13:22:18.000Z","author":"Grey-Wind","_content":"\n# C执行Shell\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char command[1000] = \"dir\"; // 将要执行的 cmd 命令\n    FILE *fp = NULL;\n    char res[1024];\n\n    fp = popen(command, \"r\"); // 执行命令，并打开读取管道\n     \n    if (fp == NULL) { // 判断是否成功打开管道\n        printf(\"运行命令失败\\n\");\n        exit(1);\n    }\n     \n    while (fgets(res, sizeof(res), fp) != NULL) { // 从管道中读取输出结果\n        printf(\"%s\", res);\n    }\n    \n    pclose(fp); // 关闭管道\n    return 0;\n\n}\n```\n\n这个示例代码将执行 dir 命令，并输出命令的输出结果。可以替换 command 变量的值为需要执行的命令。\n\n这个实现使用了标准 C 库函数中的 popen() 和 pclose() 函数来执行命令和关闭读取管道。popen() 函数打开一个管道用于读取命令的输出，返回的文件指针 fp 可以用于读取管道中的内容。pclose() 函数关闭读取管道。\n","source":"_posts/C执行Shell.md","raw":"---\ntitle: C执行Shell\ndate: 2023-09-09 21:22:18\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# C执行Shell\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char command[1000] = \"dir\"; // 将要执行的 cmd 命令\n    FILE *fp = NULL;\n    char res[1024];\n\n    fp = popen(command, \"r\"); // 执行命令，并打开读取管道\n     \n    if (fp == NULL) { // 判断是否成功打开管道\n        printf(\"运行命令失败\\n\");\n        exit(1);\n    }\n     \n    while (fgets(res, sizeof(res), fp) != NULL) { // 从管道中读取输出结果\n        printf(\"%s\", res);\n    }\n    \n    pclose(fp); // 关闭管道\n    return 0;\n\n}\n```\n\n这个示例代码将执行 dir 命令，并输出命令的输出结果。可以替换 command 变量的值为需要执行的命令。\n\n这个实现使用了标准 C 库函数中的 popen() 和 pclose() 函数来执行命令和关闭读取管道。popen() 函数打开一个管道用于读取命令的输出，返回的文件指针 fp 可以用于读取管道中的内容。pclose() 函数关闭读取管道。\n","slug":"C执行Shell","published":1,"updated":"2023-09-13T14:44:47.438Z","_id":"clmc256tt00008o5gdr5a87v4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"C执行Shell\"><a href=\"#C执行Shell\" class=\"headerlink\" title=\"C执行Shell\"></a>C执行Shell</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">char</span> command[<span class=\"hljs-number\">1000</span>] = <span class=\"hljs-string\">&quot;dir&quot;</span>; <span class=\"hljs-comment\">// 将要执行的 cmd 命令</span><br>    FILE *fp = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">char</span> res[<span class=\"hljs-number\">1024</span>];<br><br>    fp = popen(command, <span class=\"hljs-string\">&quot;r&quot;</span>); <span class=\"hljs-comment\">// 执行命令，并打开读取管道</span><br>     <br>    <span class=\"hljs-keyword\">if</span> (fp == <span class=\"hljs-literal\">NULL</span>) &#123; <span class=\"hljs-comment\">// 判断是否成功打开管道</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;运行命令失败\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>     <br>    <span class=\"hljs-keyword\">while</span> (fgets(res, <span class=\"hljs-keyword\">sizeof</span>(res), fp) != <span class=\"hljs-literal\">NULL</span>) &#123; <span class=\"hljs-comment\">// 从管道中读取输出结果</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>, res);<br>    &#125;<br>    <br>    pclose(fp); <span class=\"hljs-comment\">// 关闭管道</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个示例代码将执行 dir 命令，并输出命令的输出结果。可以替换 command 变量的值为需要执行的命令。</p>\n<p>这个实现使用了标准 C 库函数中的 popen() 和 pclose() 函数来执行命令和关闭读取管道。popen() 函数打开一个管道用于读取命令的输出，返回的文件指针 fp 可以用于读取管道中的内容。pclose() 函数关闭读取管道。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C执行Shell\"><a href=\"#C执行Shell\" class=\"headerlink\" title=\"C执行Shell\"></a>C执行Shell</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-type\">char</span> command[<span class=\"hljs-number\">1000</span>] = <span class=\"hljs-string\">&quot;dir&quot;</span>; <span class=\"hljs-comment\">// 将要执行的 cmd 命令</span><br>    FILE *fp = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">char</span> res[<span class=\"hljs-number\">1024</span>];<br><br>    fp = popen(command, <span class=\"hljs-string\">&quot;r&quot;</span>); <span class=\"hljs-comment\">// 执行命令，并打开读取管道</span><br>     <br>    <span class=\"hljs-keyword\">if</span> (fp == <span class=\"hljs-literal\">NULL</span>) &#123; <span class=\"hljs-comment\">// 判断是否成功打开管道</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;运行命令失败\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>     <br>    <span class=\"hljs-keyword\">while</span> (fgets(res, <span class=\"hljs-keyword\">sizeof</span>(res), fp) != <span class=\"hljs-literal\">NULL</span>) &#123; <span class=\"hljs-comment\">// 从管道中读取输出结果</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>, res);<br>    &#125;<br>    <br>    pclose(fp); <span class=\"hljs-comment\">// 关闭管道</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个示例代码将执行 dir 命令，并输出命令的输出结果。可以替换 command 变量的值为需要执行的命令。</p>\n<p>这个实现使用了标准 C 库函数中的 popen() 和 pclose() 函数来执行命令和关闭读取管道。popen() 函数打开一个管道用于读取命令的输出，返回的文件指针 fp 可以用于读取管道中的内容。pclose() 函数关闭读取管道。</p>\n"},{"title":"C++执行Shell","date":"2023-09-09T13:28:17.000Z","author":"Grey-Wind","_content":"\n# C++执行Shell\n\n代码如下\n\n```c++\n#include <iostream>\n\nint main() {\n    std::string command = \"dir\"; // 将要执行的 cmd 命令(例如ipconfig，ping等)\n    int result = system(command.c_str()); // 执行命令，并获得返回值\n    std::cout << \"Command result: \" << result << std::endl; // 输出返回值\n\n    return 0;\n\n}\n```\n\n示例代码将执行 dir 命令，并输出命令的返回值。\n","source":"_posts/C++执行Shell.md","raw":"---\ntitle: C++执行Shell\ndate: 2023-09-09 21:28:17\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# C++执行Shell\n\n代码如下\n\n```c++\n#include <iostream>\n\nint main() {\n    std::string command = \"dir\"; // 将要执行的 cmd 命令(例如ipconfig，ping等)\n    int result = system(command.c_str()); // 执行命令，并获得返回值\n    std::cout << \"Command result: \" << result << std::endl; // 输出返回值\n\n    return 0;\n\n}\n```\n\n示例代码将执行 dir 命令，并输出命令的返回值。\n","slug":"C++执行Shell","published":1,"updated":"2023-09-13T14:44:45.017Z","_id":"clmc2cg6200007c5g72fs0hb0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"C-执行Shell\"><a href=\"#C-执行Shell\" class=\"headerlink\" title=\"C++执行Shell\"></a>C++执行Shell</h1><p>代码如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::string command = <span class=\"hljs-string\">&quot;dir&quot;</span>; <span class=\"hljs-comment\">// 将要执行的 cmd 命令(例如ipconfig，ping等)</span><br>    <span class=\"hljs-type\">int</span> result = <span class=\"hljs-built_in\">system</span>(command.<span class=\"hljs-built_in\">c_str</span>()); <span class=\"hljs-comment\">// 执行命令，并获得返回值</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Command result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class=\"hljs-comment\">// 输出返回值</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>示例代码将执行 dir 命令，并输出命令的返回值。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-执行Shell\"><a href=\"#C-执行Shell\" class=\"headerlink\" title=\"C++执行Shell\"></a>C++执行Shell</h1><p>代码如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::string command = <span class=\"hljs-string\">&quot;dir&quot;</span>; <span class=\"hljs-comment\">// 将要执行的 cmd 命令(例如ipconfig，ping等)</span><br>    <span class=\"hljs-type\">int</span> result = <span class=\"hljs-built_in\">system</span>(command.<span class=\"hljs-built_in\">c_str</span>()); <span class=\"hljs-comment\">// 执行命令，并获得返回值</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Command result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class=\"hljs-comment\">// 输出返回值</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>示例代码将执行 dir 命令，并输出命令的返回值。</p>\n"},{"title":"Rust执行CMD","date":"2023-09-10T09:39:55.000Z","author":"Grey-Wind","_content":"\n# Rust执行Shell\n\n使用Cargo创建一个Rust项目。\n\n```rust\nuse std::process::Command;  \n\nfn main() {\n    let _ = Command::new(\"cmd.exe\").arg(\"/c\").arg(\"pause\").status();\n}\n```\n\n可以将 .arg(\"pause\") 中的内容替换为其他命令。\n","source":"_posts/Rust执行Shell.md","raw":"---\ntitle: Rust执行CMD\ndate: 2023-09-10 17:39:55\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Rust执行Shell\n\n使用Cargo创建一个Rust项目。\n\n```rust\nuse std::process::Command;  \n\nfn main() {\n    let _ = Command::new(\"cmd.exe\").arg(\"/c\").arg(\"pause\").status();\n}\n```\n\n可以将 .arg(\"pause\") 中的内容替换为其他命令。\n","slug":"Rust执行Shell","published":1,"updated":"2023-09-13T14:45:12.489Z","_id":"clmd9mnh700001w5g7wyoc4yl","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Rust执行Shell\"><a href=\"#Rust执行Shell\" class=\"headerlink\" title=\"Rust执行Shell\"></a>Rust执行Shell</h1><p>使用Cargo创建一个Rust项目。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> std::process::Command;  <br><br><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() &#123;<br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">_</span> = Command::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-string\">&quot;cmd.exe&quot;</span>).<span class=\"hljs-title function_ invoke__\">arg</span>(<span class=\"hljs-string\">&quot;/c&quot;</span>).<span class=\"hljs-title function_ invoke__\">arg</span>(<span class=\"hljs-string\">&quot;pause&quot;</span>).<span class=\"hljs-title function_ invoke__\">status</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以将 .arg(“pause”) 中的内容替换为其他命令。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Rust执行Shell\"><a href=\"#Rust执行Shell\" class=\"headerlink\" title=\"Rust执行Shell\"></a>Rust执行Shell</h1><p>使用Cargo创建一个Rust项目。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs rust\"><span class=\"hljs-keyword\">use</span> std::process::Command;  <br><br><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() &#123;<br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">_</span> = Command::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-string\">&quot;cmd.exe&quot;</span>).<span class=\"hljs-title function_ invoke__\">arg</span>(<span class=\"hljs-string\">&quot;/c&quot;</span>).<span class=\"hljs-title function_ invoke__\">arg</span>(<span class=\"hljs-string\">&quot;pause&quot;</span>).<span class=\"hljs-title function_ invoke__\">status</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以将 .arg(“pause”) 中的内容替换为其他命令。</p>\n"},{"title":"C#执行Shell","date":"2023-09-10T09:44:40.000Z","author":"Grey-Wind","_content":"\n# C#执行Shell\n\n在C#中执行Shell命令有多种方法\n\n## 使用System.Diagnostics.Process类：\n\n```csharp\nstring command = \"ipconfig\";\nProcess process = new Process();\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"cmd.exe\";\nstartInfo.Arguments = \"/c \" + command; // 如果是使用 PowerShell 命令，则将 \"/c\" 改为 \"/k\"\nstartInfo.RedirectStandardOutput = true;\nstartInfo.UseShellExecute = false;\nstartInfo.CreateNoWindow = true;\n\nprocess.StartInfo = startInfo;\nprocess.Start();\n\nstring output = process.StandardOutput.ReadToEnd();\n\nprocess.WaitForExit();\n```\n\n## 使用System.Diagnostics.Process类和PowerShell：\n\n```csharp\nstring command = \"Get-Process\";\nProcess process = new Process();\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"powershell.exe\";\nstartInfo.Arguments = command;\nstartInfo.RedirectStandardOutput = true;\nstartInfo.UseShellExecute = false;\nstartInfo.CreateNoWindow = true;\n\nprocess.StartInfo = startInfo;\nprocess.Start();\n\nstring output = process.StandardOutput.ReadToEnd();\n\nprocess.WaitForExit();\n```\n\n## 使用System.Management命名空间的ManagementObject类（需要引用System.Management.dll）：\n\n```csharp\nstring command = \"ipconfig\";\nManagementClass processClass = new ManagementClass(\"Win32_Process\");\nobject[] methodArgs = { command, null, null, 0 };\nobject result = processClass.InvokeMethod(\"Create\", methodArgs);\nint exitCode = Convert.ToInt32(result);\n```\n\n当然，还有其他一些执行Shell命令的方法。以下是其中的两种：\n\n## 使用System.Diagnostics.Process类和WMI（Windows Management Instrumentation）：\n\n```csharp\nstring command = \"ipconfig\";\nProcess process = new Process();\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"cmd.exe\";\nstartInfo.Arguments = \"/c \" + command; // 如果是使用 PowerShell 命令，则将 \"/c\" 改为 \"/k\"\nstartInfo.RedirectStandardOutput = true;\nstartInfo.UseShellExecute = false;\nstartInfo.CreateNoWindow = true;\n\nprocess.StartInfo = startInfo;\nprocess.Start();\n\nstring output = process.StandardOutput.ReadToEnd();\n\nprocess.WaitForExit();\n```\n\n## 使用Microsoft.VisualBasic.Interaction类：\n\n```csharp\nstring command = \"ipconfig\";\nstring output = Microsoft.VisualBasic.Interaction.Shell(command, AppWinStyle.Hide, true, -1);\n```\n\n## 使用System.Runtime.InteropServices引用DLL文件：\n\n```csharp\nusing System.Runtime.InteropServices;\n\n[DllImport(\"kernel32.dll\", SetLastError = true)]\npublic static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes,\n                                        bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory,\n                                        ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n\n[DllImport(\"kernel32.dll\", SetLastError = true)]\npublic static extern void WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);\n\nstruct PROCESS_INFORMATION\n{\n    public IntPtr hProcess;\n    public IntPtr hThread;\n    public int dwProcessId;\n    public int dwThreadId;\n}\n\nstruct STARTUPINFO\n{\n    public int cb;\n    public string lpReserved;\n    public string lpDesktop;\n    public string lpTitle;\n    public int dwX;\n    public int dwY;\n    public int dwXSize;\n    public int dwYSize;\n    public int dwXCountChars;\n    public int dwYCountChars;\n    public int dwFillAttribute;\n    public int dwFlags;\n    public short wShowWindow;\n    public short cbReserved2;\n    public IntPtr lpReserved2;\n    public IntPtr hStdInput;\n    public IntPtr hStdOutput;\n    public IntPtr hStdError;\n}\n\nstatic void Main(string[] args)\n{\n    string command = \"ipconfig\";\n    STARTUPINFO startupInfo = new STARTUPINFO();\n    PROCESS_INFORMATION processInfo = new PROCESS_INFORMATION();\n    \n    bool success = CreateProcess(null, command, IntPtr.Zero, IntPtr.Zero, false, 0, IntPtr.Zero, null, ref startupInfo, out processInfo);\n    if (success)\n    {\n        WaitForSingleObject(processInfo.hProcess, 0xFFFFFFFF);\n    }\n}\n```\n\n这种方法使用了Platform Invoke技术，可以直接调用Windows的API函数来执行Shell命令。请注意，使用此方法需要在代码中引用System.Runtime.InteropServices命名空间，并确保正确设置结构体和函数调用。同样地，在执行Shell命令时，需要谨慎处理输入内容和安全问题。\n\n当然，还有一种方法可以执行Shell命令：\n\n## 使用System.Diagnostics.Process类和PowerShell Core：\n\n```csharp\nstring command = \"ipconfig\";\nProcess process = new Process();\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"pwsh.exe\"; // PowerShell Core的可执行文件路径\nstartInfo.Arguments = \"-Command \" + command;\nstartInfo.RedirectStandardOutput = true;\nstartInfo.UseShellExecute = false;\nstartInfo.CreateNoWindow = true;\n\nprocess.StartInfo = startInfo;\nprocess.Start();\n\nstring output = process.StandardOutput.ReadToEnd();\n\nprocess.WaitForExit();\n```\n\n这种方法使用了PowerShell Core的可执行文件（`pwsh.exe`）来执行Shell命令。需要注意，你需要先安装并配置好PowerShell Core，并将其可执行文件的路径正确填写到代码中(或者添加到环境变量中)。\n\n以上是使用C#执行Shell命令的几种常见方法，可以根据具体需求选择适合的方法进行操作。请务必确保输入内容的安全性，并谨慎处理可能存在的风险。\n","source":"_posts/C-Sharp执行Shell.md","raw":"---\ntitle: C#执行Shell\ndate: 2023-09-10 17:44:40\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n- C-Sharp\n---\n\n# C#执行Shell\n\n在C#中执行Shell命令有多种方法\n\n## 使用System.Diagnostics.Process类：\n\n```csharp\nstring command = \"ipconfig\";\nProcess process = new Process();\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"cmd.exe\";\nstartInfo.Arguments = \"/c \" + command; // 如果是使用 PowerShell 命令，则将 \"/c\" 改为 \"/k\"\nstartInfo.RedirectStandardOutput = true;\nstartInfo.UseShellExecute = false;\nstartInfo.CreateNoWindow = true;\n\nprocess.StartInfo = startInfo;\nprocess.Start();\n\nstring output = process.StandardOutput.ReadToEnd();\n\nprocess.WaitForExit();\n```\n\n## 使用System.Diagnostics.Process类和PowerShell：\n\n```csharp\nstring command = \"Get-Process\";\nProcess process = new Process();\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"powershell.exe\";\nstartInfo.Arguments = command;\nstartInfo.RedirectStandardOutput = true;\nstartInfo.UseShellExecute = false;\nstartInfo.CreateNoWindow = true;\n\nprocess.StartInfo = startInfo;\nprocess.Start();\n\nstring output = process.StandardOutput.ReadToEnd();\n\nprocess.WaitForExit();\n```\n\n## 使用System.Management命名空间的ManagementObject类（需要引用System.Management.dll）：\n\n```csharp\nstring command = \"ipconfig\";\nManagementClass processClass = new ManagementClass(\"Win32_Process\");\nobject[] methodArgs = { command, null, null, 0 };\nobject result = processClass.InvokeMethod(\"Create\", methodArgs);\nint exitCode = Convert.ToInt32(result);\n```\n\n当然，还有其他一些执行Shell命令的方法。以下是其中的两种：\n\n## 使用System.Diagnostics.Process类和WMI（Windows Management Instrumentation）：\n\n```csharp\nstring command = \"ipconfig\";\nProcess process = new Process();\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"cmd.exe\";\nstartInfo.Arguments = \"/c \" + command; // 如果是使用 PowerShell 命令，则将 \"/c\" 改为 \"/k\"\nstartInfo.RedirectStandardOutput = true;\nstartInfo.UseShellExecute = false;\nstartInfo.CreateNoWindow = true;\n\nprocess.StartInfo = startInfo;\nprocess.Start();\n\nstring output = process.StandardOutput.ReadToEnd();\n\nprocess.WaitForExit();\n```\n\n## 使用Microsoft.VisualBasic.Interaction类：\n\n```csharp\nstring command = \"ipconfig\";\nstring output = Microsoft.VisualBasic.Interaction.Shell(command, AppWinStyle.Hide, true, -1);\n```\n\n## 使用System.Runtime.InteropServices引用DLL文件：\n\n```csharp\nusing System.Runtime.InteropServices;\n\n[DllImport(\"kernel32.dll\", SetLastError = true)]\npublic static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes,\n                                        bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory,\n                                        ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n\n[DllImport(\"kernel32.dll\", SetLastError = true)]\npublic static extern void WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);\n\nstruct PROCESS_INFORMATION\n{\n    public IntPtr hProcess;\n    public IntPtr hThread;\n    public int dwProcessId;\n    public int dwThreadId;\n}\n\nstruct STARTUPINFO\n{\n    public int cb;\n    public string lpReserved;\n    public string lpDesktop;\n    public string lpTitle;\n    public int dwX;\n    public int dwY;\n    public int dwXSize;\n    public int dwYSize;\n    public int dwXCountChars;\n    public int dwYCountChars;\n    public int dwFillAttribute;\n    public int dwFlags;\n    public short wShowWindow;\n    public short cbReserved2;\n    public IntPtr lpReserved2;\n    public IntPtr hStdInput;\n    public IntPtr hStdOutput;\n    public IntPtr hStdError;\n}\n\nstatic void Main(string[] args)\n{\n    string command = \"ipconfig\";\n    STARTUPINFO startupInfo = new STARTUPINFO();\n    PROCESS_INFORMATION processInfo = new PROCESS_INFORMATION();\n    \n    bool success = CreateProcess(null, command, IntPtr.Zero, IntPtr.Zero, false, 0, IntPtr.Zero, null, ref startupInfo, out processInfo);\n    if (success)\n    {\n        WaitForSingleObject(processInfo.hProcess, 0xFFFFFFFF);\n    }\n}\n```\n\n这种方法使用了Platform Invoke技术，可以直接调用Windows的API函数来执行Shell命令。请注意，使用此方法需要在代码中引用System.Runtime.InteropServices命名空间，并确保正确设置结构体和函数调用。同样地，在执行Shell命令时，需要谨慎处理输入内容和安全问题。\n\n当然，还有一种方法可以执行Shell命令：\n\n## 使用System.Diagnostics.Process类和PowerShell Core：\n\n```csharp\nstring command = \"ipconfig\";\nProcess process = new Process();\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.FileName = \"pwsh.exe\"; // PowerShell Core的可执行文件路径\nstartInfo.Arguments = \"-Command \" + command;\nstartInfo.RedirectStandardOutput = true;\nstartInfo.UseShellExecute = false;\nstartInfo.CreateNoWindow = true;\n\nprocess.StartInfo = startInfo;\nprocess.Start();\n\nstring output = process.StandardOutput.ReadToEnd();\n\nprocess.WaitForExit();\n```\n\n这种方法使用了PowerShell Core的可执行文件（`pwsh.exe`）来执行Shell命令。需要注意，你需要先安装并配置好PowerShell Core，并将其可执行文件的路径正确填写到代码中(或者添加到环境变量中)。\n\n以上是使用C#执行Shell命令的几种常见方法，可以根据具体需求选择适合的方法进行操作。请务必确保输入内容的安全性，并谨慎处理可能存在的风险。\n","slug":"C-Sharp执行Shell","published":1,"updated":"2023-09-13T14:44:26.378Z","_id":"clmdad4sa0000io5g243bgsb3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"C-执行Shell\"><a href=\"#C-执行Shell\" class=\"headerlink\" title=\"C#执行Shell\"></a>C#执行Shell</h1><p>在C#中执行Shell命令有多种方法</p>\n<h2 id=\"使用System-Diagnostics-Process类：\"><a href=\"#使用System-Diagnostics-Process类：\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类：\"></a>使用System.Diagnostics.Process类：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>Process process = <span class=\"hljs-keyword\">new</span> Process();<br>ProcessStartInfo startInfo = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class=\"hljs-string\">&quot;cmd.exe&quot;</span>;<br>startInfo.Arguments = <span class=\"hljs-string\">&quot;/c &quot;</span> + command; <span class=\"hljs-comment\">// 如果是使用 PowerShell 命令，则将 &quot;/c&quot; 改为 &quot;/k&quot;</span><br>startInfo.RedirectStandardOutput = <span class=\"hljs-literal\">true</span>;<br>startInfo.UseShellExecute = <span class=\"hljs-literal\">false</span>;<br>startInfo.CreateNoWindow = <span class=\"hljs-literal\">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class=\"hljs-built_in\">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Diagnostics-Process类和PowerShell：\"><a href=\"#使用System-Diagnostics-Process类和PowerShell：\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类和PowerShell：\"></a>使用System.Diagnostics.Process类和PowerShell：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;Get-Process&quot;</span>;<br>Process process = <span class=\"hljs-keyword\">new</span> Process();<br>ProcessStartInfo startInfo = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class=\"hljs-string\">&quot;powershell.exe&quot;</span>;<br>startInfo.Arguments = command;<br>startInfo.RedirectStandardOutput = <span class=\"hljs-literal\">true</span>;<br>startInfo.UseShellExecute = <span class=\"hljs-literal\">false</span>;<br>startInfo.CreateNoWindow = <span class=\"hljs-literal\">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class=\"hljs-built_in\">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Management命名空间的ManagementObject类（需要引用System-Management-dll）：\"><a href=\"#使用System-Management命名空间的ManagementObject类（需要引用System-Management-dll）：\" class=\"headerlink\" title=\"使用System.Management命名空间的ManagementObject类（需要引用System.Management.dll）：\"></a>使用System.Management命名空间的ManagementObject类（需要引用System.Management.dll）：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>ManagementClass processClass = <span class=\"hljs-keyword\">new</span> ManagementClass(<span class=\"hljs-string\">&quot;Win32_Process&quot;</span>);<br><span class=\"hljs-built_in\">object</span>[] methodArgs = &#123; command, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">0</span> &#125;;<br><span class=\"hljs-built_in\">object</span> result = processClass.InvokeMethod(<span class=\"hljs-string\">&quot;Create&quot;</span>, methodArgs);<br><span class=\"hljs-built_in\">int</span> exitCode = Convert.ToInt32(result);<br></code></pre></td></tr></table></figure>\n\n<p>当然，还有其他一些执行Shell命令的方法。以下是其中的两种：</p>\n<h2 id=\"使用System-Diagnostics-Process类和WMI（Windows-Management-Instrumentation）：\"><a href=\"#使用System-Diagnostics-Process类和WMI（Windows-Management-Instrumentation）：\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类和WMI（Windows Management Instrumentation）：\"></a>使用System.Diagnostics.Process类和WMI（Windows Management Instrumentation）：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>Process process = <span class=\"hljs-keyword\">new</span> Process();<br>ProcessStartInfo startInfo = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class=\"hljs-string\">&quot;cmd.exe&quot;</span>;<br>startInfo.Arguments = <span class=\"hljs-string\">&quot;/c &quot;</span> + command; <span class=\"hljs-comment\">// 如果是使用 PowerShell 命令，则将 &quot;/c&quot; 改为 &quot;/k&quot;</span><br>startInfo.RedirectStandardOutput = <span class=\"hljs-literal\">true</span>;<br>startInfo.UseShellExecute = <span class=\"hljs-literal\">false</span>;<br>startInfo.CreateNoWindow = <span class=\"hljs-literal\">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class=\"hljs-built_in\">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用Microsoft-VisualBasic-Interaction类：\"><a href=\"#使用Microsoft-VisualBasic-Interaction类：\" class=\"headerlink\" title=\"使用Microsoft.VisualBasic.Interaction类：\"></a>使用Microsoft.VisualBasic.Interaction类：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br><span class=\"hljs-built_in\">string</span> output = Microsoft.VisualBasic.Interaction.Shell(command, AppWinStyle.Hide, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">-1</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Runtime-InteropServices引用DLL文件：\"><a href=\"#使用System-Runtime-InteropServices引用DLL文件：\" class=\"headerlink\" title=\"使用System.Runtime.InteropServices引用DLL文件：\"></a>使用System.Runtime.InteropServices引用DLL文件：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System.Runtime.InteropServices;<br><br>[<span class=\"hljs-meta\">DllImport(<span class=\"hljs-string\">&quot;kernel32.dll&quot;</span>, SetLastError = true)</span>]<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-built_in\">bool</span> <span class=\"hljs-title\">CreateProcess</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> lpApplicationName, <span class=\"hljs-built_in\">string</span> lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                                        <span class=\"hljs-built_in\">bool</span> bInheritHandles, <span class=\"hljs-built_in\">uint</span> dwCreationFlags, IntPtr lpEnvironment, <span class=\"hljs-built_in\">string</span> lpCurrentDirectory,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                                        <span class=\"hljs-keyword\">ref</span> STARTUPINFO lpStartupInfo, <span class=\"hljs-keyword\">out</span> PROCESS_INFORMATION lpProcessInformation</span>)</span>;<br><br>[<span class=\"hljs-meta\">DllImport(<span class=\"hljs-string\">&quot;kernel32.dll&quot;</span>, SetLastError = true)</span>]<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">WaitForSingleObject</span>(<span class=\"hljs-params\">IntPtr hHandle, <span class=\"hljs-built_in\">uint</span> dwMilliseconds</span>)</span>;<br><br><span class=\"hljs-keyword\">struct</span> PROCESS_INFORMATION<br>&#123;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hProcess;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hThread;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwProcessId;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwThreadId;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> STARTUPINFO<br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> cb;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> lpReserved;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> lpDesktop;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> lpTitle;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwX;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwY;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwXSize;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwYSize;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwXCountChars;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwYCountChars;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwFillAttribute;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwFlags;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">short</span> wShowWindow;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">short</span> cbReserved2;<br>    <span class=\"hljs-keyword\">public</span> IntPtr lpReserved2;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hStdInput;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hStdOutput;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hStdError;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span>[] args</span>)</span><br>&#123;<br>    <span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>    STARTUPINFO startupInfo = <span class=\"hljs-keyword\">new</span> STARTUPINFO();<br>    PROCESS_INFORMATION processInfo = <span class=\"hljs-keyword\">new</span> PROCESS_INFORMATION();<br>    <br>    <span class=\"hljs-built_in\">bool</span> success = CreateProcess(<span class=\"hljs-literal\">null</span>, command, IntPtr.Zero, IntPtr.Zero, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-number\">0</span>, IntPtr.Zero, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-keyword\">ref</span> startupInfo, <span class=\"hljs-keyword\">out</span> processInfo);<br>    <span class=\"hljs-keyword\">if</span> (success)<br>    &#123;<br>        WaitForSingleObject(processInfo.hProcess, <span class=\"hljs-number\">0xFFFFFFFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这种方法使用了Platform Invoke技术，可以直接调用Windows的API函数来执行Shell命令。请注意，使用此方法需要在代码中引用System.Runtime.InteropServices命名空间，并确保正确设置结构体和函数调用。同样地，在执行Shell命令时，需要谨慎处理输入内容和安全问题。</p>\n<p>当然，还有一种方法可以执行Shell命令：</p>\n<h2 id=\"使用System-Diagnostics-Process类和PowerShell-Core：\"><a href=\"#使用System-Diagnostics-Process类和PowerShell-Core：\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类和PowerShell Core：\"></a>使用System.Diagnostics.Process类和PowerShell Core：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>Process process = <span class=\"hljs-keyword\">new</span> Process();<br>ProcessStartInfo startInfo = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class=\"hljs-string\">&quot;pwsh.exe&quot;</span>; <span class=\"hljs-comment\">// PowerShell Core的可执行文件路径</span><br>startInfo.Arguments = <span class=\"hljs-string\">&quot;-Command &quot;</span> + command;<br>startInfo.RedirectStandardOutput = <span class=\"hljs-literal\">true</span>;<br>startInfo.UseShellExecute = <span class=\"hljs-literal\">false</span>;<br>startInfo.CreateNoWindow = <span class=\"hljs-literal\">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class=\"hljs-built_in\">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure>\n\n<p>这种方法使用了PowerShell Core的可执行文件（<code>pwsh.exe</code>）来执行Shell命令。需要注意，你需要先安装并配置好PowerShell Core，并将其可执行文件的路径正确填写到代码中(或者添加到环境变量中)。</p>\n<p>以上是使用C#执行Shell命令的几种常见方法，可以根据具体需求选择适合的方法进行操作。请务必确保输入内容的安全性，并谨慎处理可能存在的风险。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-执行Shell\"><a href=\"#C-执行Shell\" class=\"headerlink\" title=\"C#执行Shell\"></a>C#执行Shell</h1><p>在C#中执行Shell命令有多种方法</p>\n<h2 id=\"使用System-Diagnostics-Process类：\"><a href=\"#使用System-Diagnostics-Process类：\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类：\"></a>使用System.Diagnostics.Process类：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>Process process = <span class=\"hljs-keyword\">new</span> Process();<br>ProcessStartInfo startInfo = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class=\"hljs-string\">&quot;cmd.exe&quot;</span>;<br>startInfo.Arguments = <span class=\"hljs-string\">&quot;/c &quot;</span> + command; <span class=\"hljs-comment\">// 如果是使用 PowerShell 命令，则将 &quot;/c&quot; 改为 &quot;/k&quot;</span><br>startInfo.RedirectStandardOutput = <span class=\"hljs-literal\">true</span>;<br>startInfo.UseShellExecute = <span class=\"hljs-literal\">false</span>;<br>startInfo.CreateNoWindow = <span class=\"hljs-literal\">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class=\"hljs-built_in\">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Diagnostics-Process类和PowerShell：\"><a href=\"#使用System-Diagnostics-Process类和PowerShell：\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类和PowerShell：\"></a>使用System.Diagnostics.Process类和PowerShell：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;Get-Process&quot;</span>;<br>Process process = <span class=\"hljs-keyword\">new</span> Process();<br>ProcessStartInfo startInfo = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class=\"hljs-string\">&quot;powershell.exe&quot;</span>;<br>startInfo.Arguments = command;<br>startInfo.RedirectStandardOutput = <span class=\"hljs-literal\">true</span>;<br>startInfo.UseShellExecute = <span class=\"hljs-literal\">false</span>;<br>startInfo.CreateNoWindow = <span class=\"hljs-literal\">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class=\"hljs-built_in\">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Management命名空间的ManagementObject类（需要引用System-Management-dll）：\"><a href=\"#使用System-Management命名空间的ManagementObject类（需要引用System-Management-dll）：\" class=\"headerlink\" title=\"使用System.Management命名空间的ManagementObject类（需要引用System.Management.dll）：\"></a>使用System.Management命名空间的ManagementObject类（需要引用System.Management.dll）：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>ManagementClass processClass = <span class=\"hljs-keyword\">new</span> ManagementClass(<span class=\"hljs-string\">&quot;Win32_Process&quot;</span>);<br><span class=\"hljs-built_in\">object</span>[] methodArgs = &#123; command, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">0</span> &#125;;<br><span class=\"hljs-built_in\">object</span> result = processClass.InvokeMethod(<span class=\"hljs-string\">&quot;Create&quot;</span>, methodArgs);<br><span class=\"hljs-built_in\">int</span> exitCode = Convert.ToInt32(result);<br></code></pre></td></tr></table></figure>\n\n<p>当然，还有其他一些执行Shell命令的方法。以下是其中的两种：</p>\n<h2 id=\"使用System-Diagnostics-Process类和WMI（Windows-Management-Instrumentation）：\"><a href=\"#使用System-Diagnostics-Process类和WMI（Windows-Management-Instrumentation）：\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类和WMI（Windows Management Instrumentation）：\"></a>使用System.Diagnostics.Process类和WMI（Windows Management Instrumentation）：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>Process process = <span class=\"hljs-keyword\">new</span> Process();<br>ProcessStartInfo startInfo = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class=\"hljs-string\">&quot;cmd.exe&quot;</span>;<br>startInfo.Arguments = <span class=\"hljs-string\">&quot;/c &quot;</span> + command; <span class=\"hljs-comment\">// 如果是使用 PowerShell 命令，则将 &quot;/c&quot; 改为 &quot;/k&quot;</span><br>startInfo.RedirectStandardOutput = <span class=\"hljs-literal\">true</span>;<br>startInfo.UseShellExecute = <span class=\"hljs-literal\">false</span>;<br>startInfo.CreateNoWindow = <span class=\"hljs-literal\">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class=\"hljs-built_in\">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用Microsoft-VisualBasic-Interaction类：\"><a href=\"#使用Microsoft-VisualBasic-Interaction类：\" class=\"headerlink\" title=\"使用Microsoft.VisualBasic.Interaction类：\"></a>使用Microsoft.VisualBasic.Interaction类：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br><span class=\"hljs-built_in\">string</span> output = Microsoft.VisualBasic.Interaction.Shell(command, AppWinStyle.Hide, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">-1</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Runtime-InteropServices引用DLL文件：\"><a href=\"#使用System-Runtime-InteropServices引用DLL文件：\" class=\"headerlink\" title=\"使用System.Runtime.InteropServices引用DLL文件：\"></a>使用System.Runtime.InteropServices引用DLL文件：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System.Runtime.InteropServices;<br><br>[<span class=\"hljs-meta\">DllImport(<span class=\"hljs-string\">&quot;kernel32.dll&quot;</span>, SetLastError = true)</span>]<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-built_in\">bool</span> <span class=\"hljs-title\">CreateProcess</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> lpApplicationName, <span class=\"hljs-built_in\">string</span> lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                                        <span class=\"hljs-built_in\">bool</span> bInheritHandles, <span class=\"hljs-built_in\">uint</span> dwCreationFlags, IntPtr lpEnvironment, <span class=\"hljs-built_in\">string</span> lpCurrentDirectory,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                                        <span class=\"hljs-keyword\">ref</span> STARTUPINFO lpStartupInfo, <span class=\"hljs-keyword\">out</span> PROCESS_INFORMATION lpProcessInformation</span>)</span>;<br><br>[<span class=\"hljs-meta\">DllImport(<span class=\"hljs-string\">&quot;kernel32.dll&quot;</span>, SetLastError = true)</span>]<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">WaitForSingleObject</span>(<span class=\"hljs-params\">IntPtr hHandle, <span class=\"hljs-built_in\">uint</span> dwMilliseconds</span>)</span>;<br><br><span class=\"hljs-keyword\">struct</span> PROCESS_INFORMATION<br>&#123;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hProcess;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hThread;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwProcessId;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwThreadId;<br>&#125;<br><br><span class=\"hljs-keyword\">struct</span> STARTUPINFO<br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> cb;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> lpReserved;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> lpDesktop;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> lpTitle;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwX;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwY;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwXSize;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwYSize;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwXCountChars;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwYCountChars;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwFillAttribute;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> dwFlags;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">short</span> wShowWindow;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">short</span> cbReserved2;<br>    <span class=\"hljs-keyword\">public</span> IntPtr lpReserved2;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hStdInput;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hStdOutput;<br>    <span class=\"hljs-keyword\">public</span> IntPtr hStdError;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span>[] args</span>)</span><br>&#123;<br>    <span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>    STARTUPINFO startupInfo = <span class=\"hljs-keyword\">new</span> STARTUPINFO();<br>    PROCESS_INFORMATION processInfo = <span class=\"hljs-keyword\">new</span> PROCESS_INFORMATION();<br>    <br>    <span class=\"hljs-built_in\">bool</span> success = CreateProcess(<span class=\"hljs-literal\">null</span>, command, IntPtr.Zero, IntPtr.Zero, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-number\">0</span>, IntPtr.Zero, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-keyword\">ref</span> startupInfo, <span class=\"hljs-keyword\">out</span> processInfo);<br>    <span class=\"hljs-keyword\">if</span> (success)<br>    &#123;<br>        WaitForSingleObject(processInfo.hProcess, <span class=\"hljs-number\">0xFFFFFFFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这种方法使用了Platform Invoke技术，可以直接调用Windows的API函数来执行Shell命令。请注意，使用此方法需要在代码中引用System.Runtime.InteropServices命名空间，并确保正确设置结构体和函数调用。同样地，在执行Shell命令时，需要谨慎处理输入内容和安全问题。</p>\n<p>当然，还有一种方法可以执行Shell命令：</p>\n<h2 id=\"使用System-Diagnostics-Process类和PowerShell-Core：\"><a href=\"#使用System-Diagnostics-Process类和PowerShell-Core：\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类和PowerShell Core：\"></a>使用System.Diagnostics.Process类和PowerShell Core：</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-built_in\">string</span> command = <span class=\"hljs-string\">&quot;ipconfig&quot;</span>;<br>Process process = <span class=\"hljs-keyword\">new</span> Process();<br>ProcessStartInfo startInfo = <span class=\"hljs-keyword\">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class=\"hljs-string\">&quot;pwsh.exe&quot;</span>; <span class=\"hljs-comment\">// PowerShell Core的可执行文件路径</span><br>startInfo.Arguments = <span class=\"hljs-string\">&quot;-Command &quot;</span> + command;<br>startInfo.RedirectStandardOutput = <span class=\"hljs-literal\">true</span>;<br>startInfo.UseShellExecute = <span class=\"hljs-literal\">false</span>;<br>startInfo.CreateNoWindow = <span class=\"hljs-literal\">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class=\"hljs-built_in\">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure>\n\n<p>这种方法使用了PowerShell Core的可执行文件（<code>pwsh.exe</code>）来执行Shell命令。需要注意，你需要先安装并配置好PowerShell Core，并将其可执行文件的路径正确填写到代码中(或者添加到环境变量中)。</p>\n<p>以上是使用C#执行Shell命令的几种常见方法，可以根据具体需求选择适合的方法进行操作。请务必确保输入内容的安全性，并谨慎处理可能存在的风险。</p>\n"},{"title":"Node.js执行Shell","date":"2023-09-10T10:06:28.000Z","author":"Grey-Wind","_content":"\n# Node.js执行Shell\n\n在 Node.js 中执行 Shell 命令有多种方法。以下是几种常用的方法：\n\n## `child_process` 模块：\n\n### 使用 exec 方法执行 Shell 命令\n\n```javascript\nconst { exec } = require('child_process');\n\nexec('ls -a', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`执行命令出错: ${error}`);\n    return;\n  }\n  console.log(`标准输出: ${stdout}`);\n  console.error(`错误输出: ${stderr}`);\n});\n```\n\n### 使用 spawn 方法执行 Shell 命令\n\n```javascript\nconst { spawn } = require('child_process');\n\nconst ls = spawn('ls', ['-a']);\nls.stdout.on('data', (data) => {\n  console.log(`标准输出: ${data}`);\n});\nls.stderr.on('data', (data) => {\n  console.error(`错误输出: ${data}`);\n});\nls.on('close', (code) => {\n  console.log(`子进程退出码: ${code}`);\n});\n```\n\n## `execSync` 方法：\n\n```javascript\nconst { execSync } = require('child_process');\n\ntry {\n  const stdout = execSync('ls -a');\n  console.log(`标准输出: ${stdout}`);\n} catch (error) {\n  console.error(`执行命令出错: ${error}`);\n}\n```\n\n##  `shelljs`模块：\n\n```javascript\nconst shell = require('shelljs');\n\n// 执行 Shell 命令，并获取输出\nconst result = shell.exec('ls -a');\nif (result.code !== 0) {\n  console.error(`执行命令出错: ${result.stderr}`);\n  return;\n}\nconsole.log(`标准输出: ${result.stdout}`);\n```\n\n## `execa` 模块\n\n提供了一个简单且强大的接口来执行外部命令\n\n```javascript\nconst execa = require('execa');\n\n(async () => {\n  try {\n    const { stdout } = await execa('ls', ['-a']);\n    console.log(`标准输出: ${stdout}`);\n  } catch (error) {\n    console.error(`执行命令出错: ${error}`);\n  }\n})();\n```\n\n## `node-pty` 模块\n\n这是一个伪终端的库，允许你与 Shell 进行交互式通信\n\n```javascript\nconst os = require('os');\nconst pty = require('node-pty');\n\nconst shell = os.platform() === 'win32' ? 'cmd.exe' : 'bash';\nconst ptyProcess = pty.spawn(shell, [], {\n  name: 'xterm-color',\n  cols: 80,\n  rows: 30,\n  cwd: process.cwd(),\n  env: process.env\n});\n\nptyProcess.on('data', (data) => {\n  console.log(`输出: ${data}`);\n});\n\nptyProcess.write('ls -a\\r');\n```\n\n## `shelljs-exec-proxy` 模块\n\n这是一个对 `shelljs` 的封装，提供了更简洁的方式来执行 Shell 命令并处理输出。\n\n```javascript\nconst shell = require('shelljs-exec-proxy');\n\nconst { code, stdout, stderr } = shell('ls -a');\nif (code !== 0) {\n  console.error(`执行命令出错: ${stderr}`);\n  return;\n}\nconsole.log(`标准输出: ${stdout}`);\n```\n\n## `simple-git` 模块\n\n这是一个用于管理 Git 仓库的库，它也提供了执行 Shell 命令的功能。\n\n```javascript\nconst simpleGit = require('simple-git');\n\nconst git = simpleGit();\ngit.raw(['ls-files', '-z'], (error, result) => {\n  if (error) {\n    console.error(`执行命令出错: ${error}`);\n    return;\n  }\n  console.log(`标准输出: ${result}`);\n});\n```\n\n## `ssh2` 模块\n\n这是一个用于通过 SSH 执行 Shell 命令的库。\n\n```javascript\nconst Client = require('ssh2').Client;\n\nconst conn = new Client();\nconn.on('ready', () => {\n  conn.exec('ls -a', (error, stream) => {\n    if (error) {\n      console.error(`执行命令出错: ${error}`);\n      return;\n    }\n    stream.on('close', (code, signal) => {\n      console.log(`子进程退出码: ${code}`);\n      conn.end();\n    }).on('data', (data) => {\n      console.log(`标准输出: ${data}`);\n    }).stderr.on('data', (data) => {\n      console.error(`错误输出: ${data}`);\n    });\n  });\n}).connect({\n  host: 'example.com',\n  username: 'username',\n  password: 'password'\n});\n```\n\n## `cross-spawn` 模块\n\n这是一个跨平台的库，可以在 Windows 和 Unix 系统上执行 Shell 命令。\n\n```javascript\nconst spawn = require('cross-spawn');\n\nconst ls = spawn('ls', ['-a']);\nls.stdout.on('data', (data) => {\n  console.log(`标准输出: ${data}`);\n});\nls.stderr.on('data', (data) => {\n  console.error(`错误输出: ${data}`);\n});\nls.on('close', (code) => {\n  console.log(`子进程退出码: ${code}`);\n});\n```\n\n## `shell-exec` 模块\n\n这是另一个对 Shell 命令的封装，它提供了一个简单的接口来执行命令并处理输出。\n\n   ```javascript\n   const shellExec = require('shell-exec');\n\n   (async () => {\n     const result = await shellExec('ls -a');\n     if (result.code !== 0) {\n       console.error(`执行命令出错: ${result.stderr}`);\n       return;\n     }\n     console.log(`标准输出: ${result.stdout}`);\n   })();\n   ```\n\n当然，还有一些其他的方法：\n\n## `node-pty` 模块\n\n这是一个能够让你生成一个伪终端并与其中运行 Shell 命令的库。它在计算机和服务器上都可以工作，并使你能够与 Shell 交互。\n\n   ```javascript\n   const os = require('os');\n   const pty = require('node-pty');\n\n   const term = pty.spawn(os.platform() === 'win32' ? 'cmd.exe' : 'bash', [], {\n     name: 'xterm-color',\n     cwd: process.env.HOME,\n     env: process.env\n   });\n\n   term.onData((data) => {\n     console.log(`输出: ${data}`);\n   });\n\n   term.write('ls\\r');\n   ```\n\n## `runas` 模块\n\n这个库允许你在 Windows 系统上以管理员身份运行 Shell 命令。\n\n   ```javascript\n   const runas = require('runas');\n\n   try {\n     runas('%windir%\\\\system32\\\\ipconfig.exe /all', {\n       admin: true,\n       hide: true\n     });\n   } catch (error) {\n     console.error(`执行命令出错: ${error}`);\n   }\n   ```\n\n## `node-cmd` 模块\n\n这是一个能够在 Node.js 中执行 Shell 命令的简单库，它提供了简洁的接口。\n\n```javascript\nconst cmd = require('node-cmd');\n\ncmd.get('ls -a', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`执行命令出错: ${error}`);\n    return;\n  }\n  console.log(`标准输出: ${stdout}`);\n  console.error(`错误输出: ${stderr}`);\n});\n```\n","source":"_posts/Node执行Shell.md","raw":"---\ntitle: Node.js执行Shell\ndate: 2023-09-10 18:06:28\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Node.js执行Shell\n\n在 Node.js 中执行 Shell 命令有多种方法。以下是几种常用的方法：\n\n## `child_process` 模块：\n\n### 使用 exec 方法执行 Shell 命令\n\n```javascript\nconst { exec } = require('child_process');\n\nexec('ls -a', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`执行命令出错: ${error}`);\n    return;\n  }\n  console.log(`标准输出: ${stdout}`);\n  console.error(`错误输出: ${stderr}`);\n});\n```\n\n### 使用 spawn 方法执行 Shell 命令\n\n```javascript\nconst { spawn } = require('child_process');\n\nconst ls = spawn('ls', ['-a']);\nls.stdout.on('data', (data) => {\n  console.log(`标准输出: ${data}`);\n});\nls.stderr.on('data', (data) => {\n  console.error(`错误输出: ${data}`);\n});\nls.on('close', (code) => {\n  console.log(`子进程退出码: ${code}`);\n});\n```\n\n## `execSync` 方法：\n\n```javascript\nconst { execSync } = require('child_process');\n\ntry {\n  const stdout = execSync('ls -a');\n  console.log(`标准输出: ${stdout}`);\n} catch (error) {\n  console.error(`执行命令出错: ${error}`);\n}\n```\n\n##  `shelljs`模块：\n\n```javascript\nconst shell = require('shelljs');\n\n// 执行 Shell 命令，并获取输出\nconst result = shell.exec('ls -a');\nif (result.code !== 0) {\n  console.error(`执行命令出错: ${result.stderr}`);\n  return;\n}\nconsole.log(`标准输出: ${result.stdout}`);\n```\n\n## `execa` 模块\n\n提供了一个简单且强大的接口来执行外部命令\n\n```javascript\nconst execa = require('execa');\n\n(async () => {\n  try {\n    const { stdout } = await execa('ls', ['-a']);\n    console.log(`标准输出: ${stdout}`);\n  } catch (error) {\n    console.error(`执行命令出错: ${error}`);\n  }\n})();\n```\n\n## `node-pty` 模块\n\n这是一个伪终端的库，允许你与 Shell 进行交互式通信\n\n```javascript\nconst os = require('os');\nconst pty = require('node-pty');\n\nconst shell = os.platform() === 'win32' ? 'cmd.exe' : 'bash';\nconst ptyProcess = pty.spawn(shell, [], {\n  name: 'xterm-color',\n  cols: 80,\n  rows: 30,\n  cwd: process.cwd(),\n  env: process.env\n});\n\nptyProcess.on('data', (data) => {\n  console.log(`输出: ${data}`);\n});\n\nptyProcess.write('ls -a\\r');\n```\n\n## `shelljs-exec-proxy` 模块\n\n这是一个对 `shelljs` 的封装，提供了更简洁的方式来执行 Shell 命令并处理输出。\n\n```javascript\nconst shell = require('shelljs-exec-proxy');\n\nconst { code, stdout, stderr } = shell('ls -a');\nif (code !== 0) {\n  console.error(`执行命令出错: ${stderr}`);\n  return;\n}\nconsole.log(`标准输出: ${stdout}`);\n```\n\n## `simple-git` 模块\n\n这是一个用于管理 Git 仓库的库，它也提供了执行 Shell 命令的功能。\n\n```javascript\nconst simpleGit = require('simple-git');\n\nconst git = simpleGit();\ngit.raw(['ls-files', '-z'], (error, result) => {\n  if (error) {\n    console.error(`执行命令出错: ${error}`);\n    return;\n  }\n  console.log(`标准输出: ${result}`);\n});\n```\n\n## `ssh2` 模块\n\n这是一个用于通过 SSH 执行 Shell 命令的库。\n\n```javascript\nconst Client = require('ssh2').Client;\n\nconst conn = new Client();\nconn.on('ready', () => {\n  conn.exec('ls -a', (error, stream) => {\n    if (error) {\n      console.error(`执行命令出错: ${error}`);\n      return;\n    }\n    stream.on('close', (code, signal) => {\n      console.log(`子进程退出码: ${code}`);\n      conn.end();\n    }).on('data', (data) => {\n      console.log(`标准输出: ${data}`);\n    }).stderr.on('data', (data) => {\n      console.error(`错误输出: ${data}`);\n    });\n  });\n}).connect({\n  host: 'example.com',\n  username: 'username',\n  password: 'password'\n});\n```\n\n## `cross-spawn` 模块\n\n这是一个跨平台的库，可以在 Windows 和 Unix 系统上执行 Shell 命令。\n\n```javascript\nconst spawn = require('cross-spawn');\n\nconst ls = spawn('ls', ['-a']);\nls.stdout.on('data', (data) => {\n  console.log(`标准输出: ${data}`);\n});\nls.stderr.on('data', (data) => {\n  console.error(`错误输出: ${data}`);\n});\nls.on('close', (code) => {\n  console.log(`子进程退出码: ${code}`);\n});\n```\n\n## `shell-exec` 模块\n\n这是另一个对 Shell 命令的封装，它提供了一个简单的接口来执行命令并处理输出。\n\n   ```javascript\n   const shellExec = require('shell-exec');\n\n   (async () => {\n     const result = await shellExec('ls -a');\n     if (result.code !== 0) {\n       console.error(`执行命令出错: ${result.stderr}`);\n       return;\n     }\n     console.log(`标准输出: ${result.stdout}`);\n   })();\n   ```\n\n当然，还有一些其他的方法：\n\n## `node-pty` 模块\n\n这是一个能够让你生成一个伪终端并与其中运行 Shell 命令的库。它在计算机和服务器上都可以工作，并使你能够与 Shell 交互。\n\n   ```javascript\n   const os = require('os');\n   const pty = require('node-pty');\n\n   const term = pty.spawn(os.platform() === 'win32' ? 'cmd.exe' : 'bash', [], {\n     name: 'xterm-color',\n     cwd: process.env.HOME,\n     env: process.env\n   });\n\n   term.onData((data) => {\n     console.log(`输出: ${data}`);\n   });\n\n   term.write('ls\\r');\n   ```\n\n## `runas` 模块\n\n这个库允许你在 Windows 系统上以管理员身份运行 Shell 命令。\n\n   ```javascript\n   const runas = require('runas');\n\n   try {\n     runas('%windir%\\\\system32\\\\ipconfig.exe /all', {\n       admin: true,\n       hide: true\n     });\n   } catch (error) {\n     console.error(`执行命令出错: ${error}`);\n   }\n   ```\n\n## `node-cmd` 模块\n\n这是一个能够在 Node.js 中执行 Shell 命令的简单库，它提供了简洁的接口。\n\n```javascript\nconst cmd = require('node-cmd');\n\ncmd.get('ls -a', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`执行命令出错: ${error}`);\n    return;\n  }\n  console.log(`标准输出: ${stdout}`);\n  console.error(`错误输出: ${stderr}`);\n});\n```\n","slug":"Node执行Shell","published":1,"updated":"2023-09-13T14:44:52.709Z","_id":"clmdav0ye0000qw5g94ko63xq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Node-js执行Shell\"><a href=\"#Node-js执行Shell\" class=\"headerlink\" title=\"Node.js执行Shell\"></a>Node.js执行Shell</h1><p>在 Node.js 中执行 Shell 命令有多种方法。以下是几种常用的方法：</p>\n<h2 id=\"child-process-模块：\"><a href=\"#child-process-模块：\" class=\"headerlink\" title=\"child_process 模块：\"></a><code>child_process</code> 模块：</h2><h3 id=\"使用-exec-方法执行-Shell-命令\"><a href=\"#使用-exec-方法执行-Shell-命令\" class=\"headerlink\" title=\"使用 exec 方法执行 Shell 命令\"></a>使用 exec 方法执行 Shell 命令</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; exec &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><br><span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-spawn-方法执行-Shell-命令\"><a href=\"#使用-spawn-方法执行-Shell-命令\" class=\"headerlink\" title=\"使用 spawn 方法执行 Shell 命令\"></a>使用 spawn 方法执行 Shell 命令</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; spawn &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> ls = <span class=\"hljs-title function_\">spawn</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, [<span class=\"hljs-string\">&#x27;-a&#x27;</span>]);<br>ls.<span class=\"hljs-property\">stdout</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`子进程退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execSync-方法：\"><a href=\"#execSync-方法：\" class=\"headerlink\" title=\"execSync 方法：\"></a><code>execSync</code> 方法：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; execSync &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> stdout = <span class=\"hljs-title function_\">execSync</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"shelljs模块：\"><a href=\"#shelljs模块：\" class=\"headerlink\" title=\"shelljs模块：\"></a><code>shelljs</code>模块：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> shell = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;shelljs&#x27;</span>);<br><br><span class=\"hljs-comment\">// 执行 Shell 命令，并获取输出</span><br><span class=\"hljs-keyword\">const</span> result = shell.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>);<br><span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">code</span> !== <span class=\"hljs-number\">0</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;result.stderr&#125;</span>`</span>);<br>  <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;result.stdout&#125;</span>`</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execa-模块\"><a href=\"#execa-模块\" class=\"headerlink\" title=\"execa 模块\"></a><code>execa</code> 模块</h2><p>提供了一个简单且强大的接口来执行外部命令</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> execa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;execa&#x27;</span>);<br><br>(<span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; stdout &#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">execa</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, [<span class=\"hljs-string\">&#x27;-a&#x27;</span>]);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"node-pty-模块\"><a href=\"#node-pty-模块\" class=\"headerlink\" title=\"node-pty 模块\"></a><code>node-pty</code> 模块</h2><p>这是一个伪终端的库，允许你与 Shell 进行交互式通信</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> os = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;os&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> pty = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;node-pty&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> shell = os.<span class=\"hljs-title function_\">platform</span>() === <span class=\"hljs-string\">&#x27;win32&#x27;</span> ? <span class=\"hljs-string\">&#x27;cmd.exe&#x27;</span> : <span class=\"hljs-string\">&#x27;bash&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> ptyProcess = pty.<span class=\"hljs-title function_\">spawn</span>(shell, [], &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;xterm-color&#x27;</span>,<br>  <span class=\"hljs-attr\">cols</span>: <span class=\"hljs-number\">80</span>,<br>  <span class=\"hljs-attr\">rows</span>: <span class=\"hljs-number\">30</span>,<br>  <span class=\"hljs-attr\">cwd</span>: process.<span class=\"hljs-title function_\">cwd</span>(),<br>  <span class=\"hljs-attr\">env</span>: process.<span class=\"hljs-property\">env</span><br>&#125;);<br><br>ptyProcess.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ptyProcess.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&#x27;ls -a\\r&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"shelljs-exec-proxy-模块\"><a href=\"#shelljs-exec-proxy-模块\" class=\"headerlink\" title=\"shelljs-exec-proxy 模块\"></a><code>shelljs-exec-proxy</code> 模块</h2><p>这是一个对 <code>shelljs</code> 的封装，提供了更简洁的方式来执行 Shell 命令并处理输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> shell = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;shelljs-exec-proxy&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> &#123; code, stdout, stderr &#125; = <span class=\"hljs-title function_\">shell</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>);<br><span class=\"hljs-keyword\">if</span> (code !== <span class=\"hljs-number\">0</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;stderr&#125;</span>`</span>);<br>  <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"simple-git-模块\"><a href=\"#simple-git-模块\" class=\"headerlink\" title=\"simple-git 模块\"></a><code>simple-git</code> 模块</h2><p>这是一个用于管理 Git 仓库的库，它也提供了执行 Shell 命令的功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> simpleGit = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;simple-git&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> git = <span class=\"hljs-title function_\">simpleGit</span>();<br>git.<span class=\"hljs-title function_\">raw</span>([<span class=\"hljs-string\">&#x27;ls-files&#x27;</span>, <span class=\"hljs-string\">&#x27;-z&#x27;</span>], <span class=\"hljs-function\">(<span class=\"hljs-params\">error, result</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;result&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"ssh2-模块\"><a href=\"#ssh2-模块\" class=\"headerlink\" title=\"ssh2 模块\"></a><code>ssh2</code> 模块</h2><p>这是一个用于通过 SSH 执行 Shell 命令的库。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Client</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;ssh2&#x27;</span>).<span class=\"hljs-property\">Client</span>;<br><br><span class=\"hljs-keyword\">const</span> conn = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Client</span>();<br>conn.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;ready&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  conn.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stream</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (error) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    stream.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code, signal</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`子进程退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>);<br>      conn.<span class=\"hljs-title function_\">end</span>();<br>    &#125;).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>    &#125;).<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>    &#125;);<br>  &#125;);<br>&#125;).<span class=\"hljs-title function_\">connect</span>(&#123;<br>  <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;example.com&#x27;</span>,<br>  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;username&#x27;</span>,<br>  <span class=\"hljs-attr\">password</span>: <span class=\"hljs-string\">&#x27;password&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"cross-spawn-模块\"><a href=\"#cross-spawn-模块\" class=\"headerlink\" title=\"cross-spawn 模块\"></a><code>cross-spawn</code> 模块</h2><p>这是一个跨平台的库，可以在 Windows 和 Unix 系统上执行 Shell 命令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> spawn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;cross-spawn&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> ls = <span class=\"hljs-title function_\">spawn</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, [<span class=\"hljs-string\">&#x27;-a&#x27;</span>]);<br>ls.<span class=\"hljs-property\">stdout</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`子进程退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"shell-exec-模块\"><a href=\"#shell-exec-模块\" class=\"headerlink\" title=\"shell-exec 模块\"></a><code>shell-exec</code> 模块</h2><p>这是另一个对 Shell 命令的封装，它提供了一个简单的接口来执行命令并处理输出。</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> shellExec = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;shell-exec&#x27;</span>);<br><br>(<span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">shellExec</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>);<br>  <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">code</span> !== <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;result.stderr&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;result.stdout&#125;</span>`</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure>\n\n<p>当然，还有一些其他的方法：</p>\n<h2 id=\"node-pty-模块-1\"><a href=\"#node-pty-模块-1\" class=\"headerlink\" title=\"node-pty 模块\"></a><code>node-pty</code> 模块</h2><p>这是一个能够让你生成一个伪终端并与其中运行 Shell 命令的库。它在计算机和服务器上都可以工作，并使你能够与 Shell 交互。</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> os = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;os&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> pty = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;node-pty&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> term = pty.<span class=\"hljs-title function_\">spawn</span>(os.<span class=\"hljs-title function_\">platform</span>() === <span class=\"hljs-string\">&#x27;win32&#x27;</span> ? <span class=\"hljs-string\">&#x27;cmd.exe&#x27;</span> : <span class=\"hljs-string\">&#x27;bash&#x27;</span>, [], &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;xterm-color&#x27;</span>,<br>  <span class=\"hljs-attr\">cwd</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">HOME</span>,<br>  <span class=\"hljs-attr\">env</span>: process.<span class=\"hljs-property\">env</span><br>&#125;);<br><br>term.<span class=\"hljs-title function_\">onData</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>term.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&#x27;ls\\r&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"runas-模块\"><a href=\"#runas-模块\" class=\"headerlink\" title=\"runas 模块\"></a><code>runas</code> 模块</h2><p>这个库允许你在 Windows 系统上以管理员身份运行 Shell 命令。</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> runas = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;runas&#x27;</span>);<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-title function_\">runas</span>(<span class=\"hljs-string\">&#x27;%windir%\\\\system32\\\\ipconfig.exe /all&#x27;</span>, &#123;<br>    <span class=\"hljs-attr\">admin</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">hide</span>: <span class=\"hljs-literal\">true</span><br>  &#125;);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"node-cmd-模块\"><a href=\"#node-cmd-模块\" class=\"headerlink\" title=\"node-cmd 模块\"></a><code>node-cmd</code> 模块</h2><p>这是一个能够在 Node.js 中执行 Shell 命令的简单库，它提供了简洁的接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> cmd = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;node-cmd&#x27;</span>);<br><br>cmd.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-js执行Shell\"><a href=\"#Node-js执行Shell\" class=\"headerlink\" title=\"Node.js执行Shell\"></a>Node.js执行Shell</h1><p>在 Node.js 中执行 Shell 命令有多种方法。以下是几种常用的方法：</p>\n<h2 id=\"child-process-模块：\"><a href=\"#child-process-模块：\" class=\"headerlink\" title=\"child_process 模块：\"></a><code>child_process</code> 模块：</h2><h3 id=\"使用-exec-方法执行-Shell-命令\"><a href=\"#使用-exec-方法执行-Shell-命令\" class=\"headerlink\" title=\"使用 exec 方法执行 Shell 命令\"></a>使用 exec 方法执行 Shell 命令</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; exec &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><br><span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-spawn-方法执行-Shell-命令\"><a href=\"#使用-spawn-方法执行-Shell-命令\" class=\"headerlink\" title=\"使用 spawn 方法执行 Shell 命令\"></a>使用 spawn 方法执行 Shell 命令</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; spawn &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> ls = <span class=\"hljs-title function_\">spawn</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, [<span class=\"hljs-string\">&#x27;-a&#x27;</span>]);<br>ls.<span class=\"hljs-property\">stdout</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`子进程退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execSync-方法：\"><a href=\"#execSync-方法：\" class=\"headerlink\" title=\"execSync 方法：\"></a><code>execSync</code> 方法：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; execSync &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> stdout = <span class=\"hljs-title function_\">execSync</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"shelljs模块：\"><a href=\"#shelljs模块：\" class=\"headerlink\" title=\"shelljs模块：\"></a><code>shelljs</code>模块：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> shell = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;shelljs&#x27;</span>);<br><br><span class=\"hljs-comment\">// 执行 Shell 命令，并获取输出</span><br><span class=\"hljs-keyword\">const</span> result = shell.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>);<br><span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">code</span> !== <span class=\"hljs-number\">0</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;result.stderr&#125;</span>`</span>);<br>  <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;result.stdout&#125;</span>`</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execa-模块\"><a href=\"#execa-模块\" class=\"headerlink\" title=\"execa 模块\"></a><code>execa</code> 模块</h2><p>提供了一个简单且强大的接口来执行外部命令</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> execa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;execa&#x27;</span>);<br><br>(<span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; stdout &#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">execa</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, [<span class=\"hljs-string\">&#x27;-a&#x27;</span>]);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"node-pty-模块\"><a href=\"#node-pty-模块\" class=\"headerlink\" title=\"node-pty 模块\"></a><code>node-pty</code> 模块</h2><p>这是一个伪终端的库，允许你与 Shell 进行交互式通信</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> os = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;os&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> pty = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;node-pty&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> shell = os.<span class=\"hljs-title function_\">platform</span>() === <span class=\"hljs-string\">&#x27;win32&#x27;</span> ? <span class=\"hljs-string\">&#x27;cmd.exe&#x27;</span> : <span class=\"hljs-string\">&#x27;bash&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> ptyProcess = pty.<span class=\"hljs-title function_\">spawn</span>(shell, [], &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;xterm-color&#x27;</span>,<br>  <span class=\"hljs-attr\">cols</span>: <span class=\"hljs-number\">80</span>,<br>  <span class=\"hljs-attr\">rows</span>: <span class=\"hljs-number\">30</span>,<br>  <span class=\"hljs-attr\">cwd</span>: process.<span class=\"hljs-title function_\">cwd</span>(),<br>  <span class=\"hljs-attr\">env</span>: process.<span class=\"hljs-property\">env</span><br>&#125;);<br><br>ptyProcess.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ptyProcess.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&#x27;ls -a\\r&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"shelljs-exec-proxy-模块\"><a href=\"#shelljs-exec-proxy-模块\" class=\"headerlink\" title=\"shelljs-exec-proxy 模块\"></a><code>shelljs-exec-proxy</code> 模块</h2><p>这是一个对 <code>shelljs</code> 的封装，提供了更简洁的方式来执行 Shell 命令并处理输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> shell = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;shelljs-exec-proxy&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> &#123; code, stdout, stderr &#125; = <span class=\"hljs-title function_\">shell</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>);<br><span class=\"hljs-keyword\">if</span> (code !== <span class=\"hljs-number\">0</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;stderr&#125;</span>`</span>);<br>  <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"simple-git-模块\"><a href=\"#simple-git-模块\" class=\"headerlink\" title=\"simple-git 模块\"></a><code>simple-git</code> 模块</h2><p>这是一个用于管理 Git 仓库的库，它也提供了执行 Shell 命令的功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> simpleGit = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;simple-git&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> git = <span class=\"hljs-title function_\">simpleGit</span>();<br>git.<span class=\"hljs-title function_\">raw</span>([<span class=\"hljs-string\">&#x27;ls-files&#x27;</span>, <span class=\"hljs-string\">&#x27;-z&#x27;</span>], <span class=\"hljs-function\">(<span class=\"hljs-params\">error, result</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;result&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"ssh2-模块\"><a href=\"#ssh2-模块\" class=\"headerlink\" title=\"ssh2 模块\"></a><code>ssh2</code> 模块</h2><p>这是一个用于通过 SSH 执行 Shell 命令的库。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Client</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;ssh2&#x27;</span>).<span class=\"hljs-property\">Client</span>;<br><br><span class=\"hljs-keyword\">const</span> conn = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Client</span>();<br>conn.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;ready&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  conn.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stream</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (error) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    stream.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code, signal</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`子进程退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>);<br>      conn.<span class=\"hljs-title function_\">end</span>();<br>    &#125;).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>    &#125;).<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>    &#125;);<br>  &#125;);<br>&#125;).<span class=\"hljs-title function_\">connect</span>(&#123;<br>  <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;example.com&#x27;</span>,<br>  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;username&#x27;</span>,<br>  <span class=\"hljs-attr\">password</span>: <span class=\"hljs-string\">&#x27;password&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"cross-spawn-模块\"><a href=\"#cross-spawn-模块\" class=\"headerlink\" title=\"cross-spawn 模块\"></a><code>cross-spawn</code> 模块</h2><p>这是一个跨平台的库，可以在 Windows 和 Unix 系统上执行 Shell 命令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> spawn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;cross-spawn&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> ls = <span class=\"hljs-title function_\">spawn</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, [<span class=\"hljs-string\">&#x27;-a&#x27;</span>]);<br>ls.<span class=\"hljs-property\">stdout</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`子进程退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"shell-exec-模块\"><a href=\"#shell-exec-模块\" class=\"headerlink\" title=\"shell-exec 模块\"></a><code>shell-exec</code> 模块</h2><p>这是另一个对 Shell 命令的封装，它提供了一个简单的接口来执行命令并处理输出。</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> shellExec = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;shell-exec&#x27;</span>);<br><br>(<span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">shellExec</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>);<br>  <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">code</span> !== <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;result.stderr&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;result.stdout&#125;</span>`</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure>\n\n<p>当然，还有一些其他的方法：</p>\n<h2 id=\"node-pty-模块-1\"><a href=\"#node-pty-模块-1\" class=\"headerlink\" title=\"node-pty 模块\"></a><code>node-pty</code> 模块</h2><p>这是一个能够让你生成一个伪终端并与其中运行 Shell 命令的库。它在计算机和服务器上都可以工作，并使你能够与 Shell 交互。</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> os = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;os&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> pty = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;node-pty&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> term = pty.<span class=\"hljs-title function_\">spawn</span>(os.<span class=\"hljs-title function_\">platform</span>() === <span class=\"hljs-string\">&#x27;win32&#x27;</span> ? <span class=\"hljs-string\">&#x27;cmd.exe&#x27;</span> : <span class=\"hljs-string\">&#x27;bash&#x27;</span>, [], &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;xterm-color&#x27;</span>,<br>  <span class=\"hljs-attr\">cwd</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">HOME</span>,<br>  <span class=\"hljs-attr\">env</span>: process.<span class=\"hljs-property\">env</span><br>&#125;);<br><br>term.<span class=\"hljs-title function_\">onData</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>term.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&#x27;ls\\r&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"runas-模块\"><a href=\"#runas-模块\" class=\"headerlink\" title=\"runas 模块\"></a><code>runas</code> 模块</h2><p>这个库允许你在 Windows 系统上以管理员身份运行 Shell 命令。</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> runas = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;runas&#x27;</span>);<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-title function_\">runas</span>(<span class=\"hljs-string\">&#x27;%windir%\\\\system32\\\\ipconfig.exe /all&#x27;</span>, &#123;<br>    <span class=\"hljs-attr\">admin</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">hide</span>: <span class=\"hljs-literal\">true</span><br>  &#125;);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"node-cmd-模块\"><a href=\"#node-cmd-模块\" class=\"headerlink\" title=\"node-cmd 模块\"></a><code>node-cmd</code> 模块</h2><p>这是一个能够在 Node.js 中执行 Shell 命令的简单库，它提供了简洁的接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> cmd = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;node-cmd&#x27;</span>);<br><br>cmd.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;ls -a&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`标准输出: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n"},{"title":"Scala执行Shell","date":"2023-09-10T11:00:53.000Z","author":"Grey-Wind","_content":"\n# Scala执行Shell\n\n在Scala中，可以使用以下几种方式执行shell命令：\n\n## 使用Java的`ProcessBuilder`类\n\n可以通过创建`ProcessBuilder`对象，并设置要执行的shell命令，然后使用`.start()`方法启动进程并执行命令。以下是一个示例代码：\n\n```scala\nimport java.io._\n\nval command = \"ls -l\"\nval processBuilder = new ProcessBuilder(command.split(\"\\\\s+\"): _*)\nval process = processBuilder.start()\n\nval inputStream = process.getInputStream\nval reader = new BufferedReader(new InputStreamReader(inputStream))\n\nvar line: String = null\nwhile ({line = reader.readLine(); line != null}) {\n  println(line)\n}\n\nprocess.waitFor()\n```\n这个示例中使用了`ls -l`命令来列出当前目录下的文件和文件夹。\n\n## 使用`sys.process`包\n\nScala提供了一个方便的`sys.process`包，可以使用其中的`Process`类来执行shell命令。以下是示例代码：\n\n```scala\nimport sys.process._\n\nval command = \"ls -l\"\nval output = command.!!\nprintln(output)\n```\n这个示例中，`!!`操作符会执行shell命令并返回输出结果。\n\n## 使用`scala.sys.process.Process`类\n\n和前面的方法类似，也是使用`Process`类执行shell命令。以下是示例代码：\n\n```scala\nimport scala.sys.process._\n\nval command = Seq(\"ls\", \"-l\")\nval process = Process(command)\nval output = process.!!\nprintln(output)\n```\n这个示例中使用了`Seq`来定义命令和参数，然后使用`!!`操作符执行命令并返回输出结果。\n\n## 使用`java.lang.Runtime`类\n\nScala可以直接使用Java的`Runtime`类来执行shell命令。以下是示例代码：\n\n```scala\nimport java.lang.Runtime\n\nval command = \"ls -l\"\nval runtime = Runtime.getRuntime\nval process = runtime.exec(command)\n\nval inputStream = process.getInputStream\nval reader = new BufferedReader(new InputStreamReader(inputStream))\n\nvar line: String = null\nwhile ({line = reader.readLine(); line != null}) {\n  println(line)\n}\n\nprocess.waitFor()\n```\n这个示例中使用了`Runtime.getRuntime`获取当前运行时环境的`Runtime`对象，然后使用`exec`方法执行shell命令，并读取命令的输出结果。\n\n## 使用`scala.sys.process.ProcessBuilder`类\n\nScala的`sys.process`包还提供了`ProcessBuilder`类，它是对Java中的`ProcessBuilder`类的封装，提供了更加方便的链式调用方式。以下是示例代码：\n\n```scala\nimport scala.sys.process._\n\nval command = Seq(\"ls\", \"-l\")\nval processBuilder = Process(command)\n  .run(ProcessLogger(line => println(line)))\n\nprocessBuilder.exitValue()\n```\n这个示例中使用了`Process`类的`run`方法来执行shell命令，同时通过`ProcessLogger`指定了命令输出的处理方式，这里简单地将每一行输出打印出来。最后使用`exitValue`方法获取命令的退出值。\n\n这些方法都可以根据具体的需求选择适合的方式来执行shell命令。请根据实际情况选择合适的方法，并注意处理命令执行可能出现的异常情况。\n","source":"_posts/Scala执行Shell.md","raw":"---\ntitle: Scala执行Shell\ndate: 2023-09-10 19:00:53\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Scala执行Shell\n\n在Scala中，可以使用以下几种方式执行shell命令：\n\n## 使用Java的`ProcessBuilder`类\n\n可以通过创建`ProcessBuilder`对象，并设置要执行的shell命令，然后使用`.start()`方法启动进程并执行命令。以下是一个示例代码：\n\n```scala\nimport java.io._\n\nval command = \"ls -l\"\nval processBuilder = new ProcessBuilder(command.split(\"\\\\s+\"): _*)\nval process = processBuilder.start()\n\nval inputStream = process.getInputStream\nval reader = new BufferedReader(new InputStreamReader(inputStream))\n\nvar line: String = null\nwhile ({line = reader.readLine(); line != null}) {\n  println(line)\n}\n\nprocess.waitFor()\n```\n这个示例中使用了`ls -l`命令来列出当前目录下的文件和文件夹。\n\n## 使用`sys.process`包\n\nScala提供了一个方便的`sys.process`包，可以使用其中的`Process`类来执行shell命令。以下是示例代码：\n\n```scala\nimport sys.process._\n\nval command = \"ls -l\"\nval output = command.!!\nprintln(output)\n```\n这个示例中，`!!`操作符会执行shell命令并返回输出结果。\n\n## 使用`scala.sys.process.Process`类\n\n和前面的方法类似，也是使用`Process`类执行shell命令。以下是示例代码：\n\n```scala\nimport scala.sys.process._\n\nval command = Seq(\"ls\", \"-l\")\nval process = Process(command)\nval output = process.!!\nprintln(output)\n```\n这个示例中使用了`Seq`来定义命令和参数，然后使用`!!`操作符执行命令并返回输出结果。\n\n## 使用`java.lang.Runtime`类\n\nScala可以直接使用Java的`Runtime`类来执行shell命令。以下是示例代码：\n\n```scala\nimport java.lang.Runtime\n\nval command = \"ls -l\"\nval runtime = Runtime.getRuntime\nval process = runtime.exec(command)\n\nval inputStream = process.getInputStream\nval reader = new BufferedReader(new InputStreamReader(inputStream))\n\nvar line: String = null\nwhile ({line = reader.readLine(); line != null}) {\n  println(line)\n}\n\nprocess.waitFor()\n```\n这个示例中使用了`Runtime.getRuntime`获取当前运行时环境的`Runtime`对象，然后使用`exec`方法执行shell命令，并读取命令的输出结果。\n\n## 使用`scala.sys.process.ProcessBuilder`类\n\nScala的`sys.process`包还提供了`ProcessBuilder`类，它是对Java中的`ProcessBuilder`类的封装，提供了更加方便的链式调用方式。以下是示例代码：\n\n```scala\nimport scala.sys.process._\n\nval command = Seq(\"ls\", \"-l\")\nval processBuilder = Process(command)\n  .run(ProcessLogger(line => println(line)))\n\nprocessBuilder.exitValue()\n```\n这个示例中使用了`Process`类的`run`方法来执行shell命令，同时通过`ProcessLogger`指定了命令输出的处理方式，这里简单地将每一行输出打印出来。最后使用`exitValue`方法获取命令的退出值。\n\n这些方法都可以根据具体的需求选择适合的方式来执行shell命令。请根据实际情况选择合适的方法，并注意处理命令执行可能出现的异常情况。\n","slug":"Scala执行Shell","published":1,"updated":"2023-09-13T14:45:15.356Z","_id":"clmdclmh90000zo5gc7dwdtrv","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Scala执行Shell\"><a href=\"#Scala执行Shell\" class=\"headerlink\" title=\"Scala执行Shell\"></a>Scala执行Shell</h1><p>在Scala中，可以使用以下几种方式执行shell命令：</p>\n<h2 id=\"使用Java的ProcessBuilder类\"><a href=\"#使用Java的ProcessBuilder类\" class=\"headerlink\" title=\"使用Java的ProcessBuilder类\"></a>使用Java的<code>ProcessBuilder</code>类</h2><p>可以通过创建<code>ProcessBuilder</code>对象，并设置要执行的shell命令，然后使用<code>.start()</code>方法启动进程并执行命令。以下是一个示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> java.io._<br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-string\">&quot;ls -l&quot;</span><br><span class=\"hljs-keyword\">val</span> processBuilder = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ProcessBuilder</span>(command.split(<span class=\"hljs-string\">&quot;\\\\s+&quot;</span>): _*)<br><span class=\"hljs-keyword\">val</span> process = processBuilder.start()<br><br><span class=\"hljs-keyword\">val</span> inputStream = process.getInputStream<br><span class=\"hljs-keyword\">val</span> reader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">InputStreamReader</span>(inputStream))<br><br><span class=\"hljs-keyword\">var</span> line: <span class=\"hljs-type\">String</span> = <span class=\"hljs-literal\">null</span><br><span class=\"hljs-keyword\">while</span> (&#123;line = reader.readLine(); line != <span class=\"hljs-literal\">null</span>&#125;) &#123;<br>  println(line)<br>&#125;<br><br>process.waitFor()<br></code></pre></td></tr></table></figure>\n<p>这个示例中使用了<code>ls -l</code>命令来列出当前目录下的文件和文件夹。</p>\n<h2 id=\"使用sys-process包\"><a href=\"#使用sys-process包\" class=\"headerlink\" title=\"使用sys.process包\"></a>使用<code>sys.process</code>包</h2><p>Scala提供了一个方便的<code>sys.process</code>包，可以使用其中的<code>Process</code>类来执行shell命令。以下是示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> sys.process._<br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-string\">&quot;ls -l&quot;</span><br><span class=\"hljs-keyword\">val</span> output = command.!!<br>println(output)<br></code></pre></td></tr></table></figure>\n<p>这个示例中，<code>!!</code>操作符会执行shell命令并返回输出结果。</p>\n<h2 id=\"使用scala-sys-process-Process类\"><a href=\"#使用scala-sys-process-Process类\" class=\"headerlink\" title=\"使用scala.sys.process.Process类\"></a>使用<code>scala.sys.process.Process</code>类</h2><p>和前面的方法类似，也是使用<code>Process</code>类执行shell命令。以下是示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> scala.sys.process._<br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-type\">Seq</span>(<span class=\"hljs-string\">&quot;ls&quot;</span>, <span class=\"hljs-string\">&quot;-l&quot;</span>)<br><span class=\"hljs-keyword\">val</span> process = <span class=\"hljs-type\">Process</span>(command)<br><span class=\"hljs-keyword\">val</span> output = process.!!<br>println(output)<br></code></pre></td></tr></table></figure>\n<p>这个示例中使用了<code>Seq</code>来定义命令和参数，然后使用<code>!!</code>操作符执行命令并返回输出结果。</p>\n<h2 id=\"使用java-lang-Runtime类\"><a href=\"#使用java-lang-Runtime类\" class=\"headerlink\" title=\"使用java.lang.Runtime类\"></a>使用<code>java.lang.Runtime</code>类</h2><p>Scala可以直接使用Java的<code>Runtime</code>类来执行shell命令。以下是示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> java.lang.<span class=\"hljs-type\">Runtime</span><br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-string\">&quot;ls -l&quot;</span><br><span class=\"hljs-keyword\">val</span> runtime = <span class=\"hljs-type\">Runtime</span>.getRuntime<br><span class=\"hljs-keyword\">val</span> process = runtime.exec(command)<br><br><span class=\"hljs-keyword\">val</span> inputStream = process.getInputStream<br><span class=\"hljs-keyword\">val</span> reader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">InputStreamReader</span>(inputStream))<br><br><span class=\"hljs-keyword\">var</span> line: <span class=\"hljs-type\">String</span> = <span class=\"hljs-literal\">null</span><br><span class=\"hljs-keyword\">while</span> (&#123;line = reader.readLine(); line != <span class=\"hljs-literal\">null</span>&#125;) &#123;<br>  println(line)<br>&#125;<br><br>process.waitFor()<br></code></pre></td></tr></table></figure>\n<p>这个示例中使用了<code>Runtime.getRuntime</code>获取当前运行时环境的<code>Runtime</code>对象，然后使用<code>exec</code>方法执行shell命令，并读取命令的输出结果。</p>\n<h2 id=\"使用scala-sys-process-ProcessBuilder类\"><a href=\"#使用scala-sys-process-ProcessBuilder类\" class=\"headerlink\" title=\"使用scala.sys.process.ProcessBuilder类\"></a>使用<code>scala.sys.process.ProcessBuilder</code>类</h2><p>Scala的<code>sys.process</code>包还提供了<code>ProcessBuilder</code>类，它是对Java中的<code>ProcessBuilder</code>类的封装，提供了更加方便的链式调用方式。以下是示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> scala.sys.process._<br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-type\">Seq</span>(<span class=\"hljs-string\">&quot;ls&quot;</span>, <span class=\"hljs-string\">&quot;-l&quot;</span>)<br><span class=\"hljs-keyword\">val</span> processBuilder = <span class=\"hljs-type\">Process</span>(command)<br>  .run(<span class=\"hljs-type\">ProcessLogger</span>(line =&gt; println(line)))<br><br>processBuilder.exitValue()<br></code></pre></td></tr></table></figure>\n<p>这个示例中使用了<code>Process</code>类的<code>run</code>方法来执行shell命令，同时通过<code>ProcessLogger</code>指定了命令输出的处理方式，这里简单地将每一行输出打印出来。最后使用<code>exitValue</code>方法获取命令的退出值。</p>\n<p>这些方法都可以根据具体的需求选择适合的方式来执行shell命令。请根据实际情况选择合适的方法，并注意处理命令执行可能出现的异常情况。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Scala执行Shell\"><a href=\"#Scala执行Shell\" class=\"headerlink\" title=\"Scala执行Shell\"></a>Scala执行Shell</h1><p>在Scala中，可以使用以下几种方式执行shell命令：</p>\n<h2 id=\"使用Java的ProcessBuilder类\"><a href=\"#使用Java的ProcessBuilder类\" class=\"headerlink\" title=\"使用Java的ProcessBuilder类\"></a>使用Java的<code>ProcessBuilder</code>类</h2><p>可以通过创建<code>ProcessBuilder</code>对象，并设置要执行的shell命令，然后使用<code>.start()</code>方法启动进程并执行命令。以下是一个示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> java.io._<br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-string\">&quot;ls -l&quot;</span><br><span class=\"hljs-keyword\">val</span> processBuilder = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ProcessBuilder</span>(command.split(<span class=\"hljs-string\">&quot;\\\\s+&quot;</span>): _*)<br><span class=\"hljs-keyword\">val</span> process = processBuilder.start()<br><br><span class=\"hljs-keyword\">val</span> inputStream = process.getInputStream<br><span class=\"hljs-keyword\">val</span> reader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">InputStreamReader</span>(inputStream))<br><br><span class=\"hljs-keyword\">var</span> line: <span class=\"hljs-type\">String</span> = <span class=\"hljs-literal\">null</span><br><span class=\"hljs-keyword\">while</span> (&#123;line = reader.readLine(); line != <span class=\"hljs-literal\">null</span>&#125;) &#123;<br>  println(line)<br>&#125;<br><br>process.waitFor()<br></code></pre></td></tr></table></figure>\n<p>这个示例中使用了<code>ls -l</code>命令来列出当前目录下的文件和文件夹。</p>\n<h2 id=\"使用sys-process包\"><a href=\"#使用sys-process包\" class=\"headerlink\" title=\"使用sys.process包\"></a>使用<code>sys.process</code>包</h2><p>Scala提供了一个方便的<code>sys.process</code>包，可以使用其中的<code>Process</code>类来执行shell命令。以下是示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> sys.process._<br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-string\">&quot;ls -l&quot;</span><br><span class=\"hljs-keyword\">val</span> output = command.!!<br>println(output)<br></code></pre></td></tr></table></figure>\n<p>这个示例中，<code>!!</code>操作符会执行shell命令并返回输出结果。</p>\n<h2 id=\"使用scala-sys-process-Process类\"><a href=\"#使用scala-sys-process-Process类\" class=\"headerlink\" title=\"使用scala.sys.process.Process类\"></a>使用<code>scala.sys.process.Process</code>类</h2><p>和前面的方法类似，也是使用<code>Process</code>类执行shell命令。以下是示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> scala.sys.process._<br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-type\">Seq</span>(<span class=\"hljs-string\">&quot;ls&quot;</span>, <span class=\"hljs-string\">&quot;-l&quot;</span>)<br><span class=\"hljs-keyword\">val</span> process = <span class=\"hljs-type\">Process</span>(command)<br><span class=\"hljs-keyword\">val</span> output = process.!!<br>println(output)<br></code></pre></td></tr></table></figure>\n<p>这个示例中使用了<code>Seq</code>来定义命令和参数，然后使用<code>!!</code>操作符执行命令并返回输出结果。</p>\n<h2 id=\"使用java-lang-Runtime类\"><a href=\"#使用java-lang-Runtime类\" class=\"headerlink\" title=\"使用java.lang.Runtime类\"></a>使用<code>java.lang.Runtime</code>类</h2><p>Scala可以直接使用Java的<code>Runtime</code>类来执行shell命令。以下是示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> java.lang.<span class=\"hljs-type\">Runtime</span><br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-string\">&quot;ls -l&quot;</span><br><span class=\"hljs-keyword\">val</span> runtime = <span class=\"hljs-type\">Runtime</span>.getRuntime<br><span class=\"hljs-keyword\">val</span> process = runtime.exec(command)<br><br><span class=\"hljs-keyword\">val</span> inputStream = process.getInputStream<br><span class=\"hljs-keyword\">val</span> reader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">InputStreamReader</span>(inputStream))<br><br><span class=\"hljs-keyword\">var</span> line: <span class=\"hljs-type\">String</span> = <span class=\"hljs-literal\">null</span><br><span class=\"hljs-keyword\">while</span> (&#123;line = reader.readLine(); line != <span class=\"hljs-literal\">null</span>&#125;) &#123;<br>  println(line)<br>&#125;<br><br>process.waitFor()<br></code></pre></td></tr></table></figure>\n<p>这个示例中使用了<code>Runtime.getRuntime</code>获取当前运行时环境的<code>Runtime</code>对象，然后使用<code>exec</code>方法执行shell命令，并读取命令的输出结果。</p>\n<h2 id=\"使用scala-sys-process-ProcessBuilder类\"><a href=\"#使用scala-sys-process-ProcessBuilder类\" class=\"headerlink\" title=\"使用scala.sys.process.ProcessBuilder类\"></a>使用<code>scala.sys.process.ProcessBuilder</code>类</h2><p>Scala的<code>sys.process</code>包还提供了<code>ProcessBuilder</code>类，它是对Java中的<code>ProcessBuilder</code>类的封装，提供了更加方便的链式调用方式。以下是示例代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">import</span> scala.sys.process._<br><br><span class=\"hljs-keyword\">val</span> command = <span class=\"hljs-type\">Seq</span>(<span class=\"hljs-string\">&quot;ls&quot;</span>, <span class=\"hljs-string\">&quot;-l&quot;</span>)<br><span class=\"hljs-keyword\">val</span> processBuilder = <span class=\"hljs-type\">Process</span>(command)<br>  .run(<span class=\"hljs-type\">ProcessLogger</span>(line =&gt; println(line)))<br><br>processBuilder.exitValue()<br></code></pre></td></tr></table></figure>\n<p>这个示例中使用了<code>Process</code>类的<code>run</code>方法来执行shell命令，同时通过<code>ProcessLogger</code>指定了命令输出的处理方式，这里简单地将每一行输出打印出来。最后使用<code>exitValue</code>方法获取命令的退出值。</p>\n<p>这些方法都可以根据具体的需求选择适合的方式来执行shell命令。请根据实际情况选择合适的方法，并注意处理命令执行可能出现的异常情况。</p>\n"},{"title":"Qml执行Shell","date":"2023-09-10T11:09:50.000Z","author":"Grey-Wind","_content":"\n# Qml执行Shell\n\n在QML中执行Shell命令的方法取决于你正在使用的QML框架和操作系统。以下是一种常见的方法：\n\n## 在Qt Quick中使用Qt.createQmlObject方法\n\n```qml\nimport QtQuick 2.0\nimport QtQml 2.0\n\nItem {\n    Component.onCompleted: {\n        var command = \"ls\"\n        var process = Qt.createQmlObject('import QtQuick 2.0; import QtQml 2.0; Process { command: \"' + command + '\" }', parent)\n        process.start()\n        process.waitForFinished()\n        console.log(process.standardOutput())\n    }\n}\n```\n\n在上述代码中，我们使用`Qt.createQmlObject`方法创建了一个Process对象，并指定了要执行的Shell命令（这里是\"ls\"）。然后我们启动这个进程，并等待其完成。最后，我们通过`process.standardOutput()`获取命令的输出结果。\n\n## 使用Qt Framework中的QProcess类：\n\n```c++\n#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n#include <QProcess>\n\nint main(int argc, char *argv[])\n{\n    QGuiApplication app(argc, argv);\n\n    QQmlApplicationEngine engine;\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n\n    QProcess process;\n    QString command = \"ls\";\n    process.start(command);\n    process.waitForFinished();\n\n    qDebug() << QString(process.readAllStandardOutput());\n\n    return app.exec();\n}\n```\n\n在上述代码中，我们在C++中创建了一个QProcess对象，并指定了要执行的Shell命令（这里是\"ls\"）。然后，我们启动进程，并等待其完成。最后，我们通过`process.readAllStandardOutput()`获取命令的输出结果。\n\n## 使用JavaScript的`Qt.createQmlObject()`函数：\n\n```javascript\nimport QtQuick 2.0\nimport QtQml 2.0\n\nItem {\n    Component.onCompleted: {\n        var command = \"ls\"\n        var process = Qt.createQmlObject('import QtQuick 2.0; import QtQml 2.0; Process { command: \"' + command + '\" }', parent)\n        process.start()\n        process.waitForFinished()\n        console.log(process.standardOutput())\n    }\n}\n```\n\n这种方法与第一个示例相同，只是使用了JavaScript的字符串拼接来创建QML对象。\n\n## 使用Qt的`QProcess`类和信号槽机制：\n\n```cpp\n#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n#include <QProcess>\n\nint main(int argc, char *argv[])\n{\n    QGuiApplication app(argc, argv);\n\n    QQmlApplicationEngine engine;\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n\n    QProcess process;\n    QString command = \"ls\";\n\n    QObject::connect(&process, &QProcess::readyReadStandardOutput, [&]() {\n        qDebug() << QString(process.readAllStandardOutput());\n    });\n\n    process.start(command);\n    process.waitForFinished();\n\n    return app.exec();\n}\n```\n\n这个例子与前面提到的使用`QProcess`的方法类似，但是使用了信号-槽机制。通过连接`readyReadStandardOutput`信号和一个Lambda表达式，我们可以在Shell命令输出可读取时触发相应的操作。\n\n除了前面提到的方法，还可以考虑以下几种在QML中执行Shell命令的方法：\n\n## 使用Qt的`QProcess`类\n\n在C++代码中实现一个自定义的QML扩展类型（QML Extension Type）来执行Shell命令。\n\n```c++\n// ShellCommand.h\n#include <QObject>\n#include <QProcess>\n\nclass ShellCommand : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString command READ command WRITE setCommand NOTIFY commandChanged)\n    Q_PROPERTY(QString output READ output NOTIFY outputChanged)\n\npublic:\n    explicit ShellCommand(QObject *parent = nullptr);\n\n    QString command() const;\n    void setCommand(const QString& command);\n\n    QString output() const;\n\npublic slots:\n    void execute();\n\nsignals:\n    void commandChanged();\n    void outputChanged();\n\nprivate:\n    QString m_command;\n    QString m_output;\n};\n```\n\n```c++\n// ShellCommand.cpp\n#include \"ShellCommand.h\"\n\nShellCommand::ShellCommand(QObject *parent)\n    : QObject(parent)\n{\n}\n\nQString ShellCommand::command() const\n{\n    return m_command;\n}\n\nvoid ShellCommand::setCommand(const QString& command)\n{\n    if (m_command != command) {\n        m_command = command;\n        emit commandChanged();\n    }\n}\n\nQString ShellCommand::output() const\n{\n    return m_output;\n}\n\nvoid ShellCommand::execute()\n{\n    QProcess process;\n    process.start(m_command);\n    process.waitForFinished();\n    m_output = process.readAllStandardOutput();\n    emit outputChanged();\n}\n```\n\n然后在QML中使用这个自定义的QML扩展类型：\n\n```qml\nimport QtQuick 2.0\n\nShellCommand {\n    id: shellCmd\n    command: \"ls\"\n    onOutputChanged: console.log(shellCmd.output)\n    \n    Component.onCompleted: {\n        shellCmd.execute()\n    }\n}\n```\n\n上述代码中，我们在C++中定义了一个名为`ShellCommand`的自定义QML扩展类型，在其中使用`QProcess`来执行Shell命令，并将输出结果保存到`output`属性中。在QML中，我们创建了一个`ShellCommand`实例并指定要执行的命令，并通过监听`outputChanged`信号来打印输出结果。\n\n## 使用Qt的`QProcess`类并将输出结果绑定到一个QML属性\n\n```c++\n#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n#include <QProcess>\n\nint main(int argc, char *argv[])\n{\n    QGuiApplication app(argc, argv);\n\n    QQmlApplicationEngine engine;\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n\n    QProcess process;\n    QString command = \"ls\";\n    process.start(command);\n    process.waitForFinished();\n\n    engine.rootContext()->setContextProperty(\"shellOutput\", QString(process.readAllStandardOutput()));\n\n    return app.exec();\n}\n```\n\n在这个方法中，我们在C++中执行Shell命令，并将输出结果绑定到一个名为`shellOutput`的QML属性中。然后可以在QML中直接访问该属性来获取输出结果。\n\n## 在QML中执行Shell命令的方法是使用Qt的`QProcess`类并将输出结果通过信号传递给QML\n\n首先，在C++代码中定义一个继承自`QObject`的类，用于执行Shell命令：\n\n```c++\n// ShellCommand.h\n#include <QObject>\n#include <QProcess>\n\nclass ShellCommand : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit ShellCommand(QObject *parent = nullptr);\n\npublic slots:\n    void execute(const QString& command);\n\nsignals:\n    void outputReady(const QString& output);\n};\n```\n\n```c++\n// ShellCommand.cpp\n#include \"ShellCommand.h\"\n\nShellCommand::ShellCommand(QObject *parent)\n    : QObject(parent)\n{\n}\n\nvoid ShellCommand::execute(const QString& command)\n{\n    QProcess process;\n    process.start(command);\n    process.waitForFinished();\n    QString output = process.readAllStandardOutput();\n    emit outputReady(output);\n}\n```\n\n然后，在QML中引入该C++类，并使用`Connections`元素来处理信号：\n\n```qml\nimport QtQuick 2.0\n\nItem {\n    id: root\n    property string command: \"ls\"\n    property string output: \"\"\n\n    Connections {\n        target: shellCommand\n        onOutputReady: {\n            root.output = output\n            console.log(output)\n        }\n    }\n\n    ShellCommand {\n        id: shellCommand\n    }\n\n    Component.onCompleted: {\n        shellCommand.execute(root.command)\n    }\n}\n```\n\n在这个例子中，我们在QML中创建了一个名为`shellCommand`的`ShellCommand`对象，并指定要执行的命令为`root.command`属性。通过使用`Connections`元素，我们连接了`shellCommand`对象的`outputReady`信号，并在信号触发时将输出结果赋值给`root.output`属性，并显示在控制台中。\n\n使用这种方法，可以将Shell命令的执行与QML中其他元素的行为和状态关联起来。\n\n## 使用Qt的`QProcess`类和信号槽机制来执行Shell命令并获取输出结果。\n\n在C++代码中，定义一个继承自`QObject`的类，用于执行Shell命令并发送输出结果：\n\n```c++\n// ShellCommand.h\n#include <QObject>\n#include <QProcess>\n\nclass ShellCommand : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit ShellCommand(QObject *parent = nullptr);\n\npublic slots:\n    void execute(const QString& command);\n\nsignals:\n    void outputReady(const QString& output);\n};\n```\n\n```c++\n// ShellCommand.cpp\n#include \"ShellCommand.h\"\n\nShellCommand::ShellCommand(QObject *parent)\n    : QObject(parent)\n{\n}\n\nvoid ShellCommand::execute(const QString& command)\n{\n    QProcess process;\n    process.start(command);\n    process.waitForFinished();\n    QString output = process.readAllStandardOutput();\n    emit outputReady(output);\n}\n```\n\n然后，在QML中通过`Qt.createQmlObject()`函数创建一个匿名的JavaScript对象，并将其绑定到一个QML属性上：\n\n```qml\nimport QtQuick 2.0\n\nItem {\n    id: root\n    property string command: \"ls\"\n    property string output: \"\"\n\n    Component.onCompleted: {\n        var shellCommand = Qt.createQmlObject('import QtQuick 2.0; QtObject { signal outputReady(string output); function execute(command) { var process = Qt.createQmlObject(\"import QtQuick 2.0; Process { ... }\", this); process.command = command; process.finished.connect(function() { outputReady(process.output); }); process.start(); }}', root, \"shellCommand\");\n        shellCommand.outputReady.connect(function(output) {\n            root.output = output;\n            console.log(output);\n        });\n        shellCommand.execute(root.command);\n    }\n}\n```\n\n通过使用`Qt.createQmlObject()`函数，我们在QML中动态创建了一个匿名的JavaScript对象，并将其绑定到`root`对象上。这个JavaScript对象具有一个`execute()`方法用于执行Shell命令，并且会发送一个`outputReady`信号来传递输出结果。\n\n在这个例子中，当`Component.onCompleted`事件触发时，会创建该JavaScript对象并执行Shell命令。通过连接`outputReady`信号，我们可以更新`root.output`属性并在控制台中打印输出结果。\n","source":"_posts/Qml执行Shell.md","raw":"---\ntitle: Qml执行Shell\ndate: 2023-09-10 19:09:50\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Qml执行Shell\n\n在QML中执行Shell命令的方法取决于你正在使用的QML框架和操作系统。以下是一种常见的方法：\n\n## 在Qt Quick中使用Qt.createQmlObject方法\n\n```qml\nimport QtQuick 2.0\nimport QtQml 2.0\n\nItem {\n    Component.onCompleted: {\n        var command = \"ls\"\n        var process = Qt.createQmlObject('import QtQuick 2.0; import QtQml 2.0; Process { command: \"' + command + '\" }', parent)\n        process.start()\n        process.waitForFinished()\n        console.log(process.standardOutput())\n    }\n}\n```\n\n在上述代码中，我们使用`Qt.createQmlObject`方法创建了一个Process对象，并指定了要执行的Shell命令（这里是\"ls\"）。然后我们启动这个进程，并等待其完成。最后，我们通过`process.standardOutput()`获取命令的输出结果。\n\n## 使用Qt Framework中的QProcess类：\n\n```c++\n#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n#include <QProcess>\n\nint main(int argc, char *argv[])\n{\n    QGuiApplication app(argc, argv);\n\n    QQmlApplicationEngine engine;\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n\n    QProcess process;\n    QString command = \"ls\";\n    process.start(command);\n    process.waitForFinished();\n\n    qDebug() << QString(process.readAllStandardOutput());\n\n    return app.exec();\n}\n```\n\n在上述代码中，我们在C++中创建了一个QProcess对象，并指定了要执行的Shell命令（这里是\"ls\"）。然后，我们启动进程，并等待其完成。最后，我们通过`process.readAllStandardOutput()`获取命令的输出结果。\n\n## 使用JavaScript的`Qt.createQmlObject()`函数：\n\n```javascript\nimport QtQuick 2.0\nimport QtQml 2.0\n\nItem {\n    Component.onCompleted: {\n        var command = \"ls\"\n        var process = Qt.createQmlObject('import QtQuick 2.0; import QtQml 2.0; Process { command: \"' + command + '\" }', parent)\n        process.start()\n        process.waitForFinished()\n        console.log(process.standardOutput())\n    }\n}\n```\n\n这种方法与第一个示例相同，只是使用了JavaScript的字符串拼接来创建QML对象。\n\n## 使用Qt的`QProcess`类和信号槽机制：\n\n```cpp\n#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n#include <QProcess>\n\nint main(int argc, char *argv[])\n{\n    QGuiApplication app(argc, argv);\n\n    QQmlApplicationEngine engine;\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n\n    QProcess process;\n    QString command = \"ls\";\n\n    QObject::connect(&process, &QProcess::readyReadStandardOutput, [&]() {\n        qDebug() << QString(process.readAllStandardOutput());\n    });\n\n    process.start(command);\n    process.waitForFinished();\n\n    return app.exec();\n}\n```\n\n这个例子与前面提到的使用`QProcess`的方法类似，但是使用了信号-槽机制。通过连接`readyReadStandardOutput`信号和一个Lambda表达式，我们可以在Shell命令输出可读取时触发相应的操作。\n\n除了前面提到的方法，还可以考虑以下几种在QML中执行Shell命令的方法：\n\n## 使用Qt的`QProcess`类\n\n在C++代码中实现一个自定义的QML扩展类型（QML Extension Type）来执行Shell命令。\n\n```c++\n// ShellCommand.h\n#include <QObject>\n#include <QProcess>\n\nclass ShellCommand : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString command READ command WRITE setCommand NOTIFY commandChanged)\n    Q_PROPERTY(QString output READ output NOTIFY outputChanged)\n\npublic:\n    explicit ShellCommand(QObject *parent = nullptr);\n\n    QString command() const;\n    void setCommand(const QString& command);\n\n    QString output() const;\n\npublic slots:\n    void execute();\n\nsignals:\n    void commandChanged();\n    void outputChanged();\n\nprivate:\n    QString m_command;\n    QString m_output;\n};\n```\n\n```c++\n// ShellCommand.cpp\n#include \"ShellCommand.h\"\n\nShellCommand::ShellCommand(QObject *parent)\n    : QObject(parent)\n{\n}\n\nQString ShellCommand::command() const\n{\n    return m_command;\n}\n\nvoid ShellCommand::setCommand(const QString& command)\n{\n    if (m_command != command) {\n        m_command = command;\n        emit commandChanged();\n    }\n}\n\nQString ShellCommand::output() const\n{\n    return m_output;\n}\n\nvoid ShellCommand::execute()\n{\n    QProcess process;\n    process.start(m_command);\n    process.waitForFinished();\n    m_output = process.readAllStandardOutput();\n    emit outputChanged();\n}\n```\n\n然后在QML中使用这个自定义的QML扩展类型：\n\n```qml\nimport QtQuick 2.0\n\nShellCommand {\n    id: shellCmd\n    command: \"ls\"\n    onOutputChanged: console.log(shellCmd.output)\n    \n    Component.onCompleted: {\n        shellCmd.execute()\n    }\n}\n```\n\n上述代码中，我们在C++中定义了一个名为`ShellCommand`的自定义QML扩展类型，在其中使用`QProcess`来执行Shell命令，并将输出结果保存到`output`属性中。在QML中，我们创建了一个`ShellCommand`实例并指定要执行的命令，并通过监听`outputChanged`信号来打印输出结果。\n\n## 使用Qt的`QProcess`类并将输出结果绑定到一个QML属性\n\n```c++\n#include <QGuiApplication>\n#include <QQmlApplicationEngine>\n#include <QProcess>\n\nint main(int argc, char *argv[])\n{\n    QGuiApplication app(argc, argv);\n\n    QQmlApplicationEngine engine;\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n\n    QProcess process;\n    QString command = \"ls\";\n    process.start(command);\n    process.waitForFinished();\n\n    engine.rootContext()->setContextProperty(\"shellOutput\", QString(process.readAllStandardOutput()));\n\n    return app.exec();\n}\n```\n\n在这个方法中，我们在C++中执行Shell命令，并将输出结果绑定到一个名为`shellOutput`的QML属性中。然后可以在QML中直接访问该属性来获取输出结果。\n\n## 在QML中执行Shell命令的方法是使用Qt的`QProcess`类并将输出结果通过信号传递给QML\n\n首先，在C++代码中定义一个继承自`QObject`的类，用于执行Shell命令：\n\n```c++\n// ShellCommand.h\n#include <QObject>\n#include <QProcess>\n\nclass ShellCommand : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit ShellCommand(QObject *parent = nullptr);\n\npublic slots:\n    void execute(const QString& command);\n\nsignals:\n    void outputReady(const QString& output);\n};\n```\n\n```c++\n// ShellCommand.cpp\n#include \"ShellCommand.h\"\n\nShellCommand::ShellCommand(QObject *parent)\n    : QObject(parent)\n{\n}\n\nvoid ShellCommand::execute(const QString& command)\n{\n    QProcess process;\n    process.start(command);\n    process.waitForFinished();\n    QString output = process.readAllStandardOutput();\n    emit outputReady(output);\n}\n```\n\n然后，在QML中引入该C++类，并使用`Connections`元素来处理信号：\n\n```qml\nimport QtQuick 2.0\n\nItem {\n    id: root\n    property string command: \"ls\"\n    property string output: \"\"\n\n    Connections {\n        target: shellCommand\n        onOutputReady: {\n            root.output = output\n            console.log(output)\n        }\n    }\n\n    ShellCommand {\n        id: shellCommand\n    }\n\n    Component.onCompleted: {\n        shellCommand.execute(root.command)\n    }\n}\n```\n\n在这个例子中，我们在QML中创建了一个名为`shellCommand`的`ShellCommand`对象，并指定要执行的命令为`root.command`属性。通过使用`Connections`元素，我们连接了`shellCommand`对象的`outputReady`信号，并在信号触发时将输出结果赋值给`root.output`属性，并显示在控制台中。\n\n使用这种方法，可以将Shell命令的执行与QML中其他元素的行为和状态关联起来。\n\n## 使用Qt的`QProcess`类和信号槽机制来执行Shell命令并获取输出结果。\n\n在C++代码中，定义一个继承自`QObject`的类，用于执行Shell命令并发送输出结果：\n\n```c++\n// ShellCommand.h\n#include <QObject>\n#include <QProcess>\n\nclass ShellCommand : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit ShellCommand(QObject *parent = nullptr);\n\npublic slots:\n    void execute(const QString& command);\n\nsignals:\n    void outputReady(const QString& output);\n};\n```\n\n```c++\n// ShellCommand.cpp\n#include \"ShellCommand.h\"\n\nShellCommand::ShellCommand(QObject *parent)\n    : QObject(parent)\n{\n}\n\nvoid ShellCommand::execute(const QString& command)\n{\n    QProcess process;\n    process.start(command);\n    process.waitForFinished();\n    QString output = process.readAllStandardOutput();\n    emit outputReady(output);\n}\n```\n\n然后，在QML中通过`Qt.createQmlObject()`函数创建一个匿名的JavaScript对象，并将其绑定到一个QML属性上：\n\n```qml\nimport QtQuick 2.0\n\nItem {\n    id: root\n    property string command: \"ls\"\n    property string output: \"\"\n\n    Component.onCompleted: {\n        var shellCommand = Qt.createQmlObject('import QtQuick 2.0; QtObject { signal outputReady(string output); function execute(command) { var process = Qt.createQmlObject(\"import QtQuick 2.0; Process { ... }\", this); process.command = command; process.finished.connect(function() { outputReady(process.output); }); process.start(); }}', root, \"shellCommand\");\n        shellCommand.outputReady.connect(function(output) {\n            root.output = output;\n            console.log(output);\n        });\n        shellCommand.execute(root.command);\n    }\n}\n```\n\n通过使用`Qt.createQmlObject()`函数，我们在QML中动态创建了一个匿名的JavaScript对象，并将其绑定到`root`对象上。这个JavaScript对象具有一个`execute()`方法用于执行Shell命令，并且会发送一个`outputReady`信号来传递输出结果。\n\n在这个例子中，当`Component.onCompleted`事件触发时，会创建该JavaScript对象并执行Shell命令。通过连接`outputReady`信号，我们可以更新`root.output`属性并在控制台中打印输出结果。\n","slug":"Qml执行Shell","published":1,"updated":"2023-09-13T14:45:09.062Z","_id":"clmdd0naa0000945gdj3573bq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Qml执行Shell\"><a href=\"#Qml执行Shell\" class=\"headerlink\" title=\"Qml执行Shell\"></a>Qml执行Shell</h1><p>在QML中执行Shell命令的方法取决于你正在使用的QML框架和操作系统。以下是一种常见的方法：</p>\n<h2 id=\"在Qt-Quick中使用Qt-createQmlObject方法\"><a href=\"#在Qt-Quick中使用Qt-createQmlObject方法\" class=\"headerlink\" title=\"在Qt Quick中使用Qt.createQmlObject方法\"></a>在Qt Quick中使用Qt.createQmlObject方法</h2><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"><span class=\"hljs-keyword\">import</span> QtQuick <span class=\"hljs-number\">2.0</span><br><span class=\"hljs-keyword\">import</span> QtQml <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title\">Item</span> &#123;<br>    <span class=\"hljs-attribute\">Component.onCompleted</span>: &#123;<br>        <span class=\"hljs-keyword\">var</span> command = <span class=\"hljs-string\">&quot;ls&quot;</span><br>        <span class=\"hljs-keyword\">var</span> process = Qt.createQmlObject(<span class=\"hljs-string\">&#x27;import QtQuick 2.0; import QtQml 2.0; Process &#123; command: &quot;&#x27;</span> + command + <span class=\"hljs-string\">&#x27;&quot; &#125;&#x27;</span>, <span class=\"hljs-built_in\">parent</span>)<br>        process.start()<br>        process.waitForFinished()<br>        <span class=\"hljs-built_in\">console</span>.log(process.standardOutput())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，我们使用<code>Qt.createQmlObject</code>方法创建了一个Process对象，并指定了要执行的Shell命令（这里是”ls”）。然后我们启动这个进程，并等待其完成。最后，我们通过<code>process.standardOutput()</code>获取命令的输出结果。</p>\n<h2 id=\"使用Qt-Framework中的QProcess类：\"><a href=\"#使用Qt-Framework中的QProcess类：\" class=\"headerlink\" title=\"使用Qt Framework中的QProcess类：\"></a>使用Qt Framework中的QProcess类：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QGuiApplication&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QQmlApplicationEngine&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">QGuiApplication <span class=\"hljs-title\">app</span><span class=\"hljs-params\">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class=\"hljs-built_in\">load</span>(<span class=\"hljs-built_in\">QUrl</span>(<span class=\"hljs-built_in\">QStringLiteral</span>(<span class=\"hljs-string\">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class=\"hljs-string\">&quot;ls&quot;</span>;<br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br><br>    <span class=\"hljs-built_in\">qDebug</span>() &lt;&lt; <span class=\"hljs-built_in\">QString</span>(process.<span class=\"hljs-built_in\">readAllStandardOutput</span>());<br><br>    <span class=\"hljs-keyword\">return</span> app.<span class=\"hljs-built_in\">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，我们在C++中创建了一个QProcess对象，并指定了要执行的Shell命令（这里是”ls”）。然后，我们启动进程，并等待其完成。最后，我们通过<code>process.readAllStandardOutput()</code>获取命令的输出结果。</p>\n<h2 id=\"使用JavaScript的Qt-createQmlObject-函数：\"><a href=\"#使用JavaScript的Qt-createQmlObject-函数：\" class=\"headerlink\" title=\"使用JavaScript的Qt.createQmlObject()函数：\"></a>使用JavaScript的<code>Qt.createQmlObject()</code>函数：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">QtQuick</span> <span class=\"hljs-number\">2.0</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">QtQml</span> <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title class_\">Item</span> &#123;<br>    <span class=\"hljs-title class_\">Component</span>.<span class=\"hljs-property\">onCompleted</span>: &#123;<br>        <span class=\"hljs-keyword\">var</span> command = <span class=\"hljs-string\">&quot;ls&quot;</span><br>        <span class=\"hljs-keyword\">var</span> process = <span class=\"hljs-title class_\">Qt</span>.<span class=\"hljs-title function_\">createQmlObject</span>(<span class=\"hljs-string\">&#x27;import QtQuick 2.0; import QtQml 2.0; Process &#123; command: &quot;&#x27;</span> + command + <span class=\"hljs-string\">&#x27;&quot; &#125;&#x27;</span>, parent)<br>        process.<span class=\"hljs-title function_\">start</span>()<br>        process.<span class=\"hljs-title function_\">waitForFinished</span>()<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(process.<span class=\"hljs-title function_\">standardOutput</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这种方法与第一个示例相同，只是使用了JavaScript的字符串拼接来创建QML对象。</p>\n<h2 id=\"使用Qt的QProcess类和信号槽机制：\"><a href=\"#使用Qt的QProcess类和信号槽机制：\" class=\"headerlink\" title=\"使用Qt的QProcess类和信号槽机制：\"></a>使用Qt的<code>QProcess</code>类和信号槽机制：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QGuiApplication&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QQmlApplicationEngine&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">QGuiApplication <span class=\"hljs-title\">app</span><span class=\"hljs-params\">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class=\"hljs-built_in\">load</span>(<span class=\"hljs-built_in\">QUrl</span>(<span class=\"hljs-built_in\">QStringLiteral</span>(<span class=\"hljs-string\">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class=\"hljs-string\">&quot;ls&quot;</span>;<br><br>    QObject::<span class=\"hljs-built_in\">connect</span>(&amp;process, &amp;QProcess::readyReadStandardOutput, [&amp;]() &#123;<br>        <span class=\"hljs-built_in\">qDebug</span>() &lt;&lt; <span class=\"hljs-built_in\">QString</span>(process.<span class=\"hljs-built_in\">readAllStandardOutput</span>());<br>    &#125;);<br><br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br><br>    <span class=\"hljs-keyword\">return</span> app.<span class=\"hljs-built_in\">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个例子与前面提到的使用<code>QProcess</code>的方法类似，但是使用了信号-槽机制。通过连接<code>readyReadStandardOutput</code>信号和一个Lambda表达式，我们可以在Shell命令输出可读取时触发相应的操作。</p>\n<p>除了前面提到的方法，还可以考虑以下几种在QML中执行Shell命令的方法：</p>\n<h2 id=\"使用Qt的QProcess类\"><a href=\"#使用Qt的QProcess类\" class=\"headerlink\" title=\"使用Qt的QProcess类\"></a>使用Qt的<code>QProcess</code>类</h2><p>在C++代码中实现一个自定义的QML扩展类型（QML Extension Type）来执行Shell命令。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QObject&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShellCommand</span> : <span class=\"hljs-keyword\">public</span> QObject<br>&#123;<br>    <span class=\"hljs-function\">Q_OBJECT</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">Q_PROPERTY</span><span class=\"hljs-params\">(QString command READ command WRITE setCommand NOTIFY commandChanged)</span></span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">Q_PROPERTY</span><span class=\"hljs-params\">(QString output READ output NOTIFY outputChanged)</span></span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span>:</span><br><span class=\"hljs-function\">    explicit ShellCommand(QObject *parent =</span> <span class=\"hljs-literal\">nullptr</span>);<br><br>    <span class=\"hljs-function\">QString <span class=\"hljs-title\">command</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setCommand</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span>;<br><br>    <span class=\"hljs-function\">QString <span class=\"hljs-title\">output</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-keyword\">public</span> slots:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">()</span></span>;<br><br>signals:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">commandChanged</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">outputChanged</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-keyword\">private</span>:<br>    QString m_command;<br>    QString m_output;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class=\"hljs-built_in\">ShellCommand</span>(QObject *parent)<br>    : <span class=\"hljs-built_in\">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class=\"hljs-function\">QString <span class=\"hljs-title\">ShellCommand::command</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> m_command;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ShellCommand::setCommand</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (m_command != command) &#123;<br>        m_command = command;<br>        <span class=\"hljs-function\">emit <span class=\"hljs-title\">commandChanged</span><span class=\"hljs-params\">()</span></span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\">QString <span class=\"hljs-title\">ShellCommand::output</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> m_output;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ShellCommand::execute</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    QProcess process;<br>    process.<span class=\"hljs-built_in\">start</span>(m_command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br>    m_output = process.<span class=\"hljs-built_in\">readAllStandardOutput</span>();<br>    <span class=\"hljs-function\">emit <span class=\"hljs-title\">outputChanged</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后在QML中使用这个自定义的QML扩展类型：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"><span class=\"hljs-keyword\">import</span> QtQuick <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title\">ShellCommand</span> &#123;<br>    <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> shellCmd</span><br>    <span class=\"hljs-attribute\">command</span>: <span class=\"hljs-string\">&quot;ls&quot;</span><br>    <span class=\"hljs-attribute\">onOutputChanged</span>: <span class=\"hljs-built_in\">console</span>.log(shellCmd.output)<br>    <br>    <span class=\"hljs-attribute\">Component.onCompleted</span>: &#123;<br>        shellCmd.execute()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们在C++中定义了一个名为<code>ShellCommand</code>的自定义QML扩展类型，在其中使用<code>QProcess</code>来执行Shell命令，并将输出结果保存到<code>output</code>属性中。在QML中，我们创建了一个<code>ShellCommand</code>实例并指定要执行的命令，并通过监听<code>outputChanged</code>信号来打印输出结果。</p>\n<h2 id=\"使用Qt的QProcess类并将输出结果绑定到一个QML属性\"><a href=\"#使用Qt的QProcess类并将输出结果绑定到一个QML属性\" class=\"headerlink\" title=\"使用Qt的QProcess类并将输出结果绑定到一个QML属性\"></a>使用Qt的<code>QProcess</code>类并将输出结果绑定到一个QML属性</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QGuiApplication&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QQmlApplicationEngine&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">QGuiApplication <span class=\"hljs-title\">app</span><span class=\"hljs-params\">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class=\"hljs-built_in\">load</span>(<span class=\"hljs-built_in\">QUrl</span>(<span class=\"hljs-built_in\">QStringLiteral</span>(<span class=\"hljs-string\">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class=\"hljs-string\">&quot;ls&quot;</span>;<br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br><br>    engine.<span class=\"hljs-built_in\">rootContext</span>()-&gt;<span class=\"hljs-built_in\">setContextProperty</span>(<span class=\"hljs-string\">&quot;shellOutput&quot;</span>, <span class=\"hljs-built_in\">QString</span>(process.<span class=\"hljs-built_in\">readAllStandardOutput</span>()));<br><br>    <span class=\"hljs-keyword\">return</span> app.<span class=\"hljs-built_in\">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个方法中，我们在C++中执行Shell命令，并将输出结果绑定到一个名为<code>shellOutput</code>的QML属性中。然后可以在QML中直接访问该属性来获取输出结果。</p>\n<h2 id=\"在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML\"><a href=\"#在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML\" class=\"headerlink\" title=\"在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML\"></a>在QML中执行Shell命令的方法是使用Qt的<code>QProcess</code>类并将输出结果通过信号传递给QML</h2><p>首先，在C++代码中定义一个继承自<code>QObject</code>的类，用于执行Shell命令：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QObject&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShellCommand</span> : <span class=\"hljs-keyword\">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">ShellCommand</span><span class=\"hljs-params\">(QObject *parent = <span class=\"hljs-literal\">nullptr</span>)</span></span>;<br><br><span class=\"hljs-keyword\">public</span> slots:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span>;<br><br>signals:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">outputReady</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; output)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class=\"hljs-built_in\">ShellCommand</span>(QObject *parent)<br>    : <span class=\"hljs-built_in\">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ShellCommand::execute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    QProcess process;<br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br>    QString output = process.<span class=\"hljs-built_in\">readAllStandardOutput</span>();<br>    <span class=\"hljs-function\">emit <span class=\"hljs-title\">outputReady</span><span class=\"hljs-params\">(output)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，在QML中引入该C++类，并使用<code>Connections</code>元素来处理信号：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"><span class=\"hljs-keyword\">import</span> QtQuick <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title\">Item</span> &#123;<br>    <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> root</span><br>    <span class=\"hljs-keyword\">property</span><span class=\"hljs-string\"> string command</span>: <span class=\"hljs-string\">&quot;ls&quot;</span><br>    <span class=\"hljs-keyword\">property</span><span class=\"hljs-string\"> string output</span>: <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-title\">Connections</span> &#123;<br>        <span class=\"hljs-attribute\">target</span>: shellCommand<br>        <span class=\"hljs-attribute\">onOutputReady</span>: &#123;<br>            root.output = output<br>            <span class=\"hljs-built_in\">console</span>.log(output)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-title\">ShellCommand</span> &#123;<br>        <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> shellCommand</span><br>    &#125;<br><br>    <span class=\"hljs-attribute\">Component.onCompleted</span>: &#123;<br>        shellCommand.execute(root.command)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们在QML中创建了一个名为<code>shellCommand</code>的<code>ShellCommand</code>对象，并指定要执行的命令为<code>root.command</code>属性。通过使用<code>Connections</code>元素，我们连接了<code>shellCommand</code>对象的<code>outputReady</code>信号，并在信号触发时将输出结果赋值给<code>root.output</code>属性，并显示在控制台中。</p>\n<p>使用这种方法，可以将Shell命令的执行与QML中其他元素的行为和状态关联起来。</p>\n<h2 id=\"使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。\"><a href=\"#使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。\" class=\"headerlink\" title=\"使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。\"></a>使用Qt的<code>QProcess</code>类和信号槽机制来执行Shell命令并获取输出结果。</h2><p>在C++代码中，定义一个继承自<code>QObject</code>的类，用于执行Shell命令并发送输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QObject&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShellCommand</span> : <span class=\"hljs-keyword\">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">ShellCommand</span><span class=\"hljs-params\">(QObject *parent = <span class=\"hljs-literal\">nullptr</span>)</span></span>;<br><br><span class=\"hljs-keyword\">public</span> slots:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span>;<br><br>signals:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">outputReady</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; output)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class=\"hljs-built_in\">ShellCommand</span>(QObject *parent)<br>    : <span class=\"hljs-built_in\">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ShellCommand::execute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    QProcess process;<br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br>    QString output = process.<span class=\"hljs-built_in\">readAllStandardOutput</span>();<br>    <span class=\"hljs-function\">emit <span class=\"hljs-title\">outputReady</span><span class=\"hljs-params\">(output)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，在QML中通过<code>Qt.createQmlObject()</code>函数创建一个匿名的JavaScript对象，并将其绑定到一个QML属性上：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"><span class=\"hljs-keyword\">import</span> QtQuick <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title\">Item</span> &#123;<br>    <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> root</span><br>    <span class=\"hljs-keyword\">property</span><span class=\"hljs-string\"> string command</span>: <span class=\"hljs-string\">&quot;ls&quot;</span><br>    <span class=\"hljs-keyword\">property</span><span class=\"hljs-string\"> string output</span>: <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-attribute\">Component.onCompleted</span>: &#123;<br>        <span class=\"hljs-keyword\">var</span> shellCommand = Qt.createQmlObject(<span class=\"hljs-string\">&#x27;import QtQuick 2.0; QtObject &#123; signal outputReady(string output); function execute(command) &#123; var process = Qt.createQmlObject(&quot;import QtQuick 2.0; Process &#123; ... &#125;&quot;, this); process.command = command; process.finished.connect(function() &#123; outputReady(process.output); &#125;); process.start(); &#125;&#125;&#x27;</span>, root, <span class=\"hljs-string\">&quot;shellCommand&quot;</span>);<br>        shellCommand.outputReady.connect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">output</span>) </span>&#123;<br>            root.output = output;<br>            <span class=\"hljs-built_in\">console</span>.log(output);<br>        &#125;);<br>        shellCommand.execute(root.command);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过使用<code>Qt.createQmlObject()</code>函数，我们在QML中动态创建了一个匿名的JavaScript对象，并将其绑定到<code>root</code>对象上。这个JavaScript对象具有一个<code>execute()</code>方法用于执行Shell命令，并且会发送一个<code>outputReady</code>信号来传递输出结果。</p>\n<p>在这个例子中，当<code>Component.onCompleted</code>事件触发时，会创建该JavaScript对象并执行Shell命令。通过连接<code>outputReady</code>信号，我们可以更新<code>root.output</code>属性并在控制台中打印输出结果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Qml执行Shell\"><a href=\"#Qml执行Shell\" class=\"headerlink\" title=\"Qml执行Shell\"></a>Qml执行Shell</h1><p>在QML中执行Shell命令的方法取决于你正在使用的QML框架和操作系统。以下是一种常见的方法：</p>\n<h2 id=\"在Qt-Quick中使用Qt-createQmlObject方法\"><a href=\"#在Qt-Quick中使用Qt-createQmlObject方法\" class=\"headerlink\" title=\"在Qt Quick中使用Qt.createQmlObject方法\"></a>在Qt Quick中使用Qt.createQmlObject方法</h2><figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"><span class=\"hljs-keyword\">import</span> QtQuick <span class=\"hljs-number\">2.0</span><br><span class=\"hljs-keyword\">import</span> QtQml <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title\">Item</span> &#123;<br>    <span class=\"hljs-attribute\">Component.onCompleted</span>: &#123;<br>        <span class=\"hljs-keyword\">var</span> command = <span class=\"hljs-string\">&quot;ls&quot;</span><br>        <span class=\"hljs-keyword\">var</span> process = Qt.createQmlObject(<span class=\"hljs-string\">&#x27;import QtQuick 2.0; import QtQml 2.0; Process &#123; command: &quot;&#x27;</span> + command + <span class=\"hljs-string\">&#x27;&quot; &#125;&#x27;</span>, <span class=\"hljs-built_in\">parent</span>)<br>        process.start()<br>        process.waitForFinished()<br>        <span class=\"hljs-built_in\">console</span>.log(process.standardOutput())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，我们使用<code>Qt.createQmlObject</code>方法创建了一个Process对象，并指定了要执行的Shell命令（这里是”ls”）。然后我们启动这个进程，并等待其完成。最后，我们通过<code>process.standardOutput()</code>获取命令的输出结果。</p>\n<h2 id=\"使用Qt-Framework中的QProcess类：\"><a href=\"#使用Qt-Framework中的QProcess类：\" class=\"headerlink\" title=\"使用Qt Framework中的QProcess类：\"></a>使用Qt Framework中的QProcess类：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QGuiApplication&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QQmlApplicationEngine&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">QGuiApplication <span class=\"hljs-title\">app</span><span class=\"hljs-params\">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class=\"hljs-built_in\">load</span>(<span class=\"hljs-built_in\">QUrl</span>(<span class=\"hljs-built_in\">QStringLiteral</span>(<span class=\"hljs-string\">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class=\"hljs-string\">&quot;ls&quot;</span>;<br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br><br>    <span class=\"hljs-built_in\">qDebug</span>() &lt;&lt; <span class=\"hljs-built_in\">QString</span>(process.<span class=\"hljs-built_in\">readAllStandardOutput</span>());<br><br>    <span class=\"hljs-keyword\">return</span> app.<span class=\"hljs-built_in\">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，我们在C++中创建了一个QProcess对象，并指定了要执行的Shell命令（这里是”ls”）。然后，我们启动进程，并等待其完成。最后，我们通过<code>process.readAllStandardOutput()</code>获取命令的输出结果。</p>\n<h2 id=\"使用JavaScript的Qt-createQmlObject-函数：\"><a href=\"#使用JavaScript的Qt-createQmlObject-函数：\" class=\"headerlink\" title=\"使用JavaScript的Qt.createQmlObject()函数：\"></a>使用JavaScript的<code>Qt.createQmlObject()</code>函数：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">QtQuick</span> <span class=\"hljs-number\">2.0</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">QtQml</span> <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title class_\">Item</span> &#123;<br>    <span class=\"hljs-title class_\">Component</span>.<span class=\"hljs-property\">onCompleted</span>: &#123;<br>        <span class=\"hljs-keyword\">var</span> command = <span class=\"hljs-string\">&quot;ls&quot;</span><br>        <span class=\"hljs-keyword\">var</span> process = <span class=\"hljs-title class_\">Qt</span>.<span class=\"hljs-title function_\">createQmlObject</span>(<span class=\"hljs-string\">&#x27;import QtQuick 2.0; import QtQml 2.0; Process &#123; command: &quot;&#x27;</span> + command + <span class=\"hljs-string\">&#x27;&quot; &#125;&#x27;</span>, parent)<br>        process.<span class=\"hljs-title function_\">start</span>()<br>        process.<span class=\"hljs-title function_\">waitForFinished</span>()<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(process.<span class=\"hljs-title function_\">standardOutput</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这种方法与第一个示例相同，只是使用了JavaScript的字符串拼接来创建QML对象。</p>\n<h2 id=\"使用Qt的QProcess类和信号槽机制：\"><a href=\"#使用Qt的QProcess类和信号槽机制：\" class=\"headerlink\" title=\"使用Qt的QProcess类和信号槽机制：\"></a>使用Qt的<code>QProcess</code>类和信号槽机制：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QGuiApplication&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QQmlApplicationEngine&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">QGuiApplication <span class=\"hljs-title\">app</span><span class=\"hljs-params\">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class=\"hljs-built_in\">load</span>(<span class=\"hljs-built_in\">QUrl</span>(<span class=\"hljs-built_in\">QStringLiteral</span>(<span class=\"hljs-string\">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class=\"hljs-string\">&quot;ls&quot;</span>;<br><br>    QObject::<span class=\"hljs-built_in\">connect</span>(&amp;process, &amp;QProcess::readyReadStandardOutput, [&amp;]() &#123;<br>        <span class=\"hljs-built_in\">qDebug</span>() &lt;&lt; <span class=\"hljs-built_in\">QString</span>(process.<span class=\"hljs-built_in\">readAllStandardOutput</span>());<br>    &#125;);<br><br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br><br>    <span class=\"hljs-keyword\">return</span> app.<span class=\"hljs-built_in\">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个例子与前面提到的使用<code>QProcess</code>的方法类似，但是使用了信号-槽机制。通过连接<code>readyReadStandardOutput</code>信号和一个Lambda表达式，我们可以在Shell命令输出可读取时触发相应的操作。</p>\n<p>除了前面提到的方法，还可以考虑以下几种在QML中执行Shell命令的方法：</p>\n<h2 id=\"使用Qt的QProcess类\"><a href=\"#使用Qt的QProcess类\" class=\"headerlink\" title=\"使用Qt的QProcess类\"></a>使用Qt的<code>QProcess</code>类</h2><p>在C++代码中实现一个自定义的QML扩展类型（QML Extension Type）来执行Shell命令。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QObject&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShellCommand</span> : <span class=\"hljs-keyword\">public</span> QObject<br>&#123;<br>    <span class=\"hljs-function\">Q_OBJECT</span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">Q_PROPERTY</span><span class=\"hljs-params\">(QString command READ command WRITE setCommand NOTIFY commandChanged)</span></span><br><span class=\"hljs-function\">    <span class=\"hljs-title\">Q_PROPERTY</span><span class=\"hljs-params\">(QString output READ output NOTIFY outputChanged)</span></span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span>:</span><br><span class=\"hljs-function\">    explicit ShellCommand(QObject *parent =</span> <span class=\"hljs-literal\">nullptr</span>);<br><br>    <span class=\"hljs-function\">QString <span class=\"hljs-title\">command</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setCommand</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span>;<br><br>    <span class=\"hljs-function\">QString <span class=\"hljs-title\">output</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-keyword\">public</span> slots:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">()</span></span>;<br><br>signals:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">commandChanged</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">outputChanged</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-keyword\">private</span>:<br>    QString m_command;<br>    QString m_output;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class=\"hljs-built_in\">ShellCommand</span>(QObject *parent)<br>    : <span class=\"hljs-built_in\">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class=\"hljs-function\">QString <span class=\"hljs-title\">ShellCommand::command</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> m_command;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ShellCommand::setCommand</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (m_command != command) &#123;<br>        m_command = command;<br>        <span class=\"hljs-function\">emit <span class=\"hljs-title\">commandChanged</span><span class=\"hljs-params\">()</span></span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\">QString <span class=\"hljs-title\">ShellCommand::output</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> m_output;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ShellCommand::execute</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    QProcess process;<br>    process.<span class=\"hljs-built_in\">start</span>(m_command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br>    m_output = process.<span class=\"hljs-built_in\">readAllStandardOutput</span>();<br>    <span class=\"hljs-function\">emit <span class=\"hljs-title\">outputChanged</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后在QML中使用这个自定义的QML扩展类型：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"><span class=\"hljs-keyword\">import</span> QtQuick <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title\">ShellCommand</span> &#123;<br>    <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> shellCmd</span><br>    <span class=\"hljs-attribute\">command</span>: <span class=\"hljs-string\">&quot;ls&quot;</span><br>    <span class=\"hljs-attribute\">onOutputChanged</span>: <span class=\"hljs-built_in\">console</span>.log(shellCmd.output)<br>    <br>    <span class=\"hljs-attribute\">Component.onCompleted</span>: &#123;<br>        shellCmd.execute()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们在C++中定义了一个名为<code>ShellCommand</code>的自定义QML扩展类型，在其中使用<code>QProcess</code>来执行Shell命令，并将输出结果保存到<code>output</code>属性中。在QML中，我们创建了一个<code>ShellCommand</code>实例并指定要执行的命令，并通过监听<code>outputChanged</code>信号来打印输出结果。</p>\n<h2 id=\"使用Qt的QProcess类并将输出结果绑定到一个QML属性\"><a href=\"#使用Qt的QProcess类并将输出结果绑定到一个QML属性\" class=\"headerlink\" title=\"使用Qt的QProcess类并将输出结果绑定到一个QML属性\"></a>使用Qt的<code>QProcess</code>类并将输出结果绑定到一个QML属性</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QGuiApplication&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QQmlApplicationEngine&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">QGuiApplication <span class=\"hljs-title\">app</span><span class=\"hljs-params\">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class=\"hljs-built_in\">load</span>(<span class=\"hljs-built_in\">QUrl</span>(<span class=\"hljs-built_in\">QStringLiteral</span>(<span class=\"hljs-string\">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class=\"hljs-string\">&quot;ls&quot;</span>;<br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br><br>    engine.<span class=\"hljs-built_in\">rootContext</span>()-&gt;<span class=\"hljs-built_in\">setContextProperty</span>(<span class=\"hljs-string\">&quot;shellOutput&quot;</span>, <span class=\"hljs-built_in\">QString</span>(process.<span class=\"hljs-built_in\">readAllStandardOutput</span>()));<br><br>    <span class=\"hljs-keyword\">return</span> app.<span class=\"hljs-built_in\">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个方法中，我们在C++中执行Shell命令，并将输出结果绑定到一个名为<code>shellOutput</code>的QML属性中。然后可以在QML中直接访问该属性来获取输出结果。</p>\n<h2 id=\"在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML\"><a href=\"#在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML\" class=\"headerlink\" title=\"在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML\"></a>在QML中执行Shell命令的方法是使用Qt的<code>QProcess</code>类并将输出结果通过信号传递给QML</h2><p>首先，在C++代码中定义一个继承自<code>QObject</code>的类，用于执行Shell命令：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QObject&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShellCommand</span> : <span class=\"hljs-keyword\">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">ShellCommand</span><span class=\"hljs-params\">(QObject *parent = <span class=\"hljs-literal\">nullptr</span>)</span></span>;<br><br><span class=\"hljs-keyword\">public</span> slots:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span>;<br><br>signals:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">outputReady</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; output)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class=\"hljs-built_in\">ShellCommand</span>(QObject *parent)<br>    : <span class=\"hljs-built_in\">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ShellCommand::execute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    QProcess process;<br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br>    QString output = process.<span class=\"hljs-built_in\">readAllStandardOutput</span>();<br>    <span class=\"hljs-function\">emit <span class=\"hljs-title\">outputReady</span><span class=\"hljs-params\">(output)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，在QML中引入该C++类，并使用<code>Connections</code>元素来处理信号：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"><span class=\"hljs-keyword\">import</span> QtQuick <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title\">Item</span> &#123;<br>    <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> root</span><br>    <span class=\"hljs-keyword\">property</span><span class=\"hljs-string\"> string command</span>: <span class=\"hljs-string\">&quot;ls&quot;</span><br>    <span class=\"hljs-keyword\">property</span><span class=\"hljs-string\"> string output</span>: <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-title\">Connections</span> &#123;<br>        <span class=\"hljs-attribute\">target</span>: shellCommand<br>        <span class=\"hljs-attribute\">onOutputReady</span>: &#123;<br>            root.output = output<br>            <span class=\"hljs-built_in\">console</span>.log(output)<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-title\">ShellCommand</span> &#123;<br>        <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> shellCommand</span><br>    &#125;<br><br>    <span class=\"hljs-attribute\">Component.onCompleted</span>: &#123;<br>        shellCommand.execute(root.command)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们在QML中创建了一个名为<code>shellCommand</code>的<code>ShellCommand</code>对象，并指定要执行的命令为<code>root.command</code>属性。通过使用<code>Connections</code>元素，我们连接了<code>shellCommand</code>对象的<code>outputReady</code>信号，并在信号触发时将输出结果赋值给<code>root.output</code>属性，并显示在控制台中。</p>\n<p>使用这种方法，可以将Shell命令的执行与QML中其他元素的行为和状态关联起来。</p>\n<h2 id=\"使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。\"><a href=\"#使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。\" class=\"headerlink\" title=\"使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。\"></a>使用Qt的<code>QProcess</code>类和信号槽机制来执行Shell命令并获取输出结果。</h2><p>在C++代码中，定义一个继承自<code>QObject</code>的类，用于执行Shell命令并发送输出结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QObject&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;QProcess&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShellCommand</span> : <span class=\"hljs-keyword\">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">ShellCommand</span><span class=\"hljs-params\">(QObject *parent = <span class=\"hljs-literal\">nullptr</span>)</span></span>;<br><br><span class=\"hljs-keyword\">public</span> slots:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span>;<br><br>signals:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">outputReady</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; output)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ShellCommand.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class=\"hljs-built_in\">ShellCommand</span>(QObject *parent)<br>    : <span class=\"hljs-built_in\">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ShellCommand::execute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> QString&amp; command)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    QProcess process;<br>    process.<span class=\"hljs-built_in\">start</span>(command);<br>    process.<span class=\"hljs-built_in\">waitForFinished</span>();<br>    QString output = process.<span class=\"hljs-built_in\">readAllStandardOutput</span>();<br>    <span class=\"hljs-function\">emit <span class=\"hljs-title\">outputReady</span><span class=\"hljs-params\">(output)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，在QML中通过<code>Qt.createQmlObject()</code>函数创建一个匿名的JavaScript对象，并将其绑定到一个QML属性上：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs qml\"><span class=\"hljs-keyword\">import</span> QtQuick <span class=\"hljs-number\">2.0</span><br><br><span class=\"hljs-title\">Item</span> &#123;<br>    <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> root</span><br>    <span class=\"hljs-keyword\">property</span><span class=\"hljs-string\"> string command</span>: <span class=\"hljs-string\">&quot;ls&quot;</span><br>    <span class=\"hljs-keyword\">property</span><span class=\"hljs-string\"> string output</span>: <span class=\"hljs-string\">&quot;&quot;</span><br><br>    <span class=\"hljs-attribute\">Component.onCompleted</span>: &#123;<br>        <span class=\"hljs-keyword\">var</span> shellCommand = Qt.createQmlObject(<span class=\"hljs-string\">&#x27;import QtQuick 2.0; QtObject &#123; signal outputReady(string output); function execute(command) &#123; var process = Qt.createQmlObject(&quot;import QtQuick 2.0; Process &#123; ... &#125;&quot;, this); process.command = command; process.finished.connect(function() &#123; outputReady(process.output); &#125;); process.start(); &#125;&#125;&#x27;</span>, root, <span class=\"hljs-string\">&quot;shellCommand&quot;</span>);<br>        shellCommand.outputReady.connect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">output</span>) </span>&#123;<br>            root.output = output;<br>            <span class=\"hljs-built_in\">console</span>.log(output);<br>        &#125;);<br>        shellCommand.execute(root.command);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过使用<code>Qt.createQmlObject()</code>函数，我们在QML中动态创建了一个匿名的JavaScript对象，并将其绑定到<code>root</code>对象上。这个JavaScript对象具有一个<code>execute()</code>方法用于执行Shell命令，并且会发送一个<code>outputReady</code>信号来传递输出结果。</p>\n<p>在这个例子中，当<code>Component.onCompleted</code>事件触发时，会创建该JavaScript对象并执行Shell命令。通过连接<code>outputReady</code>信号，我们可以更新<code>root.output</code>属性并在控制台中打印输出结果。</p>\n"},{"title":"Python执行Shell","date":"2023-09-10T13:14:47.000Z","author":"Grey-Wind","_content":"\n# Python执行Shell\n\n在Python中，有多种方法可以执行Shell命令。以下是一些常用的方法。\n\n## 使用`os.system`函数\n\n```python\nimport os\nos.system(\"shell 命令\")\n```\n该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。\n\n## 使用`subprocess.run`函数\n\n```python\nimport subprocess\nsubprocess.run(\"shell 命令\", shell=True)\n```\n该方法执行命令，并可以通过`subprocess.CompletedProcess`对象获取命令的返回值、输出和错误信息。\n\n## 使用`subprocess.Popen`类\n\n```python\nimport subprocess\nprocess = subprocess.Popen(\"shell 命令\", shell=True, stdout=subprocess.PIPE)\noutput, _ = process.communicate()\nprint(output.decode())\n```\n该方法也可执行命令，并通过`Popen`对象控制进程和获取输出。这里使用`communicate()`方法获取命令的输出。\n\n## 使用`os.popen`函数（已过时）\n\n```python\nimport os\noutput = os.popen(\"shell 命令\").read()\nprint(output)\n```\n该方法执行命令，并返回命令的输出。但由于安全性和可维护性等问题，不推荐使用。\n\n## 使用`os.system`函数\n\n```python\nimport os\nos.system(\"shell 命令\")\n```\n该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。\n\n## 使用`subprocess.check_output`函数\n\n```python\nimport subprocess\noutput = subprocess.check_output(\"shell 命令\", shell=True)\nprint(output.decode())\n```\n该方法执行命令，并返回命令的输出。但如果命令返回非零状态码，则会引发`subprocess.CalledProcessError`异常。\n\n## 使用`subprocess.Popen`类\n\n```python\nimport subprocess\nprocess = subprocess.Popen(\"shell 命令\", shell=True, stdout=subprocess.PIPE)\noutput, _ = process.communicate()\nprint(output.decode())\n```\n该方法也可执行命令，并通过`Popen`对象控制进程和获取输出。这里使用`communicate()`方法获取命令的输出。\n\n当然，还有一些其他的方法可以执行Shell命令。以下是其中几种常见的方法：\n\n## 使用`os.exec*`系列函数\n\n```python\nimport os\nos.exec*(命令)\n```\n这里的`*`代表不同的函数，例如`os.execlp`、`os.execvp`等。这些函数会替换当前进程，并直接执行指定的命令。\n\n## 使用第三方库\n\n### sh库\n\n```python\nimport sh\n\n# 执行命令并获取输出\noutput = sh.shell命令()\nprint(output)\n\n# 指定命令路径执行\noutput = sh.Command('命令路径')()\nprint(output)\n\n# 处理命令的输入和输出\ncommand = sh.Command('命令路径')\noutput = command('输入内容')\nprint(output)\n```\n在示例中，我们通过导入`sh`模块或者使用`Command`类来执行Shell命令。可以直接调用Shell命令作为函数，并使用`()`传递输入内容。还可以使用`Command`类指定命令的路径。\n\n`sh`库提供了简洁和易用的方式来执行Shell命令，并自动处理了输入和输出。你可以根据具体的需求使用`sh`库来执行Shell命令。\n\n### `plumbum`库\n\n```python\nfrom plumbum import local\n\n# 执行命令并获取输出\noutput = local[\"shell 命令\"]()\nprint(output)\n\n# 指定工作目录执行命令\nwith local.cwd(\"/path/to/directory\"):\n    output = local[\"shell 命令\"]()\n\n# 处理命令的输入和输出\ncmd = local[\"shell 命令\"]\noutput = cmd(\"输入内容\")\nprint(output)\n\n# 获取命令执行的返回码\ncmd = local[\"shell 命令\"]\ncmd.run()  # 执行命令\nreturn_code = cmd.returncode  # 获取返回码\n```\n\n在示例中，我们通过导入`local`对象来执行Shell命令。使用`local`对象，我们可以像调用函数一样来执行Shell命令，并通过`()`传递输入内容。还可以使用`cwd`方法指定执行命令时的工作目录。可以通过`run()`方法执行命令，并使用`returncode`属性获取返回码。\n\n`plumbum`库提供了更加简洁和高级的方式来执行Shell命令。它支持输入输出、文件操作以及远程命令执行等功能，具有更好的可读性和易用性。你可以根据自己的需求使用`plumbum`库来执行Shell命令。\n","source":"_posts/Python执行Shell.md","raw":"---\ntitle: Python执行Shell\ndate: 2023-09-10 21:14:47\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Python执行Shell\n\n在Python中，有多种方法可以执行Shell命令。以下是一些常用的方法。\n\n## 使用`os.system`函数\n\n```python\nimport os\nos.system(\"shell 命令\")\n```\n该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。\n\n## 使用`subprocess.run`函数\n\n```python\nimport subprocess\nsubprocess.run(\"shell 命令\", shell=True)\n```\n该方法执行命令，并可以通过`subprocess.CompletedProcess`对象获取命令的返回值、输出和错误信息。\n\n## 使用`subprocess.Popen`类\n\n```python\nimport subprocess\nprocess = subprocess.Popen(\"shell 命令\", shell=True, stdout=subprocess.PIPE)\noutput, _ = process.communicate()\nprint(output.decode())\n```\n该方法也可执行命令，并通过`Popen`对象控制进程和获取输出。这里使用`communicate()`方法获取命令的输出。\n\n## 使用`os.popen`函数（已过时）\n\n```python\nimport os\noutput = os.popen(\"shell 命令\").read()\nprint(output)\n```\n该方法执行命令，并返回命令的输出。但由于安全性和可维护性等问题，不推荐使用。\n\n## 使用`os.system`函数\n\n```python\nimport os\nos.system(\"shell 命令\")\n```\n该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。\n\n## 使用`subprocess.check_output`函数\n\n```python\nimport subprocess\noutput = subprocess.check_output(\"shell 命令\", shell=True)\nprint(output.decode())\n```\n该方法执行命令，并返回命令的输出。但如果命令返回非零状态码，则会引发`subprocess.CalledProcessError`异常。\n\n## 使用`subprocess.Popen`类\n\n```python\nimport subprocess\nprocess = subprocess.Popen(\"shell 命令\", shell=True, stdout=subprocess.PIPE)\noutput, _ = process.communicate()\nprint(output.decode())\n```\n该方法也可执行命令，并通过`Popen`对象控制进程和获取输出。这里使用`communicate()`方法获取命令的输出。\n\n当然，还有一些其他的方法可以执行Shell命令。以下是其中几种常见的方法：\n\n## 使用`os.exec*`系列函数\n\n```python\nimport os\nos.exec*(命令)\n```\n这里的`*`代表不同的函数，例如`os.execlp`、`os.execvp`等。这些函数会替换当前进程，并直接执行指定的命令。\n\n## 使用第三方库\n\n### sh库\n\n```python\nimport sh\n\n# 执行命令并获取输出\noutput = sh.shell命令()\nprint(output)\n\n# 指定命令路径执行\noutput = sh.Command('命令路径')()\nprint(output)\n\n# 处理命令的输入和输出\ncommand = sh.Command('命令路径')\noutput = command('输入内容')\nprint(output)\n```\n在示例中，我们通过导入`sh`模块或者使用`Command`类来执行Shell命令。可以直接调用Shell命令作为函数，并使用`()`传递输入内容。还可以使用`Command`类指定命令的路径。\n\n`sh`库提供了简洁和易用的方式来执行Shell命令，并自动处理了输入和输出。你可以根据具体的需求使用`sh`库来执行Shell命令。\n\n### `plumbum`库\n\n```python\nfrom plumbum import local\n\n# 执行命令并获取输出\noutput = local[\"shell 命令\"]()\nprint(output)\n\n# 指定工作目录执行命令\nwith local.cwd(\"/path/to/directory\"):\n    output = local[\"shell 命令\"]()\n\n# 处理命令的输入和输出\ncmd = local[\"shell 命令\"]\noutput = cmd(\"输入内容\")\nprint(output)\n\n# 获取命令执行的返回码\ncmd = local[\"shell 命令\"]\ncmd.run()  # 执行命令\nreturn_code = cmd.returncode  # 获取返回码\n```\n\n在示例中，我们通过导入`local`对象来执行Shell命令。使用`local`对象，我们可以像调用函数一样来执行Shell命令，并通过`()`传递输入内容。还可以使用`cwd`方法指定执行命令时的工作目录。可以通过`run()`方法执行命令，并使用`returncode`属性获取返回码。\n\n`plumbum`库提供了更加简洁和高级的方式来执行Shell命令。它支持输入输出、文件操作以及远程命令执行等功能，具有更好的可读性和易用性。你可以根据自己的需求使用`plumbum`库来执行Shell命令。\n","slug":"Python执行Shell","published":1,"updated":"2023-09-13T14:45:05.266Z","_id":"clmdhfnfv0000805gf8130vhc","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Python执行Shell\"><a href=\"#Python执行Shell\" class=\"headerlink\" title=\"Python执行Shell\"></a>Python执行Shell</h1><p>在Python中，有多种方法可以执行Shell命令。以下是一些常用的方法。</p>\n<h2 id=\"使用os-system函数\"><a href=\"#使用os-system函数\" class=\"headerlink\" title=\"使用os.system函数\"></a>使用<code>os.system</code>函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br>os.system(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>)<br></code></pre></td></tr></table></figure>\n<p>该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。</p>\n<h2 id=\"使用subprocess-run函数\"><a href=\"#使用subprocess-run函数\" class=\"headerlink\" title=\"使用subprocess.run函数\"></a>使用<code>subprocess.run</code>函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> subprocess<br>subprocess.run(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>, shell=<span class=\"hljs-literal\">True</span>)<br></code></pre></td></tr></table></figure>\n<p>该方法执行命令，并可以通过<code>subprocess.CompletedProcess</code>对象获取命令的返回值、输出和错误信息。</p>\n<h2 id=\"使用subprocess-Popen类\"><a href=\"#使用subprocess-Popen类\" class=\"headerlink\" title=\"使用subprocess.Popen类\"></a>使用<code>subprocess.Popen</code>类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> subprocess<br>process = subprocess.Popen(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>, shell=<span class=\"hljs-literal\">True</span>, stdout=subprocess.PIPE)<br>output, _ = process.communicate()<br><span class=\"hljs-built_in\">print</span>(output.decode())<br></code></pre></td></tr></table></figure>\n<p>该方法也可执行命令，并通过<code>Popen</code>对象控制进程和获取输出。这里使用<code>communicate()</code>方法获取命令的输出。</p>\n<h2 id=\"使用os-popen函数（已过时）\"><a href=\"#使用os-popen函数（已过时）\" class=\"headerlink\" title=\"使用os.popen函数（已过时）\"></a>使用<code>os.popen</code>函数（已过时）</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br>output = os.popen(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>).read()<br><span class=\"hljs-built_in\">print</span>(output)<br></code></pre></td></tr></table></figure>\n<p>该方法执行命令，并返回命令的输出。但由于安全性和可维护性等问题，不推荐使用。</p>\n<h2 id=\"使用os-system函数-1\"><a href=\"#使用os-system函数-1\" class=\"headerlink\" title=\"使用os.system函数\"></a>使用<code>os.system</code>函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br>os.system(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>)<br></code></pre></td></tr></table></figure>\n<p>该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。</p>\n<h2 id=\"使用subprocess-check-output函数\"><a href=\"#使用subprocess-check-output函数\" class=\"headerlink\" title=\"使用subprocess.check_output函数\"></a>使用<code>subprocess.check_output</code>函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> subprocess<br>output = subprocess.check_output(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>, shell=<span class=\"hljs-literal\">True</span>)<br><span class=\"hljs-built_in\">print</span>(output.decode())<br></code></pre></td></tr></table></figure>\n<p>该方法执行命令，并返回命令的输出。但如果命令返回非零状态码，则会引发<code>subprocess.CalledProcessError</code>异常。</p>\n<h2 id=\"使用subprocess-Popen类-1\"><a href=\"#使用subprocess-Popen类-1\" class=\"headerlink\" title=\"使用subprocess.Popen类\"></a>使用<code>subprocess.Popen</code>类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> subprocess<br>process = subprocess.Popen(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>, shell=<span class=\"hljs-literal\">True</span>, stdout=subprocess.PIPE)<br>output, _ = process.communicate()<br><span class=\"hljs-built_in\">print</span>(output.decode())<br></code></pre></td></tr></table></figure>\n<p>该方法也可执行命令，并通过<code>Popen</code>对象控制进程和获取输出。这里使用<code>communicate()</code>方法获取命令的输出。</p>\n<p>当然，还有一些其他的方法可以执行Shell命令。以下是其中几种常见的方法：</p>\n<h2 id=\"使用os-exec-系列函数\"><a href=\"#使用os-exec-系列函数\" class=\"headerlink\" title=\"使用os.exec*系列函数\"></a>使用<code>os.exec*</code>系列函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br>os.<span class=\"hljs-built_in\">exec</span>*(命令)<br></code></pre></td></tr></table></figure>\n<p>这里的<code>*</code>代表不同的函数，例如<code>os.execlp</code>、<code>os.execvp</code>等。这些函数会替换当前进程，并直接执行指定的命令。</p>\n<h2 id=\"使用第三方库\"><a href=\"#使用第三方库\" class=\"headerlink\" title=\"使用第三方库\"></a>使用第三方库</h2><h3 id=\"sh库\"><a href=\"#sh库\" class=\"headerlink\" title=\"sh库\"></a>sh库</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> sh<br><br><span class=\"hljs-comment\"># 执行命令并获取输出</span><br>output = sh.shell命令()<br><span class=\"hljs-built_in\">print</span>(output)<br><br><span class=\"hljs-comment\"># 指定命令路径执行</span><br>output = sh.Command(<span class=\"hljs-string\">&#x27;命令路径&#x27;</span>)()<br><span class=\"hljs-built_in\">print</span>(output)<br><br><span class=\"hljs-comment\"># 处理命令的输入和输出</span><br>command = sh.Command(<span class=\"hljs-string\">&#x27;命令路径&#x27;</span>)<br>output = command(<span class=\"hljs-string\">&#x27;输入内容&#x27;</span>)<br><span class=\"hljs-built_in\">print</span>(output)<br></code></pre></td></tr></table></figure>\n<p>在示例中，我们通过导入<code>sh</code>模块或者使用<code>Command</code>类来执行Shell命令。可以直接调用Shell命令作为函数，并使用<code>()</code>传递输入内容。还可以使用<code>Command</code>类指定命令的路径。</p>\n<p><code>sh</code>库提供了简洁和易用的方式来执行Shell命令，并自动处理了输入和输出。你可以根据具体的需求使用<code>sh</code>库来执行Shell命令。</p>\n<h3 id=\"plumbum库\"><a href=\"#plumbum库\" class=\"headerlink\" title=\"plumbum库\"></a><code>plumbum</code>库</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> plumbum <span class=\"hljs-keyword\">import</span> local<br><br><span class=\"hljs-comment\"># 执行命令并获取输出</span><br>output = local[<span class=\"hljs-string\">&quot;shell 命令&quot;</span>]()<br><span class=\"hljs-built_in\">print</span>(output)<br><br><span class=\"hljs-comment\"># 指定工作目录执行命令</span><br><span class=\"hljs-keyword\">with</span> local.cwd(<span class=\"hljs-string\">&quot;/path/to/directory&quot;</span>):<br>    output = local[<span class=\"hljs-string\">&quot;shell 命令&quot;</span>]()<br><br><span class=\"hljs-comment\"># 处理命令的输入和输出</span><br>cmd = local[<span class=\"hljs-string\">&quot;shell 命令&quot;</span>]<br>output = cmd(<span class=\"hljs-string\">&quot;输入内容&quot;</span>)<br><span class=\"hljs-built_in\">print</span>(output)<br><br><span class=\"hljs-comment\"># 获取命令执行的返回码</span><br>cmd = local[<span class=\"hljs-string\">&quot;shell 命令&quot;</span>]<br>cmd.run()  <span class=\"hljs-comment\"># 执行命令</span><br>return_code = cmd.returncode  <span class=\"hljs-comment\"># 获取返回码</span><br></code></pre></td></tr></table></figure>\n\n<p>在示例中，我们通过导入<code>local</code>对象来执行Shell命令。使用<code>local</code>对象，我们可以像调用函数一样来执行Shell命令，并通过<code>()</code>传递输入内容。还可以使用<code>cwd</code>方法指定执行命令时的工作目录。可以通过<code>run()</code>方法执行命令，并使用<code>returncode</code>属性获取返回码。</p>\n<p><code>plumbum</code>库提供了更加简洁和高级的方式来执行Shell命令。它支持输入输出、文件操作以及远程命令执行等功能，具有更好的可读性和易用性。你可以根据自己的需求使用<code>plumbum</code>库来执行Shell命令。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python执行Shell\"><a href=\"#Python执行Shell\" class=\"headerlink\" title=\"Python执行Shell\"></a>Python执行Shell</h1><p>在Python中，有多种方法可以执行Shell命令。以下是一些常用的方法。</p>\n<h2 id=\"使用os-system函数\"><a href=\"#使用os-system函数\" class=\"headerlink\" title=\"使用os.system函数\"></a>使用<code>os.system</code>函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br>os.system(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>)<br></code></pre></td></tr></table></figure>\n<p>该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。</p>\n<h2 id=\"使用subprocess-run函数\"><a href=\"#使用subprocess-run函数\" class=\"headerlink\" title=\"使用subprocess.run函数\"></a>使用<code>subprocess.run</code>函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> subprocess<br>subprocess.run(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>, shell=<span class=\"hljs-literal\">True</span>)<br></code></pre></td></tr></table></figure>\n<p>该方法执行命令，并可以通过<code>subprocess.CompletedProcess</code>对象获取命令的返回值、输出和错误信息。</p>\n<h2 id=\"使用subprocess-Popen类\"><a href=\"#使用subprocess-Popen类\" class=\"headerlink\" title=\"使用subprocess.Popen类\"></a>使用<code>subprocess.Popen</code>类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> subprocess<br>process = subprocess.Popen(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>, shell=<span class=\"hljs-literal\">True</span>, stdout=subprocess.PIPE)<br>output, _ = process.communicate()<br><span class=\"hljs-built_in\">print</span>(output.decode())<br></code></pre></td></tr></table></figure>\n<p>该方法也可执行命令，并通过<code>Popen</code>对象控制进程和获取输出。这里使用<code>communicate()</code>方法获取命令的输出。</p>\n<h2 id=\"使用os-popen函数（已过时）\"><a href=\"#使用os-popen函数（已过时）\" class=\"headerlink\" title=\"使用os.popen函数（已过时）\"></a>使用<code>os.popen</code>函数（已过时）</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br>output = os.popen(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>).read()<br><span class=\"hljs-built_in\">print</span>(output)<br></code></pre></td></tr></table></figure>\n<p>该方法执行命令，并返回命令的输出。但由于安全性和可维护性等问题，不推荐使用。</p>\n<h2 id=\"使用os-system函数-1\"><a href=\"#使用os-system函数-1\" class=\"headerlink\" title=\"使用os.system函数\"></a>使用<code>os.system</code>函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br>os.system(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>)<br></code></pre></td></tr></table></figure>\n<p>该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。</p>\n<h2 id=\"使用subprocess-check-output函数\"><a href=\"#使用subprocess-check-output函数\" class=\"headerlink\" title=\"使用subprocess.check_output函数\"></a>使用<code>subprocess.check_output</code>函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> subprocess<br>output = subprocess.check_output(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>, shell=<span class=\"hljs-literal\">True</span>)<br><span class=\"hljs-built_in\">print</span>(output.decode())<br></code></pre></td></tr></table></figure>\n<p>该方法执行命令，并返回命令的输出。但如果命令返回非零状态码，则会引发<code>subprocess.CalledProcessError</code>异常。</p>\n<h2 id=\"使用subprocess-Popen类-1\"><a href=\"#使用subprocess-Popen类-1\" class=\"headerlink\" title=\"使用subprocess.Popen类\"></a>使用<code>subprocess.Popen</code>类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> subprocess<br>process = subprocess.Popen(<span class=\"hljs-string\">&quot;shell 命令&quot;</span>, shell=<span class=\"hljs-literal\">True</span>, stdout=subprocess.PIPE)<br>output, _ = process.communicate()<br><span class=\"hljs-built_in\">print</span>(output.decode())<br></code></pre></td></tr></table></figure>\n<p>该方法也可执行命令，并通过<code>Popen</code>对象控制进程和获取输出。这里使用<code>communicate()</code>方法获取命令的输出。</p>\n<p>当然，还有一些其他的方法可以执行Shell命令。以下是其中几种常见的方法：</p>\n<h2 id=\"使用os-exec-系列函数\"><a href=\"#使用os-exec-系列函数\" class=\"headerlink\" title=\"使用os.exec*系列函数\"></a>使用<code>os.exec*</code>系列函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br>os.<span class=\"hljs-built_in\">exec</span>*(命令)<br></code></pre></td></tr></table></figure>\n<p>这里的<code>*</code>代表不同的函数，例如<code>os.execlp</code>、<code>os.execvp</code>等。这些函数会替换当前进程，并直接执行指定的命令。</p>\n<h2 id=\"使用第三方库\"><a href=\"#使用第三方库\" class=\"headerlink\" title=\"使用第三方库\"></a>使用第三方库</h2><h3 id=\"sh库\"><a href=\"#sh库\" class=\"headerlink\" title=\"sh库\"></a>sh库</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> sh<br><br><span class=\"hljs-comment\"># 执行命令并获取输出</span><br>output = sh.shell命令()<br><span class=\"hljs-built_in\">print</span>(output)<br><br><span class=\"hljs-comment\"># 指定命令路径执行</span><br>output = sh.Command(<span class=\"hljs-string\">&#x27;命令路径&#x27;</span>)()<br><span class=\"hljs-built_in\">print</span>(output)<br><br><span class=\"hljs-comment\"># 处理命令的输入和输出</span><br>command = sh.Command(<span class=\"hljs-string\">&#x27;命令路径&#x27;</span>)<br>output = command(<span class=\"hljs-string\">&#x27;输入内容&#x27;</span>)<br><span class=\"hljs-built_in\">print</span>(output)<br></code></pre></td></tr></table></figure>\n<p>在示例中，我们通过导入<code>sh</code>模块或者使用<code>Command</code>类来执行Shell命令。可以直接调用Shell命令作为函数，并使用<code>()</code>传递输入内容。还可以使用<code>Command</code>类指定命令的路径。</p>\n<p><code>sh</code>库提供了简洁和易用的方式来执行Shell命令，并自动处理了输入和输出。你可以根据具体的需求使用<code>sh</code>库来执行Shell命令。</p>\n<h3 id=\"plumbum库\"><a href=\"#plumbum库\" class=\"headerlink\" title=\"plumbum库\"></a><code>plumbum</code>库</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> plumbum <span class=\"hljs-keyword\">import</span> local<br><br><span class=\"hljs-comment\"># 执行命令并获取输出</span><br>output = local[<span class=\"hljs-string\">&quot;shell 命令&quot;</span>]()<br><span class=\"hljs-built_in\">print</span>(output)<br><br><span class=\"hljs-comment\"># 指定工作目录执行命令</span><br><span class=\"hljs-keyword\">with</span> local.cwd(<span class=\"hljs-string\">&quot;/path/to/directory&quot;</span>):<br>    output = local[<span class=\"hljs-string\">&quot;shell 命令&quot;</span>]()<br><br><span class=\"hljs-comment\"># 处理命令的输入和输出</span><br>cmd = local[<span class=\"hljs-string\">&quot;shell 命令&quot;</span>]<br>output = cmd(<span class=\"hljs-string\">&quot;输入内容&quot;</span>)<br><span class=\"hljs-built_in\">print</span>(output)<br><br><span class=\"hljs-comment\"># 获取命令执行的返回码</span><br>cmd = local[<span class=\"hljs-string\">&quot;shell 命令&quot;</span>]<br>cmd.run()  <span class=\"hljs-comment\"># 执行命令</span><br>return_code = cmd.returncode  <span class=\"hljs-comment\"># 获取返回码</span><br></code></pre></td></tr></table></figure>\n\n<p>在示例中，我们通过导入<code>local</code>对象来执行Shell命令。使用<code>local</code>对象，我们可以像调用函数一样来执行Shell命令，并通过<code>()</code>传递输入内容。还可以使用<code>cwd</code>方法指定执行命令时的工作目录。可以通过<code>run()</code>方法执行命令，并使用<code>returncode</code>属性获取返回码。</p>\n<p><code>plumbum</code>库提供了更加简洁和高级的方式来执行Shell命令。它支持输入输出、文件操作以及远程命令执行等功能，具有更好的可读性和易用性。你可以根据自己的需求使用<code>plumbum</code>库来执行Shell命令。</p>\n"},{"title":"F#执行Shell","date":"2023-09-10T13:33:59.000Z","author":"Grey-Wind","_content":"\n# F#执行Shell\n\n在F#中，可以使用`System.Diagnostics.Process`命名空间来执行Shell命令。以下是几种执行Shell命令的方式。\n\n## 使用`System.Diagnostics.Process.Start`方法\n\n```fsharp\nopen System.Diagnostics\n\nlet executeCommand (command: string) =\n    let processStartInfo = new ProcessStartInfo(\"cmd.exe\", sprintf \"/C %s\" command)\n    processStartInfo.RedirectStandardOutput <- true\n    processStartInfo.UseShellExecute <- false\n    processStartInfo.CreateNoWindow <- true\n\n    let process = Process.Start(processStartInfo)\n    let output = process.StandardOutput.ReadToEnd()\n\n    process.WaitForExit()\n    output\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n\n## 使用`System.Diagnostics.Process.Start`方法\n\n获取标准输出和错误输出。\n\n```fsharp\nopen System.Diagnostics\n\nlet executeCommand (command: string) =\n    let processStartInfo = new ProcessStartInfo(\"cmd.exe\", sprintf \"/C %s\" command)\n    processStartInfo.RedirectStandardOutput <- true\n    processStartInfo.RedirectStandardError <- true\n    processStartInfo.UseShellExecute <- false\n    processStartInfo.CreateNoWindow <- true\n\n    let process = Process.Start(processStartInfo)\n    let output = process.StandardOutput.ReadToEnd()\n    let error = process.StandardError.ReadToEnd()\n\n    process.WaitForExit()\n    (output, error)\n\nlet (output, error) = executeCommand \"dir\"\nprintfn \"Output:\\n%s\" output\nprintfn \"Error:\\n%s\" error\n```\n\n## 使用`System.Diagnostics.Process`类\n\n直接执行命令并获取输出。\n\n```fsharp\nopen System.Diagnostics\n\nlet executeCommand (command: string) =\n    let process = new Process()\n    process.StartInfo.FileName <- \"cmd.exe\"\n    process.StartInfo.Arguments <- sprintf \"/C %s\" command\n    process.StartInfo.UseShellExecute <- false\n    process.StartInfo.RedirectStandardOutput <- true\n\n    process.Start()\n    let output = process.StandardOutput.ReadToEnd()\n    process.WaitForExit()\n    output\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n\n## 使用`FSharp.SystemCommand`库\n\n```fsharp\nopen FSharp.SystemCommand\n\nlet executeCommand (command: string) =\n    Command.create command\n    |> Command.run\n    |> Command.output\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n请确保已将`FSharp.SystemCommand`库添加到项目引用中。\n\n## 使用`Suave.Process`库\n\n```fsharp\nopen Suave.Process\n\nlet executeCommand (command: string) =\n    command\n    |> Shell.exec\n    |> Shell.stdout\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n请确保已将`Suave.Process`库添加到项目引用中。\n\n## 使用外部命令包装器\n\n### Fake\n\n```fsharp\nopen Fake\n\nTarget \"ExecuteCommand\" (fun _ ->\n    let result = Shell.ExecRead \"dir\" |> String.concat \"\\n\"\n    printfn \"%s\" result\n)\n\nRunTargetOrDefault \"ExecuteCommand\"\n```\n### Paket.CommandRunners\n\n在F#脚本中引入`Paket.CommandRunners`命名空间，并使用相关函数来执行Shell命令。\n\n```fsharp\nopen System\nopen System.IO\nopen Paket.CommandRunners\n\nlet executeCommand (command: string) =\n    let runner = CommandRunners.createProcessRunner()\n    let output, exitCode = runner.RunCommand(command, \"\")\n  \n    match exitCode with\n    | 0 -> output\n    | _ -> sprintf \"Command failed with exit code %d:\\n%s\" exitCode output\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n\n在上述示例中，我们创建了一个`CommandRunners.createProcessRunner()`来创建一个进程托管器。然后使用`RunCommand`方法执行Shell命令，并获取输出和退出码。\n\n请注意，`Paket.CommandRunners`会自动下载所需的依赖项，并将其复制到正确的位置。\n\n这是使用`Paket.CommandRunners`在F#中执行Shell命令的方式。你可以根据实际需求进行调整，并使用适当的参数和选项来定制命令执行过程。\n","source":"_posts/F-Sharp执行Shell.md","raw":"---\ntitle: F#执行Shell\ndate: 2023-09-10 21:33:59\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# F#执行Shell\n\n在F#中，可以使用`System.Diagnostics.Process`命名空间来执行Shell命令。以下是几种执行Shell命令的方式。\n\n## 使用`System.Diagnostics.Process.Start`方法\n\n```fsharp\nopen System.Diagnostics\n\nlet executeCommand (command: string) =\n    let processStartInfo = new ProcessStartInfo(\"cmd.exe\", sprintf \"/C %s\" command)\n    processStartInfo.RedirectStandardOutput <- true\n    processStartInfo.UseShellExecute <- false\n    processStartInfo.CreateNoWindow <- true\n\n    let process = Process.Start(processStartInfo)\n    let output = process.StandardOutput.ReadToEnd()\n\n    process.WaitForExit()\n    output\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n\n## 使用`System.Diagnostics.Process.Start`方法\n\n获取标准输出和错误输出。\n\n```fsharp\nopen System.Diagnostics\n\nlet executeCommand (command: string) =\n    let processStartInfo = new ProcessStartInfo(\"cmd.exe\", sprintf \"/C %s\" command)\n    processStartInfo.RedirectStandardOutput <- true\n    processStartInfo.RedirectStandardError <- true\n    processStartInfo.UseShellExecute <- false\n    processStartInfo.CreateNoWindow <- true\n\n    let process = Process.Start(processStartInfo)\n    let output = process.StandardOutput.ReadToEnd()\n    let error = process.StandardError.ReadToEnd()\n\n    process.WaitForExit()\n    (output, error)\n\nlet (output, error) = executeCommand \"dir\"\nprintfn \"Output:\\n%s\" output\nprintfn \"Error:\\n%s\" error\n```\n\n## 使用`System.Diagnostics.Process`类\n\n直接执行命令并获取输出。\n\n```fsharp\nopen System.Diagnostics\n\nlet executeCommand (command: string) =\n    let process = new Process()\n    process.StartInfo.FileName <- \"cmd.exe\"\n    process.StartInfo.Arguments <- sprintf \"/C %s\" command\n    process.StartInfo.UseShellExecute <- false\n    process.StartInfo.RedirectStandardOutput <- true\n\n    process.Start()\n    let output = process.StandardOutput.ReadToEnd()\n    process.WaitForExit()\n    output\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n\n## 使用`FSharp.SystemCommand`库\n\n```fsharp\nopen FSharp.SystemCommand\n\nlet executeCommand (command: string) =\n    Command.create command\n    |> Command.run\n    |> Command.output\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n请确保已将`FSharp.SystemCommand`库添加到项目引用中。\n\n## 使用`Suave.Process`库\n\n```fsharp\nopen Suave.Process\n\nlet executeCommand (command: string) =\n    command\n    |> Shell.exec\n    |> Shell.stdout\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n请确保已将`Suave.Process`库添加到项目引用中。\n\n## 使用外部命令包装器\n\n### Fake\n\n```fsharp\nopen Fake\n\nTarget \"ExecuteCommand\" (fun _ ->\n    let result = Shell.ExecRead \"dir\" |> String.concat \"\\n\"\n    printfn \"%s\" result\n)\n\nRunTargetOrDefault \"ExecuteCommand\"\n```\n### Paket.CommandRunners\n\n在F#脚本中引入`Paket.CommandRunners`命名空间，并使用相关函数来执行Shell命令。\n\n```fsharp\nopen System\nopen System.IO\nopen Paket.CommandRunners\n\nlet executeCommand (command: string) =\n    let runner = CommandRunners.createProcessRunner()\n    let output, exitCode = runner.RunCommand(command, \"\")\n  \n    match exitCode with\n    | 0 -> output\n    | _ -> sprintf \"Command failed with exit code %d:\\n%s\" exitCode output\n\nlet result = executeCommand \"dir\"\nprintfn \"%s\" result\n```\n\n在上述示例中，我们创建了一个`CommandRunners.createProcessRunner()`来创建一个进程托管器。然后使用`RunCommand`方法执行Shell命令，并获取输出和退出码。\n\n请注意，`Paket.CommandRunners`会自动下载所需的依赖项，并将其复制到正确的位置。\n\n这是使用`Paket.CommandRunners`在F#中执行Shell命令的方式。你可以根据实际需求进行调整，并使用适当的参数和选项来定制命令执行过程。\n","slug":"F-Sharp执行Shell","published":1,"updated":"2023-09-13T14:44:50.096Z","_id":"clmdi4bxv0000x45g8jdm3rgf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"F-执行Shell\"><a href=\"#F-执行Shell\" class=\"headerlink\" title=\"F#执行Shell\"></a>F#执行Shell</h1><p>在F#中，可以使用<code>System.Diagnostics.Process</code>命名空间来执行Shell命令。以下是几种执行Shell命令的方式。</p>\n<h2 id=\"使用System-Diagnostics-Process-Start方法\"><a href=\"#使用System-Diagnostics-Process-Start方法\" class=\"headerlink\" title=\"使用System.Diagnostics.Process.Start方法\"></a>使用<code>System.Diagnostics.Process.Start</code>方法</h2><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> System.Diagnostics<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    <span class=\"hljs-keyword\">let</span> processStartInfo <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> ProcessStartInfo(<span class=\"hljs-string\">&quot;cmd.exe&quot;</span>, <span class=\"hljs-built_in\">sprintf</span> <span class=\"hljs-string\">&quot;/C %s&quot;</span> command)<br>    processStartInfo.RedirectStandardOutput <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br>    processStartInfo.UseShellExecute <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">false</span><br>    processStartInfo.CreateNoWindow <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-keyword\">let</span> process <span class=\"hljs-operator\">=</span> Process.Start(processStartInfo)<br>    <span class=\"hljs-keyword\">let</span> output <span class=\"hljs-operator\">=</span> process.StandardOutput.ReadToEnd()<br><br>    process.WaitForExit()<br>    output<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Diagnostics-Process-Start方法-1\"><a href=\"#使用System-Diagnostics-Process-Start方法-1\" class=\"headerlink\" title=\"使用System.Diagnostics.Process.Start方法\"></a>使用<code>System.Diagnostics.Process.Start</code>方法</h2><p>获取标准输出和错误输出。</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> System.Diagnostics<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    <span class=\"hljs-keyword\">let</span> processStartInfo <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> ProcessStartInfo(<span class=\"hljs-string\">&quot;cmd.exe&quot;</span>, <span class=\"hljs-built_in\">sprintf</span> <span class=\"hljs-string\">&quot;/C %s&quot;</span> command)<br>    processStartInfo.RedirectStandardOutput <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br>    processStartInfo.RedirectStandardError <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br>    processStartInfo.UseShellExecute <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">false</span><br>    processStartInfo.CreateNoWindow <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-keyword\">let</span> process <span class=\"hljs-operator\">=</span> Process.Start(processStartInfo)<br>    <span class=\"hljs-keyword\">let</span> output <span class=\"hljs-operator\">=</span> process.StandardOutput.ReadToEnd()<br>    <span class=\"hljs-keyword\">let</span> error <span class=\"hljs-operator\">=</span> process.StandardError.ReadToEnd()<br><br>    process.WaitForExit()<br>    (output, error)<br><br><span class=\"hljs-keyword\">let</span> (output, error) <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;Output:\\n%s&quot;</span> output<br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;Error:\\n%s&quot;</span> error<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Diagnostics-Process类\"><a href=\"#使用System-Diagnostics-Process类\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类\"></a>使用<code>System.Diagnostics.Process</code>类</h2><p>直接执行命令并获取输出。</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> System.Diagnostics<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    <span class=\"hljs-keyword\">let</span> process <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> Process()<br>    process.StartInfo.FileName <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-string\">&quot;cmd.exe&quot;</span><br>    process.StartInfo.Arguments <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-built_in\">sprintf</span> <span class=\"hljs-string\">&quot;/C %s&quot;</span> command<br>    process.StartInfo.UseShellExecute <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">false</span><br>    process.StartInfo.RedirectStandardOutput <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br><br>    process.Start()<br>    <span class=\"hljs-keyword\">let</span> output <span class=\"hljs-operator\">=</span> process.StandardOutput.ReadToEnd()<br>    process.WaitForExit()<br>    output<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用FSharp-SystemCommand库\"><a href=\"#使用FSharp-SystemCommand库\" class=\"headerlink\" title=\"使用FSharp.SystemCommand库\"></a>使用<code>FSharp.SystemCommand</code>库</h2><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> FSharp.SystemCommand<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    Command.create command<br>    <span class=\"hljs-operator\">|&gt;</span> Command.run<br>    <span class=\"hljs-operator\">|&gt;</span> Command.output<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n<p>请确保已将<code>FSharp.SystemCommand</code>库添加到项目引用中。</p>\n<h2 id=\"使用Suave-Process库\"><a href=\"#使用Suave-Process库\" class=\"headerlink\" title=\"使用Suave.Process库\"></a>使用<code>Suave.Process</code>库</h2><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> Suave.Process<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    command<br>    <span class=\"hljs-operator\">|&gt;</span> Shell.exec<br>    <span class=\"hljs-operator\">|&gt;</span> Shell.stdout<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n<p>请确保已将<code>Suave.Process</code>库添加到项目引用中。</p>\n<h2 id=\"使用外部命令包装器\"><a href=\"#使用外部命令包装器\" class=\"headerlink\" title=\"使用外部命令包装器\"></a>使用外部命令包装器</h2><h3 id=\"Fake\"><a href=\"#Fake\" class=\"headerlink\" title=\"Fake\"></a>Fake</h3><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> Fake<br><br>Target <span class=\"hljs-string\">&quot;ExecuteCommand&quot;</span> (<span class=\"hljs-keyword\">fun</span> _ <span class=\"hljs-operator\">-&gt;</span><br>    <span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> Shell.ExecRead <span class=\"hljs-string\">&quot;dir&quot;</span> <span class=\"hljs-operator\">|&gt;</span> String.concat <span class=\"hljs-string\">&quot;\\n&quot;</span><br>    <span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br>)<br><br>RunTargetOrDefault <span class=\"hljs-string\">&quot;ExecuteCommand&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Paket-CommandRunners\"><a href=\"#Paket-CommandRunners\" class=\"headerlink\" title=\"Paket.CommandRunners\"></a>Paket.CommandRunners</h3><p>在F#脚本中引入<code>Paket.CommandRunners</code>命名空间，并使用相关函数来执行Shell命令。</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> System<br><span class=\"hljs-keyword\">open</span> System.IO<br><span class=\"hljs-keyword\">open</span> Paket.CommandRunners<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    <span class=\"hljs-keyword\">let</span> runner <span class=\"hljs-operator\">=</span> CommandRunners.createProcessRunner()<br>    <span class=\"hljs-keyword\">let</span> output, exitCode <span class=\"hljs-operator\">=</span> runner.RunCommand(command, <span class=\"hljs-string\">&quot;&quot;</span>)<br>  <br>    <span class=\"hljs-keyword\">match</span> exitCode <span class=\"hljs-keyword\">with</span><br>    <span class=\"hljs-operator\">|</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-operator\">-&gt;</span> output<br>    <span class=\"hljs-operator\">|</span> _ <span class=\"hljs-operator\">-&gt;</span> <span class=\"hljs-built_in\">sprintf</span> <span class=\"hljs-string\">&quot;Command failed with exit code %d:\\n%s&quot;</span> exitCode output<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们创建了一个<code>CommandRunners.createProcessRunner()</code>来创建一个进程托管器。然后使用<code>RunCommand</code>方法执行Shell命令，并获取输出和退出码。</p>\n<p>请注意，<code>Paket.CommandRunners</code>会自动下载所需的依赖项，并将其复制到正确的位置。</p>\n<p>这是使用<code>Paket.CommandRunners</code>在F#中执行Shell命令的方式。你可以根据实际需求进行调整，并使用适当的参数和选项来定制命令执行过程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"F-执行Shell\"><a href=\"#F-执行Shell\" class=\"headerlink\" title=\"F#执行Shell\"></a>F#执行Shell</h1><p>在F#中，可以使用<code>System.Diagnostics.Process</code>命名空间来执行Shell命令。以下是几种执行Shell命令的方式。</p>\n<h2 id=\"使用System-Diagnostics-Process-Start方法\"><a href=\"#使用System-Diagnostics-Process-Start方法\" class=\"headerlink\" title=\"使用System.Diagnostics.Process.Start方法\"></a>使用<code>System.Diagnostics.Process.Start</code>方法</h2><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> System.Diagnostics<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    <span class=\"hljs-keyword\">let</span> processStartInfo <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> ProcessStartInfo(<span class=\"hljs-string\">&quot;cmd.exe&quot;</span>, <span class=\"hljs-built_in\">sprintf</span> <span class=\"hljs-string\">&quot;/C %s&quot;</span> command)<br>    processStartInfo.RedirectStandardOutput <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br>    processStartInfo.UseShellExecute <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">false</span><br>    processStartInfo.CreateNoWindow <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-keyword\">let</span> process <span class=\"hljs-operator\">=</span> Process.Start(processStartInfo)<br>    <span class=\"hljs-keyword\">let</span> output <span class=\"hljs-operator\">=</span> process.StandardOutput.ReadToEnd()<br><br>    process.WaitForExit()<br>    output<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Diagnostics-Process-Start方法-1\"><a href=\"#使用System-Diagnostics-Process-Start方法-1\" class=\"headerlink\" title=\"使用System.Diagnostics.Process.Start方法\"></a>使用<code>System.Diagnostics.Process.Start</code>方法</h2><p>获取标准输出和错误输出。</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> System.Diagnostics<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    <span class=\"hljs-keyword\">let</span> processStartInfo <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> ProcessStartInfo(<span class=\"hljs-string\">&quot;cmd.exe&quot;</span>, <span class=\"hljs-built_in\">sprintf</span> <span class=\"hljs-string\">&quot;/C %s&quot;</span> command)<br>    processStartInfo.RedirectStandardOutput <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br>    processStartInfo.RedirectStandardError <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br>    processStartInfo.UseShellExecute <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">false</span><br>    processStartInfo.CreateNoWindow <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-keyword\">let</span> process <span class=\"hljs-operator\">=</span> Process.Start(processStartInfo)<br>    <span class=\"hljs-keyword\">let</span> output <span class=\"hljs-operator\">=</span> process.StandardOutput.ReadToEnd()<br>    <span class=\"hljs-keyword\">let</span> error <span class=\"hljs-operator\">=</span> process.StandardError.ReadToEnd()<br><br>    process.WaitForExit()<br>    (output, error)<br><br><span class=\"hljs-keyword\">let</span> (output, error) <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;Output:\\n%s&quot;</span> output<br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;Error:\\n%s&quot;</span> error<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用System-Diagnostics-Process类\"><a href=\"#使用System-Diagnostics-Process类\" class=\"headerlink\" title=\"使用System.Diagnostics.Process类\"></a>使用<code>System.Diagnostics.Process</code>类</h2><p>直接执行命令并获取输出。</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> System.Diagnostics<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    <span class=\"hljs-keyword\">let</span> process <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> Process()<br>    process.StartInfo.FileName <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-string\">&quot;cmd.exe&quot;</span><br>    process.StartInfo.Arguments <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-built_in\">sprintf</span> <span class=\"hljs-string\">&quot;/C %s&quot;</span> command<br>    process.StartInfo.UseShellExecute <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">false</span><br>    process.StartInfo.RedirectStandardOutput <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span><br><br>    process.Start()<br>    <span class=\"hljs-keyword\">let</span> output <span class=\"hljs-operator\">=</span> process.StandardOutput.ReadToEnd()<br>    process.WaitForExit()<br>    output<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用FSharp-SystemCommand库\"><a href=\"#使用FSharp-SystemCommand库\" class=\"headerlink\" title=\"使用FSharp.SystemCommand库\"></a>使用<code>FSharp.SystemCommand</code>库</h2><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> FSharp.SystemCommand<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    Command.create command<br>    <span class=\"hljs-operator\">|&gt;</span> Command.run<br>    <span class=\"hljs-operator\">|&gt;</span> Command.output<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n<p>请确保已将<code>FSharp.SystemCommand</code>库添加到项目引用中。</p>\n<h2 id=\"使用Suave-Process库\"><a href=\"#使用Suave-Process库\" class=\"headerlink\" title=\"使用Suave.Process库\"></a>使用<code>Suave.Process</code>库</h2><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> Suave.Process<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    command<br>    <span class=\"hljs-operator\">|&gt;</span> Shell.exec<br>    <span class=\"hljs-operator\">|&gt;</span> Shell.stdout<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n<p>请确保已将<code>Suave.Process</code>库添加到项目引用中。</p>\n<h2 id=\"使用外部命令包装器\"><a href=\"#使用外部命令包装器\" class=\"headerlink\" title=\"使用外部命令包装器\"></a>使用外部命令包装器</h2><h3 id=\"Fake\"><a href=\"#Fake\" class=\"headerlink\" title=\"Fake\"></a>Fake</h3><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> Fake<br><br>Target <span class=\"hljs-string\">&quot;ExecuteCommand&quot;</span> (<span class=\"hljs-keyword\">fun</span> _ <span class=\"hljs-operator\">-&gt;</span><br>    <span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> Shell.ExecRead <span class=\"hljs-string\">&quot;dir&quot;</span> <span class=\"hljs-operator\">|&gt;</span> String.concat <span class=\"hljs-string\">&quot;\\n&quot;</span><br>    <span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br>)<br><br>RunTargetOrDefault <span class=\"hljs-string\">&quot;ExecuteCommand&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Paket-CommandRunners\"><a href=\"#Paket-CommandRunners\" class=\"headerlink\" title=\"Paket.CommandRunners\"></a>Paket.CommandRunners</h3><p>在F#脚本中引入<code>Paket.CommandRunners</code>命名空间，并使用相关函数来执行Shell命令。</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-keyword\">open</span> System<br><span class=\"hljs-keyword\">open</span> System.IO<br><span class=\"hljs-keyword\">open</span> Paket.CommandRunners<br><br><span class=\"hljs-keyword\">let</span> executeCommand (command<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>) <span class=\"hljs-operator\">=</span><br>    <span class=\"hljs-keyword\">let</span> runner <span class=\"hljs-operator\">=</span> CommandRunners.createProcessRunner()<br>    <span class=\"hljs-keyword\">let</span> output, exitCode <span class=\"hljs-operator\">=</span> runner.RunCommand(command, <span class=\"hljs-string\">&quot;&quot;</span>)<br>  <br>    <span class=\"hljs-keyword\">match</span> exitCode <span class=\"hljs-keyword\">with</span><br>    <span class=\"hljs-operator\">|</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-operator\">-&gt;</span> output<br>    <span class=\"hljs-operator\">|</span> _ <span class=\"hljs-operator\">-&gt;</span> <span class=\"hljs-built_in\">sprintf</span> <span class=\"hljs-string\">&quot;Command failed with exit code %d:\\n%s&quot;</span> exitCode output<br><br><span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> executeCommand <span class=\"hljs-string\">&quot;dir&quot;</span><br><span class=\"hljs-built_in\">printfn</span> <span class=\"hljs-string\">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们创建了一个<code>CommandRunners.createProcessRunner()</code>来创建一个进程托管器。然后使用<code>RunCommand</code>方法执行Shell命令，并获取输出和退出码。</p>\n<p>请注意，<code>Paket.CommandRunners</code>会自动下载所需的依赖项，并将其复制到正确的位置。</p>\n<p>这是使用<code>Paket.CommandRunners</code>在F#中执行Shell命令的方式。你可以根据实际需求进行调整，并使用适当的参数和选项来定制命令执行过程。</p>\n"},{"title":"Typescript执行Shell","date":"2023-09-10T13:50:12.000Z","author":"Grey-Wind","_content":"\n# Typescript执行Shell\n\n## `exec()`\n\n异步执行 Shell 命令，且不会保留子进程的输出结果。\n\n```typescript\nimport { exec } from 'child_process';\n\nexec('ls', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`执行命令出错: ${error.message}`);\n    return;\n  }\n  console.log(`输出内容: ${stdout}`);\n});\n```\n\n## `execSync()`\n\n同步执行 Shell 命令，并返回输出结果。\n\n```typescript\nimport { execSync } from 'child_process';\n\ntry {\n  const output = execSync('ls');\n  console.log(`输出内容: ${output.toString()}`);\n} catch (error) {\n  console.error(`执行命令出错: ${error.message}`);\n}\n```\n\n## `spawn()`\n\n异步执行 Shell 命令，并可以保留进程的输出结果。\n\n```typescript\nimport { spawn } from 'child_process';\n\nconst ls = spawn('ls');\n\nls.stdout.on('data', (data) => {\n  console.log(`输出内容: ${data}`);\n});\n\nls.stderr.on('data', (data) => {\n  console.error(`错误输出: ${data}`);\n});\n\nls.on('close', (code) => {\n  console.log(`进程退出码: ${code}`);\n});\n```\n\n## `spawnSync()`\n\n同步执行 Shell 命令，并返回输出结果。\n\n```typescript\nimport { spawnSync } from 'child_process';\n\nconst ls = spawnSync('ls');\nif (ls.error) {\n  console.error(`执行命令出错: ${ls.error.message}`);\n} else {\n  console.log(`输出内容: ${ls.output.toString()}`);\n}\n```\n\n## `execFile()`\n\n异步执行可执行文件，可以传入命令行参数。\n\n```typescript\nimport { execFile } from 'child_process';\n\nconst command = 'cd';\nconst args = ['/d', 'desktop'];\n\nexecFile(command, args, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`执行命令出错: ${error.message}`);\n    return;\n  }\n  console.log(`输出内容: ${stdout}`);\n});\n```\n\n## `execFileSync()`\n\n同步执行可执行文件，可以传入命令行参数。\n\n```typescript\nimport { execFileSync } from 'child_process';\n\nconst command = 'cd';\nconst args = ['/d', 'desktop'];\n\ntry {\n  const output = execFileSync(command, args);\n  console.log(`输出内容: ${output.toString()}`);\n} catch (error) {\n  console.error(`执行命令出错: ${error.message}`);\n}\n```\n\n## `execShellCommand()`\n\n自定义一个异步执行 Shell 命令的封装函数。\n\n```typescript\nimport { exec } from 'child_process';\n\nfunction execShellCommand(command: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    exec(command, (error, stdout, stderr) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n      resolve(stdout.trim());\n    });\n  });\n}\n\n// 使用示例\nasync function main() {\n  try {\n    const output = await execShellCommand('ls');\n    console.log(`输出内容: ${output}`);\n  } catch (error) {\n    console.error(`执行命令出错: ${error.message}`);\n  }\n}\n\nmain();\n```\n\n这个方法将 `exec` 包装在一个 Promise 中，使其可以轻松地使用 `await` 进行异步操作。\n\n## `spawnShellCommand()`\n\n自定义一个异步执行 Shell 命令的封装函数，支持参数和流式数据处理。\n\n```typescript\nimport { spawn } from 'child_process';\n\nfunction spawnShellCommand(command: string, args: string[]): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const child = spawn(command, args);\n\n    let output = '';\n\n    child.stdout.on('data', (data) => {\n      output += data.toString();\n    });\n\n    child.stderr.on('data', (data) => {\n      console.error(data.toString());\n    });\n\n    child.on('error', (error) => {\n      reject(error);\n    });\n\n    child.on('close', (code) => {\n      if (code !== 0) {\n        reject(new Error(`命令执行失败，退出码: ${code}`));\n        return;\n      }\n      resolve(output.trim());\n    });\n  });\n}\n\n// 使用示例\nasync function main() {\n  try {\n    const output = await spawnShellCommand('ls', ['-lh']);\n    console.log(`输出内容: ${output}`);\n  } catch (error) {\n    console.error(`执行命令出错: ${error.message}`);\n  }\n}\n\nmain();\n```\n\n这个方法使用 `spawn` 创建子进程，并处理标准输出和标准错误流，最后返回整个输出结果。\n","source":"_posts/Typescript执行Shell.md","raw":"---\ntitle: Typescript执行Shell\ndate: 2023-09-10 21:50:12\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Typescript执行Shell\n\n## `exec()`\n\n异步执行 Shell 命令，且不会保留子进程的输出结果。\n\n```typescript\nimport { exec } from 'child_process';\n\nexec('ls', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`执行命令出错: ${error.message}`);\n    return;\n  }\n  console.log(`输出内容: ${stdout}`);\n});\n```\n\n## `execSync()`\n\n同步执行 Shell 命令，并返回输出结果。\n\n```typescript\nimport { execSync } from 'child_process';\n\ntry {\n  const output = execSync('ls');\n  console.log(`输出内容: ${output.toString()}`);\n} catch (error) {\n  console.error(`执行命令出错: ${error.message}`);\n}\n```\n\n## `spawn()`\n\n异步执行 Shell 命令，并可以保留进程的输出结果。\n\n```typescript\nimport { spawn } from 'child_process';\n\nconst ls = spawn('ls');\n\nls.stdout.on('data', (data) => {\n  console.log(`输出内容: ${data}`);\n});\n\nls.stderr.on('data', (data) => {\n  console.error(`错误输出: ${data}`);\n});\n\nls.on('close', (code) => {\n  console.log(`进程退出码: ${code}`);\n});\n```\n\n## `spawnSync()`\n\n同步执行 Shell 命令，并返回输出结果。\n\n```typescript\nimport { spawnSync } from 'child_process';\n\nconst ls = spawnSync('ls');\nif (ls.error) {\n  console.error(`执行命令出错: ${ls.error.message}`);\n} else {\n  console.log(`输出内容: ${ls.output.toString()}`);\n}\n```\n\n## `execFile()`\n\n异步执行可执行文件，可以传入命令行参数。\n\n```typescript\nimport { execFile } from 'child_process';\n\nconst command = 'cd';\nconst args = ['/d', 'desktop'];\n\nexecFile(command, args, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`执行命令出错: ${error.message}`);\n    return;\n  }\n  console.log(`输出内容: ${stdout}`);\n});\n```\n\n## `execFileSync()`\n\n同步执行可执行文件，可以传入命令行参数。\n\n```typescript\nimport { execFileSync } from 'child_process';\n\nconst command = 'cd';\nconst args = ['/d', 'desktop'];\n\ntry {\n  const output = execFileSync(command, args);\n  console.log(`输出内容: ${output.toString()}`);\n} catch (error) {\n  console.error(`执行命令出错: ${error.message}`);\n}\n```\n\n## `execShellCommand()`\n\n自定义一个异步执行 Shell 命令的封装函数。\n\n```typescript\nimport { exec } from 'child_process';\n\nfunction execShellCommand(command: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    exec(command, (error, stdout, stderr) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n      resolve(stdout.trim());\n    });\n  });\n}\n\n// 使用示例\nasync function main() {\n  try {\n    const output = await execShellCommand('ls');\n    console.log(`输出内容: ${output}`);\n  } catch (error) {\n    console.error(`执行命令出错: ${error.message}`);\n  }\n}\n\nmain();\n```\n\n这个方法将 `exec` 包装在一个 Promise 中，使其可以轻松地使用 `await` 进行异步操作。\n\n## `spawnShellCommand()`\n\n自定义一个异步执行 Shell 命令的封装函数，支持参数和流式数据处理。\n\n```typescript\nimport { spawn } from 'child_process';\n\nfunction spawnShellCommand(command: string, args: string[]): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const child = spawn(command, args);\n\n    let output = '';\n\n    child.stdout.on('data', (data) => {\n      output += data.toString();\n    });\n\n    child.stderr.on('data', (data) => {\n      console.error(data.toString());\n    });\n\n    child.on('error', (error) => {\n      reject(error);\n    });\n\n    child.on('close', (code) => {\n      if (code !== 0) {\n        reject(new Error(`命令执行失败，退出码: ${code}`));\n        return;\n      }\n      resolve(output.trim());\n    });\n  });\n}\n\n// 使用示例\nasync function main() {\n  try {\n    const output = await spawnShellCommand('ls', ['-lh']);\n    console.log(`输出内容: ${output}`);\n  } catch (error) {\n    console.error(`执行命令出错: ${error.message}`);\n  }\n}\n\nmain();\n```\n\n这个方法使用 `spawn` 创建子进程，并处理标准输出和标准错误流，最后返回整个输出结果。\n","slug":"Typescript执行Shell","published":1,"updated":"2023-09-13T14:45:18.040Z","_id":"clmdip5dw00001s5ghxak48vy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Typescript执行Shell\"><a href=\"#Typescript执行Shell\" class=\"headerlink\" title=\"Typescript执行Shell\"></a>Typescript执行Shell</h1><h2 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a><code>exec()</code></h2><p>异步执行 Shell 命令，且不会保留子进程的输出结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; exec &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execSync\"><a href=\"#execSync\" class=\"headerlink\" title=\"execSync()\"></a><code>execSync()</code></h2><p>同步执行 Shell 命令，并返回输出结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; execSync &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-title function_\">execSync</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;output.toString()&#125;</span>`</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"spawn\"><a href=\"#spawn\" class=\"headerlink\" title=\"spawn()\"></a><code>spawn()</code></h2><p>异步执行 Shell 命令，并可以保留进程的输出结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; spawn &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> ls = <span class=\"hljs-title function_\">spawn</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>);<br><br>ls.<span class=\"hljs-property\">stdout</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`进程退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"spawnSync\"><a href=\"#spawnSync\" class=\"headerlink\" title=\"spawnSync()\"></a><code>spawnSync()</code></h2><p>同步执行 Shell 命令，并返回输出结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; spawnSync &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> ls = <span class=\"hljs-title function_\">spawnSync</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>);<br><span class=\"hljs-keyword\">if</span> (ls.<span class=\"hljs-property\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;ls.error.message&#125;</span>`</span>);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;ls.output.toString()&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execFile\"><a href=\"#execFile\" class=\"headerlink\" title=\"execFile()\"></a><code>execFile()</code></h2><p>异步执行可执行文件，可以传入命令行参数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; execFile &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> command = <span class=\"hljs-string\">&#x27;cd&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> args = [<span class=\"hljs-string\">&#x27;/d&#x27;</span>, <span class=\"hljs-string\">&#x27;desktop&#x27;</span>];<br><br><span class=\"hljs-title function_\">execFile</span>(command, args, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execFileSync\"><a href=\"#execFileSync\" class=\"headerlink\" title=\"execFileSync()\"></a><code>execFileSync()</code></h2><p>同步执行可执行文件，可以传入命令行参数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; execFileSync &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> command = <span class=\"hljs-string\">&#x27;cd&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> args = [<span class=\"hljs-string\">&#x27;/d&#x27;</span>, <span class=\"hljs-string\">&#x27;desktop&#x27;</span>];<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-title function_\">execFileSync</span>(command, args);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;output.toString()&#125;</span>`</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execShellCommand\"><a href=\"#execShellCommand\" class=\"headerlink\" title=\"execShellCommand()\"></a><code>execShellCommand()</code></h2><p>自定义一个异步执行 Shell 命令的封装函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; exec &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">execShellCommand</span>(<span class=\"hljs-params\">command: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">exec</span>(command, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (error) &#123;<br>        <span class=\"hljs-title function_\">reject</span>(error);<br>        <span class=\"hljs-keyword\">return</span>;<br>      &#125;<br>      <span class=\"hljs-title function_\">resolve</span>(stdout.<span class=\"hljs-title function_\">trim</span>());<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class=\"hljs-comment\">// 使用示例</span><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">execShellCommand</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;output&#125;</span>`</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">main</span>();<br></code></pre></td></tr></table></figure>\n\n<p>这个方法将 <code>exec</code> 包装在一个 Promise 中，使其可以轻松地使用 <code>await</code> 进行异步操作。</p>\n<h2 id=\"spawnShellCommand\"><a href=\"#spawnShellCommand\" class=\"headerlink\" title=\"spawnShellCommand()\"></a><code>spawnShellCommand()</code></h2><p>自定义一个异步执行 Shell 命令的封装函数，支持参数和流式数据处理。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; spawn &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">spawnShellCommand</span>(<span class=\"hljs-params\">command: <span class=\"hljs-built_in\">string</span>, args: <span class=\"hljs-built_in\">string</span>[]</span>): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> child = <span class=\"hljs-title function_\">spawn</span>(command, args);<br><br>    <span class=\"hljs-keyword\">let</span> output = <span class=\"hljs-string\">&#x27;&#x27;</span>;<br><br>    child.<span class=\"hljs-property\">stdout</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>      output += data.<span class=\"hljs-title function_\">toString</span>();<br>    &#125;);<br><br>    child.<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(data.<span class=\"hljs-title function_\">toString</span>());<br>    &#125;);<br><br>    child.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;error&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">reject</span>(error);<br>    &#125;);<br><br>    child.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (code !== <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`命令执行失败，退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>));<br>        <span class=\"hljs-keyword\">return</span>;<br>      &#125;<br>      <span class=\"hljs-title function_\">resolve</span>(output.<span class=\"hljs-title function_\">trim</span>());<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class=\"hljs-comment\">// 使用示例</span><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">spawnShellCommand</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, [<span class=\"hljs-string\">&#x27;-lh&#x27;</span>]);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;output&#125;</span>`</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">main</span>();<br></code></pre></td></tr></table></figure>\n\n<p>这个方法使用 <code>spawn</code> 创建子进程，并处理标准输出和标准错误流，最后返回整个输出结果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Typescript执行Shell\"><a href=\"#Typescript执行Shell\" class=\"headerlink\" title=\"Typescript执行Shell\"></a>Typescript执行Shell</h1><h2 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a><code>exec()</code></h2><p>异步执行 Shell 命令，且不会保留子进程的输出结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; exec &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execSync\"><a href=\"#execSync\" class=\"headerlink\" title=\"execSync()\"></a><code>execSync()</code></h2><p>同步执行 Shell 命令，并返回输出结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; execSync &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-title function_\">execSync</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;output.toString()&#125;</span>`</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"spawn\"><a href=\"#spawn\" class=\"headerlink\" title=\"spawn()\"></a><code>spawn()</code></h2><p>异步执行 Shell 命令，并可以保留进程的输出结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; spawn &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> ls = <span class=\"hljs-title function_\">spawn</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>);<br><br>ls.<span class=\"hljs-property\">stdout</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`错误输出: <span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`进程退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"spawnSync\"><a href=\"#spawnSync\" class=\"headerlink\" title=\"spawnSync()\"></a><code>spawnSync()</code></h2><p>同步执行 Shell 命令，并返回输出结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; spawnSync &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> ls = <span class=\"hljs-title function_\">spawnSync</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>);<br><span class=\"hljs-keyword\">if</span> (ls.<span class=\"hljs-property\">error</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;ls.error.message&#125;</span>`</span>);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;ls.output.toString()&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execFile\"><a href=\"#execFile\" class=\"headerlink\" title=\"execFile()\"></a><code>execFile()</code></h2><p>异步执行可执行文件，可以传入命令行参数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; execFile &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> command = <span class=\"hljs-string\">&#x27;cd&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> args = [<span class=\"hljs-string\">&#x27;/d&#x27;</span>, <span class=\"hljs-string\">&#x27;desktop&#x27;</span>];<br><br><span class=\"hljs-title function_\">execFile</span>(command, args, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;stdout&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execFileSync\"><a href=\"#execFileSync\" class=\"headerlink\" title=\"execFileSync()\"></a><code>execFileSync()</code></h2><p>同步执行可执行文件，可以传入命令行参数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; execFileSync &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> command = <span class=\"hljs-string\">&#x27;cd&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> args = [<span class=\"hljs-string\">&#x27;/d&#x27;</span>, <span class=\"hljs-string\">&#x27;desktop&#x27;</span>];<br><br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-title function_\">execFileSync</span>(command, args);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;output.toString()&#125;</span>`</span>);<br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"execShellCommand\"><a href=\"#execShellCommand\" class=\"headerlink\" title=\"execShellCommand()\"></a><code>execShellCommand()</code></h2><p>自定义一个异步执行 Shell 命令的封装函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; exec &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">execShellCommand</span>(<span class=\"hljs-params\">command: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">exec</span>(command, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, stdout, stderr</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (error) &#123;<br>        <span class=\"hljs-title function_\">reject</span>(error);<br>        <span class=\"hljs-keyword\">return</span>;<br>      &#125;<br>      <span class=\"hljs-title function_\">resolve</span>(stdout.<span class=\"hljs-title function_\">trim</span>());<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class=\"hljs-comment\">// 使用示例</span><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">execShellCommand</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;output&#125;</span>`</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">main</span>();<br></code></pre></td></tr></table></figure>\n\n<p>这个方法将 <code>exec</code> 包装在一个 Promise 中，使其可以轻松地使用 <code>await</code> 进行异步操作。</p>\n<h2 id=\"spawnShellCommand\"><a href=\"#spawnShellCommand\" class=\"headerlink\" title=\"spawnShellCommand()\"></a><code>spawnShellCommand()</code></h2><p>自定义一个异步执行 Shell 命令的封装函数，支持参数和流式数据处理。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123; spawn &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;child_process&#x27;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">spawnShellCommand</span>(<span class=\"hljs-params\">command: <span class=\"hljs-built_in\">string</span>, args: <span class=\"hljs-built_in\">string</span>[]</span>): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> child = <span class=\"hljs-title function_\">spawn</span>(command, args);<br><br>    <span class=\"hljs-keyword\">let</span> output = <span class=\"hljs-string\">&#x27;&#x27;</span>;<br><br>    child.<span class=\"hljs-property\">stdout</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>      output += data.<span class=\"hljs-title function_\">toString</span>();<br>    &#125;);<br><br>    child.<span class=\"hljs-property\">stderr</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(data.<span class=\"hljs-title function_\">toString</span>());<br>    &#125;);<br><br>    child.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;error&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">reject</span>(error);<br>    &#125;);<br><br>    child.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;close&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">code</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (code !== <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`命令执行失败，退出码: <span class=\"hljs-subst\">$&#123;code&#125;</span>`</span>));<br>        <span class=\"hljs-keyword\">return</span>;<br>      &#125;<br>      <span class=\"hljs-title function_\">resolve</span>(output.<span class=\"hljs-title function_\">trim</span>());<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class=\"hljs-comment\">// 使用示例</span><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">spawnShellCommand</span>(<span class=\"hljs-string\">&#x27;ls&#x27;</span>, [<span class=\"hljs-string\">&#x27;-lh&#x27;</span>]);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`输出内容: <span class=\"hljs-subst\">$&#123;output&#125;</span>`</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`执行命令出错: <span class=\"hljs-subst\">$&#123;error.message&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-title function_\">main</span>();<br></code></pre></td></tr></table></figure>\n\n<p>这个方法使用 <code>spawn</code> 创建子进程，并处理标准输出和标准错误流，最后返回整个输出结果。</p>\n"},{"title":"Objective-C执行Shell","date":"2023-09-10T14:46:48.000Z","author":"Grey-Wind","_content":"\n# Objective-C执行Shell\n\n## 使用NSTask类\n\n```objc\nNSTask *task = [[NSTask alloc] init];\n[task setLaunchPath:@\"/bin/sh\"];\n[task setArguments:@[@\"-c\", @\"ls -al\"]];\n\nNSPipe *pipe = [NSPipe pipe];\n[task setStandardOutput:pipe];\n\n[task launch];\n\nNSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];\nNSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n\nNSLog(@\"Shell command output:\\n%@\", output);\n```\n\n代码创建了一个NSTask实例，设置它的启动路径为/bin/sh，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接着，我们调用lauch方法启动任务并等待它完成。最后，我们从管道的读取端读取所有数据，并使用UTF8编码将其转换为字符串，打印出执行结果。\n\n## 使用system函数\n\n```objc\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *command = @\"ls -al\";\n        const char *cmd = [command UTF8String];\n        \n        int status = system(cmd);\n        if (status == -1) {\n            NSLog(@\"Failed to execute shell command\");\n        } else {\n            NSLog(@\"Shell command exited with status: %d\", status);\n        }\n    }\n    return 0;\n}\n```\n\n在这个示例中，我们通过NSString对象创建要执行的Shell命令，并将其转换为C字符串。然后，我们使用system函数来执行命令，并存储返回的状态码。最后，根据状态码打印相应的信息。\n\n## NSTask任务+NSPipe实例\n\n```objc\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSTask *task = [[NSTask alloc] init];\n        [task setLaunchPath:@\"/bin/sh\"];\n        [task setArguments:@[@\"-c\", @\"ls -al\"]];\n\n        NSPipe *pipe = [NSPipe pipe];\n        [task setStandardOutput:pipe];\n\n        NSFileHandle *file = [pipe fileHandleForReading];\n        [task launch];\n        \n        NSData *data = [file readDataToEndOfFile];\n        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n        \n        NSLog(@\"Shell command output:\\n%@\", output);\n    }\n    return 0;\n}\n```\n\n这个例子中，我们使用NSTask创建一个任务，并设置其启动路径为`/bin/sh`，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接下来，我们获取管道的文件句柄，并启动任务。然后，我们从文件句柄中读取所有数据，并将其转换为字符串，最后打印出执行结果。\n\n这种方式相对于之前的示例更灵活，可以更方便地处理任务的输入和输出。\n\n## 通过管道进行输入和输出的交互(NSTask)\n\n```objc\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSTask *task = [[NSTask alloc] init];\n        [task setLaunchPath:@\"/bin/sh\"];\n        \n        NSPipe *inputPipe = [NSPipe pipe];\n        NSPipe *outputPipe = [NSPipe pipe];\n        \n        [task setStandardInput:inputPipe];\n        [task setStandardOutput:outputPipe];\n        \n        NSFileHandle *inputHandle = [inputPipe fileHandleForWriting];\n        NSFileHandle *outputHandle = [outputPipe fileHandleForReading];\n        \n        [task launch];\n        \n        NSString *command = @\"ls -al\";\n        NSData *commandData = [command dataUsingEncoding:NSUTF8StringEncoding];\n        [inputHandle writeData:commandData];\n        [inputHandle closeFile];\n        \n        NSData *outputData = [outputHandle readDataToEndOfFile];\n        NSString *output = [[NSString alloc] initWithData:outputData encoding:NSUTF8StringEncoding];\n        \n        NSLog(@\"Shell command output:\\n%@\", output);\n    }\n    return 0;\n}\n```\n\n在这个示例中，创建了一个`NSTask`对象，并设置其启动路径为`/bin/sh`。然后，我们创建了两个管道，一个用于将命令输入给Shell，另一个用于获取Shell的输出。我们将这两个管道分别设置为任务的标准输入和标准输出。\n\n接下来获取输入管道和输出管道的文件句柄，并启动任务。然后创建一个要执行的Shell命令，并将其转换为NSData对象。使用输入句柄，我们将命令数据写入输入管道，并关闭输入句柄。\n\n最后，从输出句柄中读取所有数据，并将其转换为字符串。打印出Shell命令的输出结果。\n","source":"_posts/Objective-C执行Shell.md","raw":"---\ntitle: Objective-C执行Shell\ndate: 2023-09-10 22:46:48\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Objective-C执行Shell\n\n## 使用NSTask类\n\n```objc\nNSTask *task = [[NSTask alloc] init];\n[task setLaunchPath:@\"/bin/sh\"];\n[task setArguments:@[@\"-c\", @\"ls -al\"]];\n\nNSPipe *pipe = [NSPipe pipe];\n[task setStandardOutput:pipe];\n\n[task launch];\n\nNSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];\nNSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n\nNSLog(@\"Shell command output:\\n%@\", output);\n```\n\n代码创建了一个NSTask实例，设置它的启动路径为/bin/sh，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接着，我们调用lauch方法启动任务并等待它完成。最后，我们从管道的读取端读取所有数据，并使用UTF8编码将其转换为字符串，打印出执行结果。\n\n## 使用system函数\n\n```objc\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *command = @\"ls -al\";\n        const char *cmd = [command UTF8String];\n        \n        int status = system(cmd);\n        if (status == -1) {\n            NSLog(@\"Failed to execute shell command\");\n        } else {\n            NSLog(@\"Shell command exited with status: %d\", status);\n        }\n    }\n    return 0;\n}\n```\n\n在这个示例中，我们通过NSString对象创建要执行的Shell命令，并将其转换为C字符串。然后，我们使用system函数来执行命令，并存储返回的状态码。最后，根据状态码打印相应的信息。\n\n## NSTask任务+NSPipe实例\n\n```objc\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSTask *task = [[NSTask alloc] init];\n        [task setLaunchPath:@\"/bin/sh\"];\n        [task setArguments:@[@\"-c\", @\"ls -al\"]];\n\n        NSPipe *pipe = [NSPipe pipe];\n        [task setStandardOutput:pipe];\n\n        NSFileHandle *file = [pipe fileHandleForReading];\n        [task launch];\n        \n        NSData *data = [file readDataToEndOfFile];\n        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n        \n        NSLog(@\"Shell command output:\\n%@\", output);\n    }\n    return 0;\n}\n```\n\n这个例子中，我们使用NSTask创建一个任务，并设置其启动路径为`/bin/sh`，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接下来，我们获取管道的文件句柄，并启动任务。然后，我们从文件句柄中读取所有数据，并将其转换为字符串，最后打印出执行结果。\n\n这种方式相对于之前的示例更灵活，可以更方便地处理任务的输入和输出。\n\n## 通过管道进行输入和输出的交互(NSTask)\n\n```objc\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSTask *task = [[NSTask alloc] init];\n        [task setLaunchPath:@\"/bin/sh\"];\n        \n        NSPipe *inputPipe = [NSPipe pipe];\n        NSPipe *outputPipe = [NSPipe pipe];\n        \n        [task setStandardInput:inputPipe];\n        [task setStandardOutput:outputPipe];\n        \n        NSFileHandle *inputHandle = [inputPipe fileHandleForWriting];\n        NSFileHandle *outputHandle = [outputPipe fileHandleForReading];\n        \n        [task launch];\n        \n        NSString *command = @\"ls -al\";\n        NSData *commandData = [command dataUsingEncoding:NSUTF8StringEncoding];\n        [inputHandle writeData:commandData];\n        [inputHandle closeFile];\n        \n        NSData *outputData = [outputHandle readDataToEndOfFile];\n        NSString *output = [[NSString alloc] initWithData:outputData encoding:NSUTF8StringEncoding];\n        \n        NSLog(@\"Shell command output:\\n%@\", output);\n    }\n    return 0;\n}\n```\n\n在这个示例中，创建了一个`NSTask`对象，并设置其启动路径为`/bin/sh`。然后，我们创建了两个管道，一个用于将命令输入给Shell，另一个用于获取Shell的输出。我们将这两个管道分别设置为任务的标准输入和标准输出。\n\n接下来获取输入管道和输出管道的文件句柄，并启动任务。然后创建一个要执行的Shell命令，并将其转换为NSData对象。使用输入句柄，我们将命令数据写入输入管道，并关闭输入句柄。\n\n最后，从输出句柄中读取所有数据，并将其转换为字符串。打印出Shell命令的输出结果。\n","slug":"Objective-C执行Shell","published":1,"updated":"2023-09-13T14:44:58.379Z","_id":"clmdkqd1y0000l05g63kvdzdf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Objective-C执行Shell\"><a href=\"#Objective-C执行Shell\" class=\"headerlink\" title=\"Objective-C执行Shell\"></a>Objective-C执行Shell</h1><h2 id=\"使用NSTask类\"><a href=\"#使用NSTask类\" class=\"headerlink\" title=\"使用NSTask类\"></a>使用NSTask类</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objc\"><span class=\"hljs-built_in\">NSTask</span> *task = [[<span class=\"hljs-built_in\">NSTask</span> alloc] init];<br>[task setLaunchPath:<span class=\"hljs-string\">@&quot;/bin/sh&quot;</span>];<br>[task setArguments:@[<span class=\"hljs-string\">@&quot;-c&quot;</span>, <span class=\"hljs-string\">@&quot;ls -al&quot;</span>]];<br><br><span class=\"hljs-built_in\">NSPipe</span> *pipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>[task setStandardOutput:pipe];<br><br>[task launch];<br><br><span class=\"hljs-built_in\">NSData</span> *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br><span class=\"hljs-built_in\">NSString</span> *output = [[<span class=\"hljs-built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br><br><span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Shell command output:\\n%@&quot;</span>, output);<br></code></pre></td></tr></table></figure>\n\n<p>代码创建了一个NSTask实例，设置它的启动路径为&#x2F;bin&#x2F;sh，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接着，我们调用lauch方法启动任务并等待它完成。最后，我们从管道的读取端读取所有数据，并使用UTF8编码将其转换为字符串，打印出执行结果。</p>\n<h2 id=\"使用system函数\"><a href=\"#使用system函数\" class=\"headerlink\" title=\"使用system函数\"></a>使用system函数</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objc\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSString</span> *command = <span class=\"hljs-string\">@&quot;ls -al&quot;</span>;<br>        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *cmd = [command UTF8String];<br>        <br>        <span class=\"hljs-type\">int</span> status = system(cmd);<br>        <span class=\"hljs-keyword\">if</span> (status == <span class=\"hljs-number\">-1</span>) &#123;<br>            <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Failed to execute shell command&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Shell command exited with status: %d&quot;</span>, status);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个示例中，我们通过NSString对象创建要执行的Shell命令，并将其转换为C字符串。然后，我们使用system函数来执行命令，并存储返回的状态码。最后，根据状态码打印相应的信息。</p>\n<h2 id=\"NSTask任务-NSPipe实例\"><a href=\"#NSTask任务-NSPipe实例\" class=\"headerlink\" title=\"NSTask任务+NSPipe实例\"></a>NSTask任务+NSPipe实例</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objc\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSTask</span> *task = [[<span class=\"hljs-built_in\">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class=\"hljs-string\">@&quot;/bin/sh&quot;</span>];<br>        [task setArguments:@[<span class=\"hljs-string\">@&quot;-c&quot;</span>, <span class=\"hljs-string\">@&quot;ls -al&quot;</span>]];<br><br>        <span class=\"hljs-built_in\">NSPipe</span> *pipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>        [task setStandardOutput:pipe];<br><br>        <span class=\"hljs-built_in\">NSFileHandle</span> *file = [pipe fileHandleForReading];<br>        [task launch];<br>        <br>        <span class=\"hljs-built_in\">NSData</span> *data = [file readDataToEndOfFile];<br>        <span class=\"hljs-built_in\">NSString</span> *output = [[<span class=\"hljs-built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br>        <br>        <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Shell command output:\\n%@&quot;</span>, output);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个例子中，我们使用NSTask创建一个任务，并设置其启动路径为<code>/bin/sh</code>，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接下来，我们获取管道的文件句柄，并启动任务。然后，我们从文件句柄中读取所有数据，并将其转换为字符串，最后打印出执行结果。</p>\n<p>这种方式相对于之前的示例更灵活，可以更方便地处理任务的输入和输出。</p>\n<h2 id=\"通过管道进行输入和输出的交互-NSTask\"><a href=\"#通过管道进行输入和输出的交互-NSTask\" class=\"headerlink\" title=\"通过管道进行输入和输出的交互(NSTask)\"></a>通过管道进行输入和输出的交互(NSTask)</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objc\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSTask</span> *task = [[<span class=\"hljs-built_in\">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class=\"hljs-string\">@&quot;/bin/sh&quot;</span>];<br>        <br>        <span class=\"hljs-built_in\">NSPipe</span> *inputPipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>        <span class=\"hljs-built_in\">NSPipe</span> *outputPipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>        <br>        [task setStandardInput:inputPipe];<br>        [task setStandardOutput:outputPipe];<br>        <br>        <span class=\"hljs-built_in\">NSFileHandle</span> *inputHandle = [inputPipe fileHandleForWriting];<br>        <span class=\"hljs-built_in\">NSFileHandle</span> *outputHandle = [outputPipe fileHandleForReading];<br>        <br>        [task launch];<br>        <br>        <span class=\"hljs-built_in\">NSString</span> *command = <span class=\"hljs-string\">@&quot;ls -al&quot;</span>;<br>        <span class=\"hljs-built_in\">NSData</span> *commandData = [command dataUsingEncoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br>        [inputHandle writeData:commandData];<br>        [inputHandle closeFile];<br>        <br>        <span class=\"hljs-built_in\">NSData</span> *outputData = [outputHandle readDataToEndOfFile];<br>        <span class=\"hljs-built_in\">NSString</span> *output = [[<span class=\"hljs-built_in\">NSString</span> alloc] initWithData:outputData encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br>        <br>        <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Shell command output:\\n%@&quot;</span>, output);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个示例中，创建了一个<code>NSTask</code>对象，并设置其启动路径为<code>/bin/sh</code>。然后，我们创建了两个管道，一个用于将命令输入给Shell，另一个用于获取Shell的输出。我们将这两个管道分别设置为任务的标准输入和标准输出。</p>\n<p>接下来获取输入管道和输出管道的文件句柄，并启动任务。然后创建一个要执行的Shell命令，并将其转换为NSData对象。使用输入句柄，我们将命令数据写入输入管道，并关闭输入句柄。</p>\n<p>最后，从输出句柄中读取所有数据，并将其转换为字符串。打印出Shell命令的输出结果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objective-C执行Shell\"><a href=\"#Objective-C执行Shell\" class=\"headerlink\" title=\"Objective-C执行Shell\"></a>Objective-C执行Shell</h1><h2 id=\"使用NSTask类\"><a href=\"#使用NSTask类\" class=\"headerlink\" title=\"使用NSTask类\"></a>使用NSTask类</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objc\"><span class=\"hljs-built_in\">NSTask</span> *task = [[<span class=\"hljs-built_in\">NSTask</span> alloc] init];<br>[task setLaunchPath:<span class=\"hljs-string\">@&quot;/bin/sh&quot;</span>];<br>[task setArguments:@[<span class=\"hljs-string\">@&quot;-c&quot;</span>, <span class=\"hljs-string\">@&quot;ls -al&quot;</span>]];<br><br><span class=\"hljs-built_in\">NSPipe</span> *pipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>[task setStandardOutput:pipe];<br><br>[task launch];<br><br><span class=\"hljs-built_in\">NSData</span> *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br><span class=\"hljs-built_in\">NSString</span> *output = [[<span class=\"hljs-built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br><br><span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Shell command output:\\n%@&quot;</span>, output);<br></code></pre></td></tr></table></figure>\n\n<p>代码创建了一个NSTask实例，设置它的启动路径为&#x2F;bin&#x2F;sh，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接着，我们调用lauch方法启动任务并等待它完成。最后，我们从管道的读取端读取所有数据，并使用UTF8编码将其转换为字符串，打印出执行结果。</p>\n<h2 id=\"使用system函数\"><a href=\"#使用system函数\" class=\"headerlink\" title=\"使用system函数\"></a>使用system函数</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objc\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSString</span> *command = <span class=\"hljs-string\">@&quot;ls -al&quot;</span>;<br>        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *cmd = [command UTF8String];<br>        <br>        <span class=\"hljs-type\">int</span> status = system(cmd);<br>        <span class=\"hljs-keyword\">if</span> (status == <span class=\"hljs-number\">-1</span>) &#123;<br>            <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Failed to execute shell command&quot;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Shell command exited with status: %d&quot;</span>, status);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个示例中，我们通过NSString对象创建要执行的Shell命令，并将其转换为C字符串。然后，我们使用system函数来执行命令，并存储返回的状态码。最后，根据状态码打印相应的信息。</p>\n<h2 id=\"NSTask任务-NSPipe实例\"><a href=\"#NSTask任务-NSPipe实例\" class=\"headerlink\" title=\"NSTask任务+NSPipe实例\"></a>NSTask任务+NSPipe实例</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objc\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSTask</span> *task = [[<span class=\"hljs-built_in\">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class=\"hljs-string\">@&quot;/bin/sh&quot;</span>];<br>        [task setArguments:@[<span class=\"hljs-string\">@&quot;-c&quot;</span>, <span class=\"hljs-string\">@&quot;ls -al&quot;</span>]];<br><br>        <span class=\"hljs-built_in\">NSPipe</span> *pipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>        [task setStandardOutput:pipe];<br><br>        <span class=\"hljs-built_in\">NSFileHandle</span> *file = [pipe fileHandleForReading];<br>        [task launch];<br>        <br>        <span class=\"hljs-built_in\">NSData</span> *data = [file readDataToEndOfFile];<br>        <span class=\"hljs-built_in\">NSString</span> *output = [[<span class=\"hljs-built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br>        <br>        <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Shell command output:\\n%@&quot;</span>, output);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个例子中，我们使用NSTask创建一个任务，并设置其启动路径为<code>/bin/sh</code>，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接下来，我们获取管道的文件句柄，并启动任务。然后，我们从文件句柄中读取所有数据，并将其转换为字符串，最后打印出执行结果。</p>\n<p>这种方式相对于之前的示例更灵活，可以更方便地处理任务的输入和输出。</p>\n<h2 id=\"通过管道进行输入和输出的交互-NSTask\"><a href=\"#通过管道进行输入和输出的交互-NSTask\" class=\"headerlink\" title=\"通过管道进行输入和输出的交互(NSTask)\"></a>通过管道进行输入和输出的交互(NSTask)</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objc\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSTask</span> *task = [[<span class=\"hljs-built_in\">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class=\"hljs-string\">@&quot;/bin/sh&quot;</span>];<br>        <br>        <span class=\"hljs-built_in\">NSPipe</span> *inputPipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>        <span class=\"hljs-built_in\">NSPipe</span> *outputPipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>        <br>        [task setStandardInput:inputPipe];<br>        [task setStandardOutput:outputPipe];<br>        <br>        <span class=\"hljs-built_in\">NSFileHandle</span> *inputHandle = [inputPipe fileHandleForWriting];<br>        <span class=\"hljs-built_in\">NSFileHandle</span> *outputHandle = [outputPipe fileHandleForReading];<br>        <br>        [task launch];<br>        <br>        <span class=\"hljs-built_in\">NSString</span> *command = <span class=\"hljs-string\">@&quot;ls -al&quot;</span>;<br>        <span class=\"hljs-built_in\">NSData</span> *commandData = [command dataUsingEncoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br>        [inputHandle writeData:commandData];<br>        [inputHandle closeFile];<br>        <br>        <span class=\"hljs-built_in\">NSData</span> *outputData = [outputHandle readDataToEndOfFile];<br>        <span class=\"hljs-built_in\">NSString</span> *output = [[<span class=\"hljs-built_in\">NSString</span> alloc] initWithData:outputData encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br>        <br>        <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;Shell command output:\\n%@&quot;</span>, output);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个示例中，创建了一个<code>NSTask</code>对象，并设置其启动路径为<code>/bin/sh</code>。然后，我们创建了两个管道，一个用于将命令输入给Shell，另一个用于获取Shell的输出。我们将这两个管道分别设置为任务的标准输入和标准输出。</p>\n<p>接下来获取输入管道和输出管道的文件句柄，并启动任务。然后创建一个要执行的Shell命令，并将其转换为NSData对象。使用输入句柄，我们将命令数据写入输入管道，并关闭输入句柄。</p>\n<p>最后，从输出句柄中读取所有数据，并将其转换为字符串。打印出Shell命令的输出结果。</p>\n"},{"title":"Objective-C++执行Shell","date":"2023-09-10T14:58:22.000Z","author":"Grey-Wind","_content":"\n# Objective-C++执行Shell\n\n## 使用 NSTask 类\n\nNSTask 是一个 Objective-C 类，用于在 macOS 或 iOS 应用程序中执行外部命令。它可以创建一个子进程，并允许您设置命令、参数和环境变量。下面是一个示例代码片段：\n\n```objective-c\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSTask *task = [[NSTask alloc] init];\n        [task setLaunchPath:@\"/usr/bin/env\"];\n        [task setArguments:@[@\"ls\", @\"-l\"]];\n        \n        NSPipe *pipe = [NSPipe pipe];\n        [task setStandardOutput:pipe];\n        \n        [task launch];\n        [task waitUntilExit];\n        \n        NSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];\n        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n        NSLog(@\"%@\", output);\n    }\n    return 0;\n}\n```\n\n上述代码中，NSTask 用于运行 \"ls -l\" 命令，并将输出保存到一个 NSPipe 中。然后，我们读取管道中的数据并打印到控制台。\n\n## 使用 system() 函数\n\nC++ 中有一个名为 system() 的函数，可以用于执行 Shell 命令。在 Objective-C++ 中，您也可以使用该函数。下面是一个示例代码片段：\n\n```objective-c++\n#include <iostream>\n#include <cstdlib>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int result = system(\"ls -l\");\n        if (result != 0) {\n            std::cout << \"Command execution failed.\" << std::endl;\n        }\n    }\n    return 0;\n}\n```\n\n## 使用 popen() 函数\n\npopen() 函数可以用于执行 Shell 命令并获取输出。\n\n```objective-c++\n#include <iostream>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        FILE *pipe = popen(\"ls -l\", \"r\");\n        if (pipe == NULL) {\n            std::cout << \"Command execution failed.\" << std::endl;\n            return -1;\n        }\n        \n        char buffer[128];\n        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {\n            std::cout << buffer;\n        }\n        \n        pclose(pipe);\n    }\n    return 0;\n}\n```\n\n上述代码中，我们使用 popen() 执行 \"ls -l\" 命令，并逐行读取输出并打印到控制台。\n\n## 使用 NSTask 的便捷方法\n\nNSTask 类提供了一些便捷方法来执行 Shell 命令，而无需手动设置 launch path 和 arguments。\n\n```objective-c++\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *output = [NSString stringWithContentsOfURL:[NSURL URLWithString:@\"http://example.com\"]\n                                                    encoding:NSUTF8StringEncoding\n                                                       error:nil];\n        NSLog(@\"%@\", output);\n    }\n    return 0;\n}\n```\n\n上述代码中，我们使用 `[NSString stringWithContentsOfURL:encoding:error:]` 方法执行了 `curl http://example.com` 命令，并将输出保存在 NSString 对象中。\n\n5. 使用 system() 或 popen() 的 C++ 封装：您可以将 system() 或 popen() 函数进行封装，以便更方便地在 Objective-C++ 中使用。例如，可以创建一个 C++ 函数来执行 Shell 命令，并返回结果。下面是一个示例代码片段：\n\n```objective-c++\n#include <iostream>\n#include <cstdio>\n\nstd::string executeShellCommand(const std::string &command) {\n    char buffer[128];\n    std::string result = \"\";\n    \n    FILE *pipe = popen(command.c_str(), \"r\");\n    if (!pipe) {\n        return \"Command execution failed.\";\n    }\n    \n    while (fgets(buffer, sizeof(buffer), pipe) != NULL) {\n        result += buffer;\n    }\n    \n    pclose(pipe);\n    \n    return result;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        std::string output = executeShellCommand(\"ls -l\");\n        std::cout << output;\n    }\n    return 0;\n}\n```\n\n上述代码中，我们定义了一个 `executeShellCommand()` 函数，它接受一个 Shell 命令，并返回执行结果。在 `main()` 函数中，我们调用该函数执行 \"ls -l\" 命令，并将输出打印到控制台。\n\n## 使用 POSIX 的 fork() 和 exec() 函数\n\nObjective-C++ 可以直接使用 POSIX 的 fork() 和 exec() 函数来创建子进程并执行外部命令。下面是一个示例代码片段：\n\n```objective-c++\n#include <iostream>\n#include <unistd.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        pid_t pid = fork();\n        \n        if (pid < 0) {\n            std::cout << \"Failed to create child process.\" << std::endl;\n            return -1;\n        } else if (pid == 0) {\n            // Child process\n            execl(\"/bin/ls\", \"ls\", \"-l\", NULL);\n            std::cout << \"Failed to execute command.\" << std::endl;\n            return -1;\n        } else {\n            // Parent process\n            wait(NULL);\n        }\n    }\n    return 0;\n}\n```\n\n上述代码中，我们通过调用 fork() 函数创建了一个子进程，并在子进程中调用 execl() 函数来执行 \"ls -l\" 命令。父进程通过调用 wait() 函数等待子进程的结束。\n\n## 使用 NSTask 的便捷方法执行 Shell 脚本\n\n如果要执行复杂的 Shell 脚本，可以使用 NSTask 的便捷方法来执行脚本文件。下面是一个示例代码片段：\n\n```objective-c++\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *scriptPath = [[NSBundle mainBundle] pathForResource:@\"script.sh\" ofType:nil];\n        \n        NSTask *task = [[NSTask alloc] init];\n        [task setLaunchPath:@\"/bin/sh\"];\n        [task setArguments:@[scriptPath]];\n        \n        NSPipe *pipe = [NSPipe pipe];\n        [task setStandardOutput:pipe];\n        \n        [task launch];\n        [task waitUntilExit];\n        \n        NSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];\n        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n        NSLog(@\"%@\", output);\n    }\n    return 0;\n}\n```\n\n上述代码中，我们使用 NSTask 执行一个名为 \"script.sh\" 的 Shell 脚本文件，并将输出保存到一个 NSPipe 中。\n","source":"_posts/Objective-C++执行Shell.md","raw":"---\ntitle: Objective-C++执行Shell\ndate: 2023-09-10 22:58:22\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# Objective-C++执行Shell\n\n## 使用 NSTask 类\n\nNSTask 是一个 Objective-C 类，用于在 macOS 或 iOS 应用程序中执行外部命令。它可以创建一个子进程，并允许您设置命令、参数和环境变量。下面是一个示例代码片段：\n\n```objective-c\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSTask *task = [[NSTask alloc] init];\n        [task setLaunchPath:@\"/usr/bin/env\"];\n        [task setArguments:@[@\"ls\", @\"-l\"]];\n        \n        NSPipe *pipe = [NSPipe pipe];\n        [task setStandardOutput:pipe];\n        \n        [task launch];\n        [task waitUntilExit];\n        \n        NSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];\n        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n        NSLog(@\"%@\", output);\n    }\n    return 0;\n}\n```\n\n上述代码中，NSTask 用于运行 \"ls -l\" 命令，并将输出保存到一个 NSPipe 中。然后，我们读取管道中的数据并打印到控制台。\n\n## 使用 system() 函数\n\nC++ 中有一个名为 system() 的函数，可以用于执行 Shell 命令。在 Objective-C++ 中，您也可以使用该函数。下面是一个示例代码片段：\n\n```objective-c++\n#include <iostream>\n#include <cstdlib>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        int result = system(\"ls -l\");\n        if (result != 0) {\n            std::cout << \"Command execution failed.\" << std::endl;\n        }\n    }\n    return 0;\n}\n```\n\n## 使用 popen() 函数\n\npopen() 函数可以用于执行 Shell 命令并获取输出。\n\n```objective-c++\n#include <iostream>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        FILE *pipe = popen(\"ls -l\", \"r\");\n        if (pipe == NULL) {\n            std::cout << \"Command execution failed.\" << std::endl;\n            return -1;\n        }\n        \n        char buffer[128];\n        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {\n            std::cout << buffer;\n        }\n        \n        pclose(pipe);\n    }\n    return 0;\n}\n```\n\n上述代码中，我们使用 popen() 执行 \"ls -l\" 命令，并逐行读取输出并打印到控制台。\n\n## 使用 NSTask 的便捷方法\n\nNSTask 类提供了一些便捷方法来执行 Shell 命令，而无需手动设置 launch path 和 arguments。\n\n```objective-c++\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *output = [NSString stringWithContentsOfURL:[NSURL URLWithString:@\"http://example.com\"]\n                                                    encoding:NSUTF8StringEncoding\n                                                       error:nil];\n        NSLog(@\"%@\", output);\n    }\n    return 0;\n}\n```\n\n上述代码中，我们使用 `[NSString stringWithContentsOfURL:encoding:error:]` 方法执行了 `curl http://example.com` 命令，并将输出保存在 NSString 对象中。\n\n5. 使用 system() 或 popen() 的 C++ 封装：您可以将 system() 或 popen() 函数进行封装，以便更方便地在 Objective-C++ 中使用。例如，可以创建一个 C++ 函数来执行 Shell 命令，并返回结果。下面是一个示例代码片段：\n\n```objective-c++\n#include <iostream>\n#include <cstdio>\n\nstd::string executeShellCommand(const std::string &command) {\n    char buffer[128];\n    std::string result = \"\";\n    \n    FILE *pipe = popen(command.c_str(), \"r\");\n    if (!pipe) {\n        return \"Command execution failed.\";\n    }\n    \n    while (fgets(buffer, sizeof(buffer), pipe) != NULL) {\n        result += buffer;\n    }\n    \n    pclose(pipe);\n    \n    return result;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        std::string output = executeShellCommand(\"ls -l\");\n        std::cout << output;\n    }\n    return 0;\n}\n```\n\n上述代码中，我们定义了一个 `executeShellCommand()` 函数，它接受一个 Shell 命令，并返回执行结果。在 `main()` 函数中，我们调用该函数执行 \"ls -l\" 命令，并将输出打印到控制台。\n\n## 使用 POSIX 的 fork() 和 exec() 函数\n\nObjective-C++ 可以直接使用 POSIX 的 fork() 和 exec() 函数来创建子进程并执行外部命令。下面是一个示例代码片段：\n\n```objective-c++\n#include <iostream>\n#include <unistd.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        pid_t pid = fork();\n        \n        if (pid < 0) {\n            std::cout << \"Failed to create child process.\" << std::endl;\n            return -1;\n        } else if (pid == 0) {\n            // Child process\n            execl(\"/bin/ls\", \"ls\", \"-l\", NULL);\n            std::cout << \"Failed to execute command.\" << std::endl;\n            return -1;\n        } else {\n            // Parent process\n            wait(NULL);\n        }\n    }\n    return 0;\n}\n```\n\n上述代码中，我们通过调用 fork() 函数创建了一个子进程，并在子进程中调用 execl() 函数来执行 \"ls -l\" 命令。父进程通过调用 wait() 函数等待子进程的结束。\n\n## 使用 NSTask 的便捷方法执行 Shell 脚本\n\n如果要执行复杂的 Shell 脚本，可以使用 NSTask 的便捷方法来执行脚本文件。下面是一个示例代码片段：\n\n```objective-c++\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *scriptPath = [[NSBundle mainBundle] pathForResource:@\"script.sh\" ofType:nil];\n        \n        NSTask *task = [[NSTask alloc] init];\n        [task setLaunchPath:@\"/bin/sh\"];\n        [task setArguments:@[scriptPath]];\n        \n        NSPipe *pipe = [NSPipe pipe];\n        [task setStandardOutput:pipe];\n        \n        [task launch];\n        [task waitUntilExit];\n        \n        NSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];\n        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n        NSLog(@\"%@\", output);\n    }\n    return 0;\n}\n```\n\n上述代码中，我们使用 NSTask 执行一个名为 \"script.sh\" 的 Shell 脚本文件，并将输出保存到一个 NSPipe 中。\n","slug":"Objective-C++执行Shell","published":1,"updated":"2023-09-13T14:44:55.503Z","_id":"clmdl5yx70000h85g870nag79","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Objective-C-执行Shell\"><a href=\"#Objective-C-执行Shell\" class=\"headerlink\" title=\"Objective-C++执行Shell\"></a>Objective-C++执行Shell</h1><h2 id=\"使用-NSTask-类\"><a href=\"#使用-NSTask-类\" class=\"headerlink\" title=\"使用 NSTask 类\"></a>使用 NSTask 类</h2><p>NSTask 是一个 Objective-C 类，用于在 macOS 或 iOS 应用程序中执行外部命令。它可以创建一个子进程，并允许您设置命令、参数和环境变量。下面是一个示例代码片段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c\">#import &lt;Foundation/Foundation.h&gt;<br><br>int main(int argc, const char * argv[]) &#123;<br>    @autoreleasepool &#123;<br>        NSTask *task = [[NSTask alloc] init];<br>        [task setLaunchPath:@&quot;/usr/bin/env&quot;];<br>        [task setArguments:@[@&quot;ls&quot;, @&quot;-l&quot;]];<br>        <br>        NSPipe *pipe = [NSPipe pipe];<br>        [task setStandardOutput:pipe];<br>        <br>        [task launch];<br>        [task waitUntilExit];<br>        <br>        NSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br>        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>        NSLog(@&quot;%@&quot;, output);<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，NSTask 用于运行 “ls -l” 命令，并将输出保存到一个 NSPipe 中。然后，我们读取管道中的数据并打印到控制台。</p>\n<h2 id=\"使用-system-函数\"><a href=\"#使用-system-函数\" class=\"headerlink\" title=\"使用 system() 函数\"></a>使用 system() 函数</h2><p>C++ 中有一个名为 system() 的函数，可以用于执行 Shell 命令。在 Objective-C++ 中，您也可以使用该函数。下面是一个示例代码片段：</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-type\">int</span> result = system(<span class=\"hljs-string\">&quot;ls -l&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span> (result != <span class=\"hljs-number\">0</span>) &#123;<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Command execution failed.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用-popen-函数\"><a href=\"#使用-popen-函数\" class=\"headerlink\" title=\"使用 popen() 函数\"></a>使用 popen() 函数</h2><p>popen() 函数可以用于执行 Shell 命令并获取输出。</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        FILE *pipe = popen(<span class=\"hljs-string\">&quot;ls -l&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span> (pipe == <span class=\"hljs-literal\">NULL</span>) &#123;<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Command execution failed.&quot;</span> &lt;&lt; std::endl;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125;<br>        <br>        <span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">128</span>];<br>        <span class=\"hljs-keyword\">while</span> (fgets(buffer, <span class=\"hljs-keyword\">sizeof</span>(buffer), pipe) != <span class=\"hljs-literal\">NULL</span>) &#123;<br>            std::cout &lt;&lt; buffer;<br>        &#125;<br>        <br>        pclose(pipe);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们使用 popen() 执行 “ls -l” 命令，并逐行读取输出并打印到控制台。</p>\n<h2 id=\"使用-NSTask-的便捷方法\"><a href=\"#使用-NSTask-的便捷方法\" class=\"headerlink\" title=\"使用 NSTask 的便捷方法\"></a>使用 NSTask 的便捷方法</h2><p>NSTask 类提供了一些便捷方法来执行 Shell 命令，而无需手动设置 launch path 和 arguments。</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSString</span> *output = [<span class=\"hljs-built_in\">NSString</span> stringWithContentsOfURL:[<span class=\"hljs-built_in\">NSURL</span> URLWithString:<span class=\"hljs-string\">@&quot;http://example.com&quot;</span>]<br>                                                    encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span><br>                                                       error:<span class=\"hljs-literal\">nil</span>];<br>        <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;%@&quot;</span>, output);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们使用 <code>[NSString stringWithContentsOfURL:encoding:error:]</code> 方法执行了 <code>curl http://example.com</code> 命令，并将输出保存在 NSString 对象中。</p>\n<ol start=\"5\">\n<li>使用 system() 或 popen() 的 C++ 封装：您可以将 system() 或 popen() 函数进行封装，以便更方便地在 Objective-C++ 中使用。例如，可以创建一个 C++ 函数来执行 Shell 命令，并返回结果。下面是一个示例代码片段：</li>\n</ol>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br>std::string executeShellCommand(<span class=\"hljs-keyword\">const</span> std::string &amp;command) &#123;<br>    <span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">128</span>];<br>    std::string result = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <br>    FILE *pipe = popen(command.c_str(), <span class=\"hljs-string\">&quot;r&quot;</span>);<br>    <span class=\"hljs-keyword\">if</span> (!pipe) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Command execution failed.&quot;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">while</span> (fgets(buffer, <span class=\"hljs-keyword\">sizeof</span>(buffer), pipe) != <span class=\"hljs-literal\">NULL</span>) &#123;<br>        result += buffer;<br>    &#125;<br>    <br>    pclose(pipe);<br>    <br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        std::string output = executeShellCommand(<span class=\"hljs-string\">&quot;ls -l&quot;</span>);<br>        std::cout &lt;&lt; output;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们定义了一个 <code>executeShellCommand()</code> 函数，它接受一个 Shell 命令，并返回执行结果。在 <code>main()</code> 函数中，我们调用该函数执行 “ls -l” 命令，并将输出打印到控制台。</p>\n<h2 id=\"使用-POSIX-的-fork-和-exec-函数\"><a href=\"#使用-POSIX-的-fork-和-exec-函数\" class=\"headerlink\" title=\"使用 POSIX 的 fork() 和 exec() 函数\"></a>使用 POSIX 的 fork() 和 exec() 函数</h2><p>Objective-C++ 可以直接使用 POSIX 的 fork() 和 exec() 函数来创建子进程并执行外部命令。下面是一个示例代码片段：</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        pid_t pid = fork();<br>        <br>        <span class=\"hljs-keyword\">if</span> (pid &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed to create child process.&quot;</span> &lt;&lt; std::endl;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pid == <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">// Child process</span><br>            execl(<span class=\"hljs-string\">&quot;/bin/ls&quot;</span>, <span class=\"hljs-string\">&quot;ls&quot;</span>, <span class=\"hljs-string\">&quot;-l&quot;</span>, <span class=\"hljs-literal\">NULL</span>);<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed to execute command.&quot;</span> &lt;&lt; std::endl;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// Parent process</span><br>            wait(<span class=\"hljs-literal\">NULL</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们通过调用 fork() 函数创建了一个子进程，并在子进程中调用 execl() 函数来执行 “ls -l” 命令。父进程通过调用 wait() 函数等待子进程的结束。</p>\n<h2 id=\"使用-NSTask-的便捷方法执行-Shell-脚本\"><a href=\"#使用-NSTask-的便捷方法执行-Shell-脚本\" class=\"headerlink\" title=\"使用 NSTask 的便捷方法执行 Shell 脚本\"></a>使用 NSTask 的便捷方法执行 Shell 脚本</h2><p>如果要执行复杂的 Shell 脚本，可以使用 NSTask 的便捷方法来执行脚本文件。下面是一个示例代码片段：</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSString</span> *scriptPath = [[<span class=\"hljs-built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"hljs-string\">@&quot;script.sh&quot;</span> ofType:<span class=\"hljs-literal\">nil</span>];<br>        <br>        <span class=\"hljs-built_in\">NSTask</span> *task = [[<span class=\"hljs-built_in\">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class=\"hljs-string\">@&quot;/bin/sh&quot;</span>];<br>        [task setArguments:@[scriptPath]];<br>        <br>        <span class=\"hljs-built_in\">NSPipe</span> *pipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>        [task setStandardOutput:pipe];<br>        <br>        [task launch];<br>        [task waitUntilExit];<br>        <br>        <span class=\"hljs-built_in\">NSData</span> *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br>        <span class=\"hljs-built_in\">NSString</span> *output = [[<span class=\"hljs-built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br>        <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;%@&quot;</span>, output);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们使用 NSTask 执行一个名为 “script.sh” 的 Shell 脚本文件，并将输出保存到一个 NSPipe 中。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objective-C-执行Shell\"><a href=\"#Objective-C-执行Shell\" class=\"headerlink\" title=\"Objective-C++执行Shell\"></a>Objective-C++执行Shell</h1><h2 id=\"使用-NSTask-类\"><a href=\"#使用-NSTask-类\" class=\"headerlink\" title=\"使用 NSTask 类\"></a>使用 NSTask 类</h2><p>NSTask 是一个 Objective-C 类，用于在 macOS 或 iOS 应用程序中执行外部命令。它可以创建一个子进程，并允许您设置命令、参数和环境变量。下面是一个示例代码片段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c\">#import &lt;Foundation/Foundation.h&gt;<br><br>int main(int argc, const char * argv[]) &#123;<br>    @autoreleasepool &#123;<br>        NSTask *task = [[NSTask alloc] init];<br>        [task setLaunchPath:@&quot;/usr/bin/env&quot;];<br>        [task setArguments:@[@&quot;ls&quot;, @&quot;-l&quot;]];<br>        <br>        NSPipe *pipe = [NSPipe pipe];<br>        [task setStandardOutput:pipe];<br>        <br>        [task launch];<br>        [task waitUntilExit];<br>        <br>        NSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br>        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>        NSLog(@&quot;%@&quot;, output);<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，NSTask 用于运行 “ls -l” 命令，并将输出保存到一个 NSPipe 中。然后，我们读取管道中的数据并打印到控制台。</p>\n<h2 id=\"使用-system-函数\"><a href=\"#使用-system-函数\" class=\"headerlink\" title=\"使用 system() 函数\"></a>使用 system() 函数</h2><p>C++ 中有一个名为 system() 的函数，可以用于执行 Shell 命令。在 Objective-C++ 中，您也可以使用该函数。下面是一个示例代码片段：</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-type\">int</span> result = system(<span class=\"hljs-string\">&quot;ls -l&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span> (result != <span class=\"hljs-number\">0</span>) &#123;<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Command execution failed.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用-popen-函数\"><a href=\"#使用-popen-函数\" class=\"headerlink\" title=\"使用 popen() 函数\"></a>使用 popen() 函数</h2><p>popen() 函数可以用于执行 Shell 命令并获取输出。</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        FILE *pipe = popen(<span class=\"hljs-string\">&quot;ls -l&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span> (pipe == <span class=\"hljs-literal\">NULL</span>) &#123;<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Command execution failed.&quot;</span> &lt;&lt; std::endl;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125;<br>        <br>        <span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">128</span>];<br>        <span class=\"hljs-keyword\">while</span> (fgets(buffer, <span class=\"hljs-keyword\">sizeof</span>(buffer), pipe) != <span class=\"hljs-literal\">NULL</span>) &#123;<br>            std::cout &lt;&lt; buffer;<br>        &#125;<br>        <br>        pclose(pipe);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们使用 popen() 执行 “ls -l” 命令，并逐行读取输出并打印到控制台。</p>\n<h2 id=\"使用-NSTask-的便捷方法\"><a href=\"#使用-NSTask-的便捷方法\" class=\"headerlink\" title=\"使用 NSTask 的便捷方法\"></a>使用 NSTask 的便捷方法</h2><p>NSTask 类提供了一些便捷方法来执行 Shell 命令，而无需手动设置 launch path 和 arguments。</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSString</span> *output = [<span class=\"hljs-built_in\">NSString</span> stringWithContentsOfURL:[<span class=\"hljs-built_in\">NSURL</span> URLWithString:<span class=\"hljs-string\">@&quot;http://example.com&quot;</span>]<br>                                                    encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span><br>                                                       error:<span class=\"hljs-literal\">nil</span>];<br>        <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;%@&quot;</span>, output);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们使用 <code>[NSString stringWithContentsOfURL:encoding:error:]</code> 方法执行了 <code>curl http://example.com</code> 命令，并将输出保存在 NSString 对象中。</p>\n<ol start=\"5\">\n<li>使用 system() 或 popen() 的 C++ 封装：您可以将 system() 或 popen() 函数进行封装，以便更方便地在 Objective-C++ 中使用。例如，可以创建一个 C++ 函数来执行 Shell 命令，并返回结果。下面是一个示例代码片段：</li>\n</ol>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br>std::string executeShellCommand(<span class=\"hljs-keyword\">const</span> std::string &amp;command) &#123;<br>    <span class=\"hljs-type\">char</span> buffer[<span class=\"hljs-number\">128</span>];<br>    std::string result = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <br>    FILE *pipe = popen(command.c_str(), <span class=\"hljs-string\">&quot;r&quot;</span>);<br>    <span class=\"hljs-keyword\">if</span> (!pipe) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Command execution failed.&quot;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">while</span> (fgets(buffer, <span class=\"hljs-keyword\">sizeof</span>(buffer), pipe) != <span class=\"hljs-literal\">NULL</span>) &#123;<br>        result += buffer;<br>    &#125;<br>    <br>    pclose(pipe);<br>    <br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        std::string output = executeShellCommand(<span class=\"hljs-string\">&quot;ls -l&quot;</span>);<br>        std::cout &lt;&lt; output;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们定义了一个 <code>executeShellCommand()</code> 函数，它接受一个 Shell 命令，并返回执行结果。在 <code>main()</code> 函数中，我们调用该函数执行 “ls -l” 命令，并将输出打印到控制台。</p>\n<h2 id=\"使用-POSIX-的-fork-和-exec-函数\"><a href=\"#使用-POSIX-的-fork-和-exec-函数\" class=\"headerlink\" title=\"使用 POSIX 的 fork() 和 exec() 函数\"></a>使用 POSIX 的 fork() 和 exec() 函数</h2><p>Objective-C++ 可以直接使用 POSIX 的 fork() 和 exec() 函数来创建子进程并执行外部命令。下面是一个示例代码片段：</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        pid_t pid = fork();<br>        <br>        <span class=\"hljs-keyword\">if</span> (pid &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed to create child process.&quot;</span> &lt;&lt; std::endl;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pid == <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">// Child process</span><br>            execl(<span class=\"hljs-string\">&quot;/bin/ls&quot;</span>, <span class=\"hljs-string\">&quot;ls&quot;</span>, <span class=\"hljs-string\">&quot;-l&quot;</span>, <span class=\"hljs-literal\">NULL</span>);<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed to execute command.&quot;</span> &lt;&lt; std::endl;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// Parent process</span><br>            wait(<span class=\"hljs-literal\">NULL</span>);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们通过调用 fork() 函数创建了一个子进程，并在子进程中调用 execl() 函数来执行 “ls -l” 命令。父进程通过调用 wait() 函数等待子进程的结束。</p>\n<h2 id=\"使用-NSTask-的便捷方法执行-Shell-脚本\"><a href=\"#使用-NSTask-的便捷方法执行-Shell-脚本\" class=\"headerlink\" title=\"使用 NSTask 的便捷方法执行 Shell 脚本\"></a>使用 NSTask 的便捷方法执行 Shell 脚本</h2><p>如果要执行复杂的 Shell 脚本，可以使用 NSTask 的便捷方法来执行脚本文件。下面是一个示例代码片段：</p>\n<figure class=\"highlight objective-c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objective-c++\"><span class=\"hljs-meta\">#import <span class=\"hljs-string\">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> main(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> * argv[]) &#123;<br>    <span class=\"hljs-keyword\">@autoreleasepool</span> &#123;<br>        <span class=\"hljs-built_in\">NSString</span> *scriptPath = [[<span class=\"hljs-built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"hljs-string\">@&quot;script.sh&quot;</span> ofType:<span class=\"hljs-literal\">nil</span>];<br>        <br>        <span class=\"hljs-built_in\">NSTask</span> *task = [[<span class=\"hljs-built_in\">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class=\"hljs-string\">@&quot;/bin/sh&quot;</span>];<br>        [task setArguments:@[scriptPath]];<br>        <br>        <span class=\"hljs-built_in\">NSPipe</span> *pipe = [<span class=\"hljs-built_in\">NSPipe</span> pipe];<br>        [task setStandardOutput:pipe];<br>        <br>        [task launch];<br>        [task waitUntilExit];<br>        <br>        <span class=\"hljs-built_in\">NSData</span> *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br>        <span class=\"hljs-built_in\">NSString</span> *output = [[<span class=\"hljs-built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"hljs-built_in\">NSUTF8StringEncoding</span>];<br>        <span class=\"hljs-built_in\">NSLog</span>(<span class=\"hljs-string\">@&quot;%@&quot;</span>, output);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码中，我们使用 NSTask 执行一个名为 “script.sh” 的 Shell 脚本文件，并将输出保存到一个 NSPipe 中。</p>\n"},{"title":"PHP执行Shell","date":"2023-09-13T13:23:24.000Z","author":"Grey-Wind","_content":"\n# PHP执行Shell\n\nPHP有多种执行Shell命令的方法，以下是其中一些常用(或能用)的方法：\n\n## exec函数\n\n```php\n$result = exec('shell command');\n```\n这会在Shell中执行指定的命令，并将结果保存在变量`$result`中。\n\n## shell_exec函数\n\n```php\n$result = shell_exec('shell command');\n```\n这与exec函数类似，但是会返回命令的完整输出结果。\n\n## system函数\n\n```php\nsystem('shell command', $return_value);\n```\n该函数将命令的输出直接打印到屏幕上，并将返回值存储在`$return_value`中。\n\n## passthru函数\n\n```php\npassthru('shell command');\n```\n该函数直接将命令的输出打印到屏幕上，而不会返回任何结果。\n\n是的，还有其他一些执行Shell命令的方法。以下是其中的一些：\n\n## popen函数\n\n```php\n$handle = popen('shell command', 'r');\n$result = fread($handle, 8192);\npclose($handle);\n```\n这个函数可以打开一个管道，并执行Shell命令。您可以使用`fread`函数读取命令的输出，并使用`pclose`函数关闭管道。\n\n## proc_open函数\n\n```php\n$descriptorspec = array(\n   0 => array(\"pipe\", \"r\"),  \n   1 => array(\"pipe\", \"w\"),  \n   2 => array(\"pipe\", \"w\")   \n);\n\n$process = proc_open('shell command', $descriptorspec, $pipes);\nif (is_resource($process)) {\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n}\n```\n这个函数可以打开一个进程，并执行Shell命令。您可以使用`stream_get_contents`函数读取标准输出和错误输出。\n\n## backtick操作符（反引号）\n\n```php\n$result = `shell command`;\n```\n在PHP中，您可以使用backtick操作符将Shell命令嵌入到字符串中，然后将其执行。执行结果将作为字符串返回给变量`$result`。可以使用`echo $result;`来输出结果。\n","source":"_posts/PHP执行Shell.md","raw":"---\ntitle: PHP执行Shell\ndate: 2023-09-13 21:23:24\nauthor: \"Grey-Wind\"\ncategories:\n- 各语言执行Shell\ntags:\n- 编程\n---\n\n# PHP执行Shell\n\nPHP有多种执行Shell命令的方法，以下是其中一些常用(或能用)的方法：\n\n## exec函数\n\n```php\n$result = exec('shell command');\n```\n这会在Shell中执行指定的命令，并将结果保存在变量`$result`中。\n\n## shell_exec函数\n\n```php\n$result = shell_exec('shell command');\n```\n这与exec函数类似，但是会返回命令的完整输出结果。\n\n## system函数\n\n```php\nsystem('shell command', $return_value);\n```\n该函数将命令的输出直接打印到屏幕上，并将返回值存储在`$return_value`中。\n\n## passthru函数\n\n```php\npassthru('shell command');\n```\n该函数直接将命令的输出打印到屏幕上，而不会返回任何结果。\n\n是的，还有其他一些执行Shell命令的方法。以下是其中的一些：\n\n## popen函数\n\n```php\n$handle = popen('shell command', 'r');\n$result = fread($handle, 8192);\npclose($handle);\n```\n这个函数可以打开一个管道，并执行Shell命令。您可以使用`fread`函数读取命令的输出，并使用`pclose`函数关闭管道。\n\n## proc_open函数\n\n```php\n$descriptorspec = array(\n   0 => array(\"pipe\", \"r\"),  \n   1 => array(\"pipe\", \"w\"),  \n   2 => array(\"pipe\", \"w\")   \n);\n\n$process = proc_open('shell command', $descriptorspec, $pipes);\nif (is_resource($process)) {\n    $output = stream_get_contents($pipes[1]);\n    fclose($pipes[1]);\n\n    $error = stream_get_contents($pipes[2]);\n    fclose($pipes[2]);\n\n    proc_close($process);\n}\n```\n这个函数可以打开一个进程，并执行Shell命令。您可以使用`stream_get_contents`函数读取标准输出和错误输出。\n\n## backtick操作符（反引号）\n\n```php\n$result = `shell command`;\n```\n在PHP中，您可以使用backtick操作符将Shell命令嵌入到字符串中，然后将其执行。执行结果将作为字符串返回给变量`$result`。可以使用`echo $result;`来输出结果。\n","slug":"PHP执行Shell","published":1,"updated":"2023-09-13T14:45:02.495Z","_id":"clmhsaq280000wg5gayll54zw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"PHP执行Shell\"><a href=\"#PHP执行Shell\" class=\"headerlink\" title=\"PHP执行Shell\"></a>PHP执行Shell</h1><p>PHP有多种执行Shell命令的方法，以下是其中一些常用(或能用)的方法：</p>\n<h2 id=\"exec函数\"><a href=\"#exec函数\" class=\"headerlink\" title=\"exec函数\"></a>exec函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$result</span> = <span class=\"hljs-title function_ invoke__\">exec</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>这会在Shell中执行指定的命令，并将结果保存在变量<code>$result</code>中。</p>\n<h2 id=\"shell-exec函数\"><a href=\"#shell-exec函数\" class=\"headerlink\" title=\"shell_exec函数\"></a>shell_exec函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$result</span> = <span class=\"hljs-title function_ invoke__\">shell_exec</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>这与exec函数类似，但是会返回命令的完整输出结果。</p>\n<h2 id=\"system函数\"><a href=\"#system函数\" class=\"headerlink\" title=\"system函数\"></a>system函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-title function_ invoke__\">system</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>, <span class=\"hljs-variable\">$return_value</span>);<br></code></pre></td></tr></table></figure>\n<p>该函数将命令的输出直接打印到屏幕上，并将返回值存储在<code>$return_value</code>中。</p>\n<h2 id=\"passthru函数\"><a href=\"#passthru函数\" class=\"headerlink\" title=\"passthru函数\"></a>passthru函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-title function_ invoke__\">passthru</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>该函数直接将命令的输出打印到屏幕上，而不会返回任何结果。</p>\n<p>是的，还有其他一些执行Shell命令的方法。以下是其中的一些：</p>\n<h2 id=\"popen函数\"><a href=\"#popen函数\" class=\"headerlink\" title=\"popen函数\"></a>popen函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$handle</span> = <span class=\"hljs-title function_ invoke__\">popen</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>, <span class=\"hljs-string\">&#x27;r&#x27;</span>);<br><span class=\"hljs-variable\">$result</span> = <span class=\"hljs-title function_ invoke__\">fread</span>(<span class=\"hljs-variable\">$handle</span>, <span class=\"hljs-number\">8192</span>);<br><span class=\"hljs-title function_ invoke__\">pclose</span>(<span class=\"hljs-variable\">$handle</span>);<br></code></pre></td></tr></table></figure>\n<p>这个函数可以打开一个管道，并执行Shell命令。您可以使用<code>fread</code>函数读取命令的输出，并使用<code>pclose</code>函数关闭管道。</p>\n<h2 id=\"proc-open函数\"><a href=\"#proc-open函数\" class=\"headerlink\" title=\"proc_open函数\"></a>proc_open函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$descriptorspec</span> = <span class=\"hljs-keyword\">array</span>(<br>   <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">&quot;pipe&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>),  <br>   <span class=\"hljs-number\">1</span> =&gt; <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">&quot;pipe&quot;</span>, <span class=\"hljs-string\">&quot;w&quot;</span>),  <br>   <span class=\"hljs-number\">2</span> =&gt; <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">&quot;pipe&quot;</span>, <span class=\"hljs-string\">&quot;w&quot;</span>)   <br>);<br><br><span class=\"hljs-variable\">$process</span> = <span class=\"hljs-title function_ invoke__\">proc_open</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>, <span class=\"hljs-variable\">$descriptorspec</span>, <span class=\"hljs-variable\">$pipes</span>);<br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_ invoke__\">is_resource</span>(<span class=\"hljs-variable\">$process</span>)) &#123;<br>    <span class=\"hljs-variable\">$output</span> = <span class=\"hljs-title function_ invoke__\">stream_get_contents</span>(<span class=\"hljs-variable\">$pipes</span>[<span class=\"hljs-number\">1</span>]);<br>    <span class=\"hljs-title function_ invoke__\">fclose</span>(<span class=\"hljs-variable\">$pipes</span>[<span class=\"hljs-number\">1</span>]);<br><br>    <span class=\"hljs-variable\">$error</span> = <span class=\"hljs-title function_ invoke__\">stream_get_contents</span>(<span class=\"hljs-variable\">$pipes</span>[<span class=\"hljs-number\">2</span>]);<br>    <span class=\"hljs-title function_ invoke__\">fclose</span>(<span class=\"hljs-variable\">$pipes</span>[<span class=\"hljs-number\">2</span>]);<br><br>    <span class=\"hljs-title function_ invoke__\">proc_close</span>(<span class=\"hljs-variable\">$process</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这个函数可以打开一个进程，并执行Shell命令。您可以使用<code>stream_get_contents</code>函数读取标准输出和错误输出。</p>\n<h2 id=\"backtick操作符（反引号）\"><a href=\"#backtick操作符（反引号）\" class=\"headerlink\" title=\"backtick操作符（反引号）\"></a>backtick操作符（反引号）</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$result</span> = `shell command`;<br></code></pre></td></tr></table></figure>\n<p>在PHP中，您可以使用backtick操作符将Shell命令嵌入到字符串中，然后将其执行。执行结果将作为字符串返回给变量<code>$result</code>。可以使用<code>echo $result;</code>来输出结果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"PHP执行Shell\"><a href=\"#PHP执行Shell\" class=\"headerlink\" title=\"PHP执行Shell\"></a>PHP执行Shell</h1><p>PHP有多种执行Shell命令的方法，以下是其中一些常用(或能用)的方法：</p>\n<h2 id=\"exec函数\"><a href=\"#exec函数\" class=\"headerlink\" title=\"exec函数\"></a>exec函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$result</span> = <span class=\"hljs-title function_ invoke__\">exec</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>这会在Shell中执行指定的命令，并将结果保存在变量<code>$result</code>中。</p>\n<h2 id=\"shell-exec函数\"><a href=\"#shell-exec函数\" class=\"headerlink\" title=\"shell_exec函数\"></a>shell_exec函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$result</span> = <span class=\"hljs-title function_ invoke__\">shell_exec</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>这与exec函数类似，但是会返回命令的完整输出结果。</p>\n<h2 id=\"system函数\"><a href=\"#system函数\" class=\"headerlink\" title=\"system函数\"></a>system函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-title function_ invoke__\">system</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>, <span class=\"hljs-variable\">$return_value</span>);<br></code></pre></td></tr></table></figure>\n<p>该函数将命令的输出直接打印到屏幕上，并将返回值存储在<code>$return_value</code>中。</p>\n<h2 id=\"passthru函数\"><a href=\"#passthru函数\" class=\"headerlink\" title=\"passthru函数\"></a>passthru函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-title function_ invoke__\">passthru</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>该函数直接将命令的输出打印到屏幕上，而不会返回任何结果。</p>\n<p>是的，还有其他一些执行Shell命令的方法。以下是其中的一些：</p>\n<h2 id=\"popen函数\"><a href=\"#popen函数\" class=\"headerlink\" title=\"popen函数\"></a>popen函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$handle</span> = <span class=\"hljs-title function_ invoke__\">popen</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>, <span class=\"hljs-string\">&#x27;r&#x27;</span>);<br><span class=\"hljs-variable\">$result</span> = <span class=\"hljs-title function_ invoke__\">fread</span>(<span class=\"hljs-variable\">$handle</span>, <span class=\"hljs-number\">8192</span>);<br><span class=\"hljs-title function_ invoke__\">pclose</span>(<span class=\"hljs-variable\">$handle</span>);<br></code></pre></td></tr></table></figure>\n<p>这个函数可以打开一个管道，并执行Shell命令。您可以使用<code>fread</code>函数读取命令的输出，并使用<code>pclose</code>函数关闭管道。</p>\n<h2 id=\"proc-open函数\"><a href=\"#proc-open函数\" class=\"headerlink\" title=\"proc_open函数\"></a>proc_open函数</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$descriptorspec</span> = <span class=\"hljs-keyword\">array</span>(<br>   <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">&quot;pipe&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>),  <br>   <span class=\"hljs-number\">1</span> =&gt; <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">&quot;pipe&quot;</span>, <span class=\"hljs-string\">&quot;w&quot;</span>),  <br>   <span class=\"hljs-number\">2</span> =&gt; <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">&quot;pipe&quot;</span>, <span class=\"hljs-string\">&quot;w&quot;</span>)   <br>);<br><br><span class=\"hljs-variable\">$process</span> = <span class=\"hljs-title function_ invoke__\">proc_open</span>(<span class=\"hljs-string\">&#x27;shell command&#x27;</span>, <span class=\"hljs-variable\">$descriptorspec</span>, <span class=\"hljs-variable\">$pipes</span>);<br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_ invoke__\">is_resource</span>(<span class=\"hljs-variable\">$process</span>)) &#123;<br>    <span class=\"hljs-variable\">$output</span> = <span class=\"hljs-title function_ invoke__\">stream_get_contents</span>(<span class=\"hljs-variable\">$pipes</span>[<span class=\"hljs-number\">1</span>]);<br>    <span class=\"hljs-title function_ invoke__\">fclose</span>(<span class=\"hljs-variable\">$pipes</span>[<span class=\"hljs-number\">1</span>]);<br><br>    <span class=\"hljs-variable\">$error</span> = <span class=\"hljs-title function_ invoke__\">stream_get_contents</span>(<span class=\"hljs-variable\">$pipes</span>[<span class=\"hljs-number\">2</span>]);<br>    <span class=\"hljs-title function_ invoke__\">fclose</span>(<span class=\"hljs-variable\">$pipes</span>[<span class=\"hljs-number\">2</span>]);<br><br>    <span class=\"hljs-title function_ invoke__\">proc_close</span>(<span class=\"hljs-variable\">$process</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这个函数可以打开一个进程，并执行Shell命令。您可以使用<code>stream_get_contents</code>函数读取标准输出和错误输出。</p>\n<h2 id=\"backtick操作符（反引号）\"><a href=\"#backtick操作符（反引号）\" class=\"headerlink\" title=\"backtick操作符（反引号）\"></a>backtick操作符（反引号）</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$result</span> = `shell command`;<br></code></pre></td></tr></table></figure>\n<p>在PHP中，您可以使用backtick操作符将Shell命令嵌入到字符串中，然后将其执行。执行结果将作为字符串返回给变量<code>$result</code>。可以使用<code>echo $result;</code>来输出结果。</p>\n"},{"title":"C# WPF(.NET Framework)窗口使用HTML页面","date":"2023-09-13T13:42:58.000Z","author":"Grey-Wind","_content":"\n# C# WPF(.NET Framework)窗口使用HTML页面\n\n由于`Awesomium`和`DotNetBrowser`目前都已经停止更新并不再推荐使用，所以我并没有写相关教程。\n\n然后呢，我个人不喜欢`.Net Core`，所以`WebView`也没写，单纯个人喜好问题，以后想要用了再写吧。\n\n## WebBrowser\n\n首先，在XAML文件中添加一个`WebBrowser`控件：\n\n```xaml\n<Window x:Class=\"MyApp.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"HTML嵌入示例\" Height=\"450\" Width=\"800\">\n    <Grid>\n        <WebBrowser x:Name=\"webBrowser\" />\n    </Grid>\n</Window>\n```\n\n### 代码嵌入式\n\n在后台代码中加载HTML内容：\n\n```csharp\nusing System;\nusing System.Windows;\n\nnamespace MyApp\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            // 在窗口加载时加载HTML\n            Loaded += MainWindow_Loaded;\n        }\n\n        private void MainWindow_Loaded(object sender, RoutedEventArgs e)\n        {\n            // 加载HTML内容\n            webBrowser.NavigateToString(\"<html><body><h1>Hello, World!</h1></body></html>\");\n        }\n    }\n}\n```\n\n此示例在窗口加载时将显示一个包含标题 \"Hello, World!\" 的HTML页面。\n\n### 外部文件绝对路径式\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Windows;\nusing System.Windows.Controls;\n\nnamespace WebBrowserExample\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        private void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            string filePath = @\"C:\\path\\to\\your\\html\\file.html\";\n\n            if (File.Exists(filePath))\n            {\n                webBrowser.Navigate(new Uri(filePath));\n            }\n            else\n            {\n                MessageBox.Show(\"指定的文件不存在！\");\n            }\n        }\n    }\n}\n```\n\n在上面的示例中，我们假设你有一个 `MainWindow`（主窗口）并添加了一个名为 `webBrowser` 的 `WebBrowser` 控件。在窗口的 `Loaded` 事件中，我们指定了要加载的 HTML 文件的绝对路径。\n\n### 外部文件相对路径式\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Windows;\nusing System.Windows.Controls;\n\nnamespace WebBrowserExample\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        private void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            string currentDirectory = Directory.GetCurrentDirectory();\n            string relativePath = \"your/html/file.html\";\n            string absolutePath = Path.Combine(currentDirectory, relativePath);\n\n            if (File.Exists(absolutePath))\n            {\n                webBrowser.Navigate(new Uri(absolutePath));\n            }\n            else\n            {\n                MessageBox.Show(\"指定的文件不存在！\");\n            }\n        }\n    }\n}\n```\n\n在上述示例中，我们假设你有一个 `MainWindow`（主窗口）并添加了一个名为 `webBrowser` 的 `WebBrowser` 控件。在窗口的 `Loaded` 事件中，我们首先获取当前目录的路径 `currentDirectory`，然后将其与相对路径 `relativePath` 合并为绝对路径 `absolutePath`。\n\n最后，我们检查文件是否存在，如果文件存在，就使用 `WebBrowser` 控件的 `Navigate` 方法加载该文件；如果文件不存在，则弹出一个消息框提示文件不存在。\n\n### 直接加载(无C#代码)\n\n填写窗口XAML文件`WebBrowser`中的`Address`。\n\n例如：\n\n```xml\n<WebBrowser x:Name=\"webBrowser\" Address=\"https://sunrise-studio.gitee.io/\" />\n```\n\n简单吧，但是不方便修改，这个只适合最简单基础的。\n\n## CefSharp\n\n在MainWindow.xaml文件中添加一个WebBrowser控件：\n\n```xml\n<Window x:Class=\"CefSharpDemo.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:cefSharp=\"clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf\"\n        Title=\"CefSharp Demo\" Height=\"350\" Width=\"525\">\n    <Grid>\n        <cefSharp:ChromiumWebBrowser x:Name=\"webBrowser\" Address=\"about:blank\" />\n    </Grid>\n</Window>\n```\n\n### 代码嵌入式\n\n```csharp\nusing System.Windows;\nusing CefSharp;\nusing CefSharp.Wpf;\n\nnamespace CefSharpDemo\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n            InitializeCefSharp();\n            webBrowser.Loaded += WebBrowser_Loaded;\n        }\n\n        private void InitializeCefSharp()\n        {\n            var settings = new CefSettings();\n            Cef.Initialize(settings);\n        }\n\n        private void WebBrowser_Loaded(object sender, RoutedEventArgs e)\n        {\n            string html = @\"<html><body><h1>Hello, World!</h1></body></html>\";\n            webBrowser.LoadHtml(html, \"https://localhost\");\n        }\n        \n        protected override void OnClosed(System.EventArgs e)\n        {\n            base.OnClosed(e);\n            Cef.Shutdown();\n        }\n    }\n}\n```\n\n在构造函数中，我们初始化了CefSharp引擎，并将`webBrowser.Loaded`事件处理器指向了`WebBrowser_Loaded`方法。这样，当`webBrowser`控件加载完成时，会触发该事件，然后在`WebBrowser_Loaded`方法中加载HTML内容。\n\n注意，在`WebBrowser_Loaded`方法中，我们将HTML代码赋值给`html`变量，然后通过`webBrowser.LoadHtml`方法加载到`webBrowser`控件中。\n\n现在，当启动此WPF应用程序时，它将在窗口加载完成后加载并显示`Hello, World!`的HTML内容。\n\n### 外部文件绝对路径式\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Windows;\nusing CefSharp;\nusing CefSharp.Wpf;\n\nnamespace CefSharpDemo\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n            InitializeCefSharp();\n\n            Loaded += MainWindow_Loaded;\n            Closed += MainWindow_Closed;\n        }\n\n        private void InitializeCefSharp()\n        {\n            var settings = new CefSettings();\n            Cef.Initialize(settings);\n        }\n\n        private void MainWindow_Loaded(object sender, RoutedEventArgs e)\n        {\n            string htmlFilePath = @\"C:\\path\\to\\your\\html\\file.html\";\n            LoadHtmlFromFile(htmlFilePath);\n        }\n\n        private void LoadHtmlFromFile(string filePath)\n        {\n            try\n            {\n                string htmlContent = File.ReadAllText(filePath);\n                webBrowser.LoadHtml(htmlContent, \"https://localhost\");\n            }\n            catch (Exception ex)\n            {\n                // 处理加载错误\n                MessageBox.Show($\"Failed to load HTML file: {ex.Message}\");\n            }\n        }\n\n        private void MainWindow_Closed(object sender, EventArgs e)\n        {\n            Cef.Shutdown();\n        }\n    }\n}\n```\n\n在这个简化的示例中，我们假设要加载的HTML文件位于本地磁盘上的绝对路径`C:\\path\\to\\your\\html\\file.html`。在`MainWindow_Loaded`方法中，我们调用`LoadHtmlFromFile`方法，并将HTML文件的路径作为参数传递给它。\n\n`LoadHtmlFromFile`方法读取指定路径的HTML文件内容，并使用`webBrowser.LoadHtml`方法将内容加载到`webBrowser`控件中。如果加载过程中出现错误，我们通过一个简单的消息框显示错误信息。\n\n在窗口关闭时，我们调用`Cef.Shutdown`方法来关闭CefSharp引擎。\n\n### 外部文件相对路径式\n\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Reflection;\nusing System.Windows;\nusing CefSharp;\nusing CefSharp.Wpf;\n\nnamespace CefSharpDemo\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n            InitializeCefSharp();\n\n            Loaded += MainWindow_Loaded;\n            Closed += MainWindow_Closed;\n        }\n\n        private void InitializeCefSharp()\n        {\n            var settings = new CefSettings();\n            Cef.Initialize(settings);\n        }\n\n        private void MainWindow_Loaded(object sender, RoutedEventArgs e)\n        {\n            string htmlFilePath = GetHtmlFilePath(\"file.html\");\n            LoadHtmlFromFile(htmlFilePath);\n        }\n\n        private string GetHtmlFilePath(string fileName)\n        {\n            //获取当前应用程序目录的路径\n            string currentPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase).Replace(@\"file:\\\", \"\");\n            //获取HTML文件的绝对路径\n            string htmlFilePath = Path.Combine(currentPath, fileName);\n            return htmlFilePath;\n        }\n\n        private void LoadHtmlFromFile(string filePath)\n        {\n            try\n            {\n                string htmlContent = File.ReadAllText(filePath);\n                webBrowser.LoadHtml(htmlContent, \"https://localhost\");\n            }\n            catch (Exception ex)\n            {\n                // 处理加载错误\n                MessageBox.Show($\"Failed to load HTML file: {ex.Message}\");\n            }\n        }\n\n        private void MainWindow_Closed(object sender, EventArgs e)\n        {\n            Cef.Shutdown();\n        }\n    }\n}\n```\n\n这个简化的示例中，我们将要加载HTML文件放在程序的根目录下，并命名为`file.html`。在`MainWindow_Loaded`方法中，我们调用了`GetHtmlFilePath`方法，并将HTML文件名作为参数传递给它。\n\n`GetHtmlFilePath`方法首先获取当前应用程序目录的路径，然后使用`Path.Combine`方法将HTML文件名与应用程序目录组合成完整路径，并返回该路径。\n\n随后，我们调用`LoadHtmlFromFile`方法，并将HTML文件的完整路径作为参数传递给它。该方法读取指定路径的HTML文件内容，并使用`webBrowser.LoadHtml`方法将内容加载到`webBrowser`控件中。\n\n如果加载过程中出现错误，我们通过一个简单的消息框显示错误信息。\n\n在窗口关闭时，我们调用`Cef.Shutdown`方法来关闭CefSharp引擎。\n\n请注意，我们使用了`Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase)`方法来获取当前目录的路径，而不是`Environment.CurrentDirectory`。这是因为当应用程序启动时，`Environment.CurrentDirectory`可能不是期望的路径。当然，如果你不在意的话，用`Environment.CurrentDirectory`也是可以的\n\n### 直接加载(无C#代码)\n\n填写窗口XAML文件`cefSharp`中的`Address`。\n\n例如：\n\n```xml\n<cefSharp:ChromiumWebBrowser x:Name=\"webBrowser\" Address=\"https://sunrise-studio.gitee.io/\" />\n```\n\n简单吧，但是不方便修改，这个只适合最简单基础的。\n","source":"_posts/C-WPF-NET-Framework-窗口使用HTML页面.md","raw":"---\ntitle: C# WPF(.NET Framework)窗口使用HTML页面\ndate: 2023-09-13 21:42:58\nauthor: \"Grey-Wind\"\ntags:\n- 编程\n- C-Sharp\n- HTML\n---\n\n# C# WPF(.NET Framework)窗口使用HTML页面\n\n由于`Awesomium`和`DotNetBrowser`目前都已经停止更新并不再推荐使用，所以我并没有写相关教程。\n\n然后呢，我个人不喜欢`.Net Core`，所以`WebView`也没写，单纯个人喜好问题，以后想要用了再写吧。\n\n## WebBrowser\n\n首先，在XAML文件中添加一个`WebBrowser`控件：\n\n```xaml\n<Window x:Class=\"MyApp.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"HTML嵌入示例\" Height=\"450\" Width=\"800\">\n    <Grid>\n        <WebBrowser x:Name=\"webBrowser\" />\n    </Grid>\n</Window>\n```\n\n### 代码嵌入式\n\n在后台代码中加载HTML内容：\n\n```csharp\nusing System;\nusing System.Windows;\n\nnamespace MyApp\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            // 在窗口加载时加载HTML\n            Loaded += MainWindow_Loaded;\n        }\n\n        private void MainWindow_Loaded(object sender, RoutedEventArgs e)\n        {\n            // 加载HTML内容\n            webBrowser.NavigateToString(\"<html><body><h1>Hello, World!</h1></body></html>\");\n        }\n    }\n}\n```\n\n此示例在窗口加载时将显示一个包含标题 \"Hello, World!\" 的HTML页面。\n\n### 外部文件绝对路径式\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Windows;\nusing System.Windows.Controls;\n\nnamespace WebBrowserExample\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        private void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            string filePath = @\"C:\\path\\to\\your\\html\\file.html\";\n\n            if (File.Exists(filePath))\n            {\n                webBrowser.Navigate(new Uri(filePath));\n            }\n            else\n            {\n                MessageBox.Show(\"指定的文件不存在！\");\n            }\n        }\n    }\n}\n```\n\n在上面的示例中，我们假设你有一个 `MainWindow`（主窗口）并添加了一个名为 `webBrowser` 的 `WebBrowser` 控件。在窗口的 `Loaded` 事件中，我们指定了要加载的 HTML 文件的绝对路径。\n\n### 外部文件相对路径式\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Windows;\nusing System.Windows.Controls;\n\nnamespace WebBrowserExample\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        private void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            string currentDirectory = Directory.GetCurrentDirectory();\n            string relativePath = \"your/html/file.html\";\n            string absolutePath = Path.Combine(currentDirectory, relativePath);\n\n            if (File.Exists(absolutePath))\n            {\n                webBrowser.Navigate(new Uri(absolutePath));\n            }\n            else\n            {\n                MessageBox.Show(\"指定的文件不存在！\");\n            }\n        }\n    }\n}\n```\n\n在上述示例中，我们假设你有一个 `MainWindow`（主窗口）并添加了一个名为 `webBrowser` 的 `WebBrowser` 控件。在窗口的 `Loaded` 事件中，我们首先获取当前目录的路径 `currentDirectory`，然后将其与相对路径 `relativePath` 合并为绝对路径 `absolutePath`。\n\n最后，我们检查文件是否存在，如果文件存在，就使用 `WebBrowser` 控件的 `Navigate` 方法加载该文件；如果文件不存在，则弹出一个消息框提示文件不存在。\n\n### 直接加载(无C#代码)\n\n填写窗口XAML文件`WebBrowser`中的`Address`。\n\n例如：\n\n```xml\n<WebBrowser x:Name=\"webBrowser\" Address=\"https://sunrise-studio.gitee.io/\" />\n```\n\n简单吧，但是不方便修改，这个只适合最简单基础的。\n\n## CefSharp\n\n在MainWindow.xaml文件中添加一个WebBrowser控件：\n\n```xml\n<Window x:Class=\"CefSharpDemo.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:cefSharp=\"clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf\"\n        Title=\"CefSharp Demo\" Height=\"350\" Width=\"525\">\n    <Grid>\n        <cefSharp:ChromiumWebBrowser x:Name=\"webBrowser\" Address=\"about:blank\" />\n    </Grid>\n</Window>\n```\n\n### 代码嵌入式\n\n```csharp\nusing System.Windows;\nusing CefSharp;\nusing CefSharp.Wpf;\n\nnamespace CefSharpDemo\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n            InitializeCefSharp();\n            webBrowser.Loaded += WebBrowser_Loaded;\n        }\n\n        private void InitializeCefSharp()\n        {\n            var settings = new CefSettings();\n            Cef.Initialize(settings);\n        }\n\n        private void WebBrowser_Loaded(object sender, RoutedEventArgs e)\n        {\n            string html = @\"<html><body><h1>Hello, World!</h1></body></html>\";\n            webBrowser.LoadHtml(html, \"https://localhost\");\n        }\n        \n        protected override void OnClosed(System.EventArgs e)\n        {\n            base.OnClosed(e);\n            Cef.Shutdown();\n        }\n    }\n}\n```\n\n在构造函数中，我们初始化了CefSharp引擎，并将`webBrowser.Loaded`事件处理器指向了`WebBrowser_Loaded`方法。这样，当`webBrowser`控件加载完成时，会触发该事件，然后在`WebBrowser_Loaded`方法中加载HTML内容。\n\n注意，在`WebBrowser_Loaded`方法中，我们将HTML代码赋值给`html`变量，然后通过`webBrowser.LoadHtml`方法加载到`webBrowser`控件中。\n\n现在，当启动此WPF应用程序时，它将在窗口加载完成后加载并显示`Hello, World!`的HTML内容。\n\n### 外部文件绝对路径式\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Windows;\nusing CefSharp;\nusing CefSharp.Wpf;\n\nnamespace CefSharpDemo\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n            InitializeCefSharp();\n\n            Loaded += MainWindow_Loaded;\n            Closed += MainWindow_Closed;\n        }\n\n        private void InitializeCefSharp()\n        {\n            var settings = new CefSettings();\n            Cef.Initialize(settings);\n        }\n\n        private void MainWindow_Loaded(object sender, RoutedEventArgs e)\n        {\n            string htmlFilePath = @\"C:\\path\\to\\your\\html\\file.html\";\n            LoadHtmlFromFile(htmlFilePath);\n        }\n\n        private void LoadHtmlFromFile(string filePath)\n        {\n            try\n            {\n                string htmlContent = File.ReadAllText(filePath);\n                webBrowser.LoadHtml(htmlContent, \"https://localhost\");\n            }\n            catch (Exception ex)\n            {\n                // 处理加载错误\n                MessageBox.Show($\"Failed to load HTML file: {ex.Message}\");\n            }\n        }\n\n        private void MainWindow_Closed(object sender, EventArgs e)\n        {\n            Cef.Shutdown();\n        }\n    }\n}\n```\n\n在这个简化的示例中，我们假设要加载的HTML文件位于本地磁盘上的绝对路径`C:\\path\\to\\your\\html\\file.html`。在`MainWindow_Loaded`方法中，我们调用`LoadHtmlFromFile`方法，并将HTML文件的路径作为参数传递给它。\n\n`LoadHtmlFromFile`方法读取指定路径的HTML文件内容，并使用`webBrowser.LoadHtml`方法将内容加载到`webBrowser`控件中。如果加载过程中出现错误，我们通过一个简单的消息框显示错误信息。\n\n在窗口关闭时，我们调用`Cef.Shutdown`方法来关闭CefSharp引擎。\n\n### 外部文件相对路径式\n\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Reflection;\nusing System.Windows;\nusing CefSharp;\nusing CefSharp.Wpf;\n\nnamespace CefSharpDemo\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n            InitializeCefSharp();\n\n            Loaded += MainWindow_Loaded;\n            Closed += MainWindow_Closed;\n        }\n\n        private void InitializeCefSharp()\n        {\n            var settings = new CefSettings();\n            Cef.Initialize(settings);\n        }\n\n        private void MainWindow_Loaded(object sender, RoutedEventArgs e)\n        {\n            string htmlFilePath = GetHtmlFilePath(\"file.html\");\n            LoadHtmlFromFile(htmlFilePath);\n        }\n\n        private string GetHtmlFilePath(string fileName)\n        {\n            //获取当前应用程序目录的路径\n            string currentPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase).Replace(@\"file:\\\", \"\");\n            //获取HTML文件的绝对路径\n            string htmlFilePath = Path.Combine(currentPath, fileName);\n            return htmlFilePath;\n        }\n\n        private void LoadHtmlFromFile(string filePath)\n        {\n            try\n            {\n                string htmlContent = File.ReadAllText(filePath);\n                webBrowser.LoadHtml(htmlContent, \"https://localhost\");\n            }\n            catch (Exception ex)\n            {\n                // 处理加载错误\n                MessageBox.Show($\"Failed to load HTML file: {ex.Message}\");\n            }\n        }\n\n        private void MainWindow_Closed(object sender, EventArgs e)\n        {\n            Cef.Shutdown();\n        }\n    }\n}\n```\n\n这个简化的示例中，我们将要加载HTML文件放在程序的根目录下，并命名为`file.html`。在`MainWindow_Loaded`方法中，我们调用了`GetHtmlFilePath`方法，并将HTML文件名作为参数传递给它。\n\n`GetHtmlFilePath`方法首先获取当前应用程序目录的路径，然后使用`Path.Combine`方法将HTML文件名与应用程序目录组合成完整路径，并返回该路径。\n\n随后，我们调用`LoadHtmlFromFile`方法，并将HTML文件的完整路径作为参数传递给它。该方法读取指定路径的HTML文件内容，并使用`webBrowser.LoadHtml`方法将内容加载到`webBrowser`控件中。\n\n如果加载过程中出现错误，我们通过一个简单的消息框显示错误信息。\n\n在窗口关闭时，我们调用`Cef.Shutdown`方法来关闭CefSharp引擎。\n\n请注意，我们使用了`Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase)`方法来获取当前目录的路径，而不是`Environment.CurrentDirectory`。这是因为当应用程序启动时，`Environment.CurrentDirectory`可能不是期望的路径。当然，如果你不在意的话，用`Environment.CurrentDirectory`也是可以的\n\n### 直接加载(无C#代码)\n\n填写窗口XAML文件`cefSharp`中的`Address`。\n\n例如：\n\n```xml\n<cefSharp:ChromiumWebBrowser x:Name=\"webBrowser\" Address=\"https://sunrise-studio.gitee.io/\" />\n```\n\n简单吧，但是不方便修改，这个只适合最简单基础的。\n","slug":"C-WPF-NET-Framework-窗口使用HTML页面","published":1,"updated":"2023-09-13T14:44:41.862Z","_id":"clmhtkqd80000ug5ghqom7hi4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"C-WPF-NET-Framework-窗口使用HTML页面\"><a href=\"#C-WPF-NET-Framework-窗口使用HTML页面\" class=\"headerlink\" title=\"C# WPF(.NET Framework)窗口使用HTML页面\"></a>C# WPF(.NET Framework)窗口使用HTML页面</h1><p>由于<code>Awesomium</code>和<code>DotNetBrowser</code>目前都已经停止更新并不再推荐使用，所以我并没有写相关教程。</p>\n<p>然后呢，我个人不喜欢<code>.Net Core</code>，所以<code>WebView</code>也没写，单纯个人喜好问题，以后想要用了再写吧。</p>\n<h2 id=\"WebBrowser\"><a href=\"#WebBrowser\" class=\"headerlink\" title=\"WebBrowser\"></a>WebBrowser</h2><p>首先，在XAML文件中添加一个<code>WebBrowser</code>控件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xaml\">&lt;Window x:Class=&quot;MyApp.MainWindow&quot;<br>        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;<br>        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;<br>        Title=&quot;HTML嵌入示例&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt;<br>    &lt;Grid&gt;<br>        &lt;WebBrowser x:Name=&quot;webBrowser&quot; /&gt;<br>    &lt;/Grid&gt;<br>&lt;/Window&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"代码嵌入式\"><a href=\"#代码嵌入式\" class=\"headerlink\" title=\"代码嵌入式\"></a>代码嵌入式</h3><p>在后台代码中加载HTML内容：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">MyApp</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br><br>            <span class=\"hljs-comment\">// 在窗口加载时加载HTML</span><br>            Loaded += MainWindow_Loaded;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-comment\">// 加载HTML内容</span><br>            webBrowser.NavigateToString(<span class=\"hljs-string\">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>此示例在窗口加载时将显示一个包含标题 “Hello, World!” 的HTML页面。</p>\n<h3 id=\"外部文件绝对路径式\"><a href=\"#外部文件绝对路径式\" class=\"headerlink\" title=\"外部文件绝对路径式\"></a>外部文件绝对路径式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.IO;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> System.Windows.Controls;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">WebBrowserExample</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Window_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> filePath = <span class=\"hljs-string\">@&quot;C:\\path\\to\\your\\html\\file.html&quot;</span>;<br><br>            <span class=\"hljs-keyword\">if</span> (File.Exists(filePath))<br>            &#123;<br>                webBrowser.Navigate(<span class=\"hljs-keyword\">new</span> Uri(filePath));<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span><br>            &#123;<br>                MessageBox.Show(<span class=\"hljs-string\">&quot;指定的文件不存在！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的示例中，我们假设你有一个 <code>MainWindow</code>（主窗口）并添加了一个名为 <code>webBrowser</code> 的 <code>WebBrowser</code> 控件。在窗口的 <code>Loaded</code> 事件中，我们指定了要加载的 HTML 文件的绝对路径。</p>\n<h3 id=\"外部文件相对路径式\"><a href=\"#外部文件相对路径式\" class=\"headerlink\" title=\"外部文件相对路径式\"></a>外部文件相对路径式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.IO;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> System.Windows.Controls;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">WebBrowserExample</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Window_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> currentDirectory = Directory.GetCurrentDirectory();<br>            <span class=\"hljs-built_in\">string</span> relativePath = <span class=\"hljs-string\">&quot;your/html/file.html&quot;</span>;<br>            <span class=\"hljs-built_in\">string</span> absolutePath = Path.Combine(currentDirectory, relativePath);<br><br>            <span class=\"hljs-keyword\">if</span> (File.Exists(absolutePath))<br>            &#123;<br>                webBrowser.Navigate(<span class=\"hljs-keyword\">new</span> Uri(absolutePath));<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span><br>            &#123;<br>                MessageBox.Show(<span class=\"hljs-string\">&quot;指定的文件不存在！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们假设你有一个 <code>MainWindow</code>（主窗口）并添加了一个名为 <code>webBrowser</code> 的 <code>WebBrowser</code> 控件。在窗口的 <code>Loaded</code> 事件中，我们首先获取当前目录的路径 <code>currentDirectory</code>，然后将其与相对路径 <code>relativePath</code> 合并为绝对路径 <code>absolutePath</code>。</p>\n<p>最后，我们检查文件是否存在，如果文件存在，就使用 <code>WebBrowser</code> 控件的 <code>Navigate</code> 方法加载该文件；如果文件不存在，则弹出一个消息框提示文件不存在。</p>\n<h3 id=\"直接加载-无C-代码\"><a href=\"#直接加载-无C-代码\" class=\"headerlink\" title=\"直接加载(无C#代码)\"></a>直接加载(无C#代码)</h3><p>填写窗口XAML文件<code>WebBrowser</code>中的<code>Address</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WebBrowser</span> <span class=\"hljs-attr\">x:Name</span>=<span class=\"hljs-string\">&quot;webBrowser&quot;</span> <span class=\"hljs-attr\">Address</span>=<span class=\"hljs-string\">&quot;https://sunrise-studio.gitee.io/&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>简单吧，但是不方便修改，这个只适合最简单基础的。</p>\n<h2 id=\"CefSharp\"><a href=\"#CefSharp\" class=\"headerlink\" title=\"CefSharp\"></a>CefSharp</h2><p>在MainWindow.xaml文件中添加一个WebBrowser控件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Window</span> <span class=\"hljs-attr\">x:Class</span>=<span class=\"hljs-string\">&quot;CefSharpDemo.MainWindow&quot;</span></span><br><span class=\"hljs-tag\">        <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class=\"hljs-tag\">        <span class=\"hljs-attr\">xmlns:x</span>=<span class=\"hljs-string\">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class=\"hljs-tag\">        <span class=\"hljs-attr\">xmlns:cefSharp</span>=<span class=\"hljs-string\">&quot;clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf&quot;</span></span><br><span class=\"hljs-tag\">        <span class=\"hljs-attr\">Title</span>=<span class=\"hljs-string\">&quot;CefSharp Demo&quot;</span> <span class=\"hljs-attr\">Height</span>=<span class=\"hljs-string\">&quot;350&quot;</span> <span class=\"hljs-attr\">Width</span>=<span class=\"hljs-string\">&quot;525&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Grid</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cefSharp:ChromiumWebBrowser</span> <span class=\"hljs-attr\">x:Name</span>=<span class=\"hljs-string\">&quot;webBrowser&quot;</span> <span class=\"hljs-attr\">Address</span>=<span class=\"hljs-string\">&quot;about:blank&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Grid</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Window</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"代码嵌入式-1\"><a href=\"#代码嵌入式-1\" class=\"headerlink\" title=\"代码嵌入式\"></a>代码嵌入式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> CefSharp;<br><span class=\"hljs-keyword\">using</span> CefSharp.Wpf;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">CefSharpDemo</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>            InitializeCefSharp();<br>            webBrowser.Loaded += WebBrowser_Loaded;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitializeCefSharp</span>()</span><br>        &#123;<br>            <span class=\"hljs-keyword\">var</span> settings = <span class=\"hljs-keyword\">new</span> CefSettings();<br>            Cef.Initialize(settings);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">WebBrowser_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> html = <span class=\"hljs-string\">@&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;<br>            webBrowser.LoadHtml(html, <span class=\"hljs-string\">&quot;https://localhost&quot;</span>);<br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">OnClosed</span>(<span class=\"hljs-params\">System.EventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-keyword\">base</span>.OnClosed(e);<br>            Cef.Shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在构造函数中，我们初始化了CefSharp引擎，并将<code>webBrowser.Loaded</code>事件处理器指向了<code>WebBrowser_Loaded</code>方法。这样，当<code>webBrowser</code>控件加载完成时，会触发该事件，然后在<code>WebBrowser_Loaded</code>方法中加载HTML内容。</p>\n<p>注意，在<code>WebBrowser_Loaded</code>方法中，我们将HTML代码赋值给<code>html</code>变量，然后通过<code>webBrowser.LoadHtml</code>方法加载到<code>webBrowser</code>控件中。</p>\n<p>现在，当启动此WPF应用程序时，它将在窗口加载完成后加载并显示<code>Hello, World!</code>的HTML内容。</p>\n<h3 id=\"外部文件绝对路径式-1\"><a href=\"#外部文件绝对路径式-1\" class=\"headerlink\" title=\"外部文件绝对路径式\"></a>外部文件绝对路径式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.IO;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> CefSharp;<br><span class=\"hljs-keyword\">using</span> CefSharp.Wpf;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">CefSharpDemo</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>            InitializeCefSharp();<br><br>            Loaded += MainWindow_Loaded;<br>            Closed += MainWindow_Closed;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitializeCefSharp</span>()</span><br>        &#123;<br>            <span class=\"hljs-keyword\">var</span> settings = <span class=\"hljs-keyword\">new</span> CefSettings();<br>            Cef.Initialize(settings);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> htmlFilePath = <span class=\"hljs-string\">@&quot;C:\\path\\to\\your\\html\\file.html&quot;</span>;<br>            LoadHtmlFromFile(htmlFilePath);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadHtmlFromFile</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> filePath</span>)</span><br>        &#123;<br>            <span class=\"hljs-keyword\">try</span><br>            &#123;<br>                <span class=\"hljs-built_in\">string</span> htmlContent = File.ReadAllText(filePath);<br>                webBrowser.LoadHtml(htmlContent, <span class=\"hljs-string\">&quot;https://localhost&quot;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">catch</span> (Exception ex)<br>            &#123;<br>                <span class=\"hljs-comment\">// 处理加载错误</span><br>                MessageBox.Show(<span class=\"hljs-string\">$&quot;Failed to load HTML file: <span class=\"hljs-subst\">&#123;ex.Message&#125;</span>&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Closed</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            Cef.Shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个简化的示例中，我们假设要加载的HTML文件位于本地磁盘上的绝对路径<code>C:\\path\\to\\your\\html\\file.html</code>。在<code>MainWindow_Loaded</code>方法中，我们调用<code>LoadHtmlFromFile</code>方法，并将HTML文件的路径作为参数传递给它。</p>\n<p><code>LoadHtmlFromFile</code>方法读取指定路径的HTML文件内容，并使用<code>webBrowser.LoadHtml</code>方法将内容加载到<code>webBrowser</code>控件中。如果加载过程中出现错误，我们通过一个简单的消息框显示错误信息。</p>\n<p>在窗口关闭时，我们调用<code>Cef.Shutdown</code>方法来关闭CefSharp引擎。</p>\n<h3 id=\"外部文件相对路径式-1\"><a href=\"#外部文件相对路径式-1\" class=\"headerlink\" title=\"外部文件相对路径式\"></a>外部文件相对路径式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.IO;<br><span class=\"hljs-keyword\">using</span> System.Reflection;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> CefSharp;<br><span class=\"hljs-keyword\">using</span> CefSharp.Wpf;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">CefSharpDemo</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>            InitializeCefSharp();<br><br>            Loaded += MainWindow_Loaded;<br>            Closed += MainWindow_Closed;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitializeCefSharp</span>()</span><br>        &#123;<br>            <span class=\"hljs-keyword\">var</span> settings = <span class=\"hljs-keyword\">new</span> CefSettings();<br>            Cef.Initialize(settings);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> htmlFilePath = GetHtmlFilePath(<span class=\"hljs-string\">&quot;file.html&quot;</span>);<br>            LoadHtmlFromFile(htmlFilePath);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">string</span> <span class=\"hljs-title\">GetHtmlFilePath</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> fileName</span>)</span><br>        &#123;<br>            <span class=\"hljs-comment\">//获取当前应用程序目录的路径</span><br>            <span class=\"hljs-built_in\">string</span> currentPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase).Replace(<span class=\"hljs-string\">@&quot;file:\\&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>);<br>            <span class=\"hljs-comment\">//获取HTML文件的绝对路径</span><br>            <span class=\"hljs-built_in\">string</span> htmlFilePath = Path.Combine(currentPath, fileName);<br>            <span class=\"hljs-keyword\">return</span> htmlFilePath;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadHtmlFromFile</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> filePath</span>)</span><br>        &#123;<br>            <span class=\"hljs-keyword\">try</span><br>            &#123;<br>                <span class=\"hljs-built_in\">string</span> htmlContent = File.ReadAllText(filePath);<br>                webBrowser.LoadHtml(htmlContent, <span class=\"hljs-string\">&quot;https://localhost&quot;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">catch</span> (Exception ex)<br>            &#123;<br>                <span class=\"hljs-comment\">// 处理加载错误</span><br>                MessageBox.Show(<span class=\"hljs-string\">$&quot;Failed to load HTML file: <span class=\"hljs-subst\">&#123;ex.Message&#125;</span>&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Closed</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            Cef.Shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个简化的示例中，我们将要加载HTML文件放在程序的根目录下，并命名为<code>file.html</code>。在<code>MainWindow_Loaded</code>方法中，我们调用了<code>GetHtmlFilePath</code>方法，并将HTML文件名作为参数传递给它。</p>\n<p><code>GetHtmlFilePath</code>方法首先获取当前应用程序目录的路径，然后使用<code>Path.Combine</code>方法将HTML文件名与应用程序目录组合成完整路径，并返回该路径。</p>\n<p>随后，我们调用<code>LoadHtmlFromFile</code>方法，并将HTML文件的完整路径作为参数传递给它。该方法读取指定路径的HTML文件内容，并使用<code>webBrowser.LoadHtml</code>方法将内容加载到<code>webBrowser</code>控件中。</p>\n<p>如果加载过程中出现错误，我们通过一个简单的消息框显示错误信息。</p>\n<p>在窗口关闭时，我们调用<code>Cef.Shutdown</code>方法来关闭CefSharp引擎。</p>\n<p>请注意，我们使用了<code>Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase)</code>方法来获取当前目录的路径，而不是<code>Environment.CurrentDirectory</code>。这是因为当应用程序启动时，<code>Environment.CurrentDirectory</code>可能不是期望的路径。当然，如果你不在意的话，用<code>Environment.CurrentDirectory</code>也是可以的</p>\n<h3 id=\"直接加载-无C-代码-1\"><a href=\"#直接加载-无C-代码-1\" class=\"headerlink\" title=\"直接加载(无C#代码)\"></a>直接加载(无C#代码)</h3><p>填写窗口XAML文件<code>cefSharp</code>中的<code>Address</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cefSharp:ChromiumWebBrowser</span> <span class=\"hljs-attr\">x:Name</span>=<span class=\"hljs-string\">&quot;webBrowser&quot;</span> <span class=\"hljs-attr\">Address</span>=<span class=\"hljs-string\">&quot;https://sunrise-studio.gitee.io/&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>简单吧，但是不方便修改，这个只适合最简单基础的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-WPF-NET-Framework-窗口使用HTML页面\"><a href=\"#C-WPF-NET-Framework-窗口使用HTML页面\" class=\"headerlink\" title=\"C# WPF(.NET Framework)窗口使用HTML页面\"></a>C# WPF(.NET Framework)窗口使用HTML页面</h1><p>由于<code>Awesomium</code>和<code>DotNetBrowser</code>目前都已经停止更新并不再推荐使用，所以我并没有写相关教程。</p>\n<p>然后呢，我个人不喜欢<code>.Net Core</code>，所以<code>WebView</code>也没写，单纯个人喜好问题，以后想要用了再写吧。</p>\n<h2 id=\"WebBrowser\"><a href=\"#WebBrowser\" class=\"headerlink\" title=\"WebBrowser\"></a>WebBrowser</h2><p>首先，在XAML文件中添加一个<code>WebBrowser</code>控件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xaml\">&lt;Window x:Class=&quot;MyApp.MainWindow&quot;<br>        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;<br>        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;<br>        Title=&quot;HTML嵌入示例&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt;<br>    &lt;Grid&gt;<br>        &lt;WebBrowser x:Name=&quot;webBrowser&quot; /&gt;<br>    &lt;/Grid&gt;<br>&lt;/Window&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"代码嵌入式\"><a href=\"#代码嵌入式\" class=\"headerlink\" title=\"代码嵌入式\"></a>代码嵌入式</h3><p>在后台代码中加载HTML内容：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">MyApp</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br><br>            <span class=\"hljs-comment\">// 在窗口加载时加载HTML</span><br>            Loaded += MainWindow_Loaded;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-comment\">// 加载HTML内容</span><br>            webBrowser.NavigateToString(<span class=\"hljs-string\">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>此示例在窗口加载时将显示一个包含标题 “Hello, World!” 的HTML页面。</p>\n<h3 id=\"外部文件绝对路径式\"><a href=\"#外部文件绝对路径式\" class=\"headerlink\" title=\"外部文件绝对路径式\"></a>外部文件绝对路径式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.IO;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> System.Windows.Controls;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">WebBrowserExample</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Window_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> filePath = <span class=\"hljs-string\">@&quot;C:\\path\\to\\your\\html\\file.html&quot;</span>;<br><br>            <span class=\"hljs-keyword\">if</span> (File.Exists(filePath))<br>            &#123;<br>                webBrowser.Navigate(<span class=\"hljs-keyword\">new</span> Uri(filePath));<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span><br>            &#123;<br>                MessageBox.Show(<span class=\"hljs-string\">&quot;指定的文件不存在！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的示例中，我们假设你有一个 <code>MainWindow</code>（主窗口）并添加了一个名为 <code>webBrowser</code> 的 <code>WebBrowser</code> 控件。在窗口的 <code>Loaded</code> 事件中，我们指定了要加载的 HTML 文件的绝对路径。</p>\n<h3 id=\"外部文件相对路径式\"><a href=\"#外部文件相对路径式\" class=\"headerlink\" title=\"外部文件相对路径式\"></a>外部文件相对路径式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.IO;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> System.Windows.Controls;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">WebBrowserExample</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Window_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> currentDirectory = Directory.GetCurrentDirectory();<br>            <span class=\"hljs-built_in\">string</span> relativePath = <span class=\"hljs-string\">&quot;your/html/file.html&quot;</span>;<br>            <span class=\"hljs-built_in\">string</span> absolutePath = Path.Combine(currentDirectory, relativePath);<br><br>            <span class=\"hljs-keyword\">if</span> (File.Exists(absolutePath))<br>            &#123;<br>                webBrowser.Navigate(<span class=\"hljs-keyword\">new</span> Uri(absolutePath));<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span><br>            &#123;<br>                MessageBox.Show(<span class=\"hljs-string\">&quot;指定的文件不存在！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们假设你有一个 <code>MainWindow</code>（主窗口）并添加了一个名为 <code>webBrowser</code> 的 <code>WebBrowser</code> 控件。在窗口的 <code>Loaded</code> 事件中，我们首先获取当前目录的路径 <code>currentDirectory</code>，然后将其与相对路径 <code>relativePath</code> 合并为绝对路径 <code>absolutePath</code>。</p>\n<p>最后，我们检查文件是否存在，如果文件存在，就使用 <code>WebBrowser</code> 控件的 <code>Navigate</code> 方法加载该文件；如果文件不存在，则弹出一个消息框提示文件不存在。</p>\n<h3 id=\"直接加载-无C-代码\"><a href=\"#直接加载-无C-代码\" class=\"headerlink\" title=\"直接加载(无C#代码)\"></a>直接加载(无C#代码)</h3><p>填写窗口XAML文件<code>WebBrowser</code>中的<code>Address</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WebBrowser</span> <span class=\"hljs-attr\">x:Name</span>=<span class=\"hljs-string\">&quot;webBrowser&quot;</span> <span class=\"hljs-attr\">Address</span>=<span class=\"hljs-string\">&quot;https://sunrise-studio.gitee.io/&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>简单吧，但是不方便修改，这个只适合最简单基础的。</p>\n<h2 id=\"CefSharp\"><a href=\"#CefSharp\" class=\"headerlink\" title=\"CefSharp\"></a>CefSharp</h2><p>在MainWindow.xaml文件中添加一个WebBrowser控件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Window</span> <span class=\"hljs-attr\">x:Class</span>=<span class=\"hljs-string\">&quot;CefSharpDemo.MainWindow&quot;</span></span><br><span class=\"hljs-tag\">        <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class=\"hljs-tag\">        <span class=\"hljs-attr\">xmlns:x</span>=<span class=\"hljs-string\">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class=\"hljs-tag\">        <span class=\"hljs-attr\">xmlns:cefSharp</span>=<span class=\"hljs-string\">&quot;clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf&quot;</span></span><br><span class=\"hljs-tag\">        <span class=\"hljs-attr\">Title</span>=<span class=\"hljs-string\">&quot;CefSharp Demo&quot;</span> <span class=\"hljs-attr\">Height</span>=<span class=\"hljs-string\">&quot;350&quot;</span> <span class=\"hljs-attr\">Width</span>=<span class=\"hljs-string\">&quot;525&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Grid</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cefSharp:ChromiumWebBrowser</span> <span class=\"hljs-attr\">x:Name</span>=<span class=\"hljs-string\">&quot;webBrowser&quot;</span> <span class=\"hljs-attr\">Address</span>=<span class=\"hljs-string\">&quot;about:blank&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Grid</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Window</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"代码嵌入式-1\"><a href=\"#代码嵌入式-1\" class=\"headerlink\" title=\"代码嵌入式\"></a>代码嵌入式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> CefSharp;<br><span class=\"hljs-keyword\">using</span> CefSharp.Wpf;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">CefSharpDemo</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>            InitializeCefSharp();<br>            webBrowser.Loaded += WebBrowser_Loaded;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitializeCefSharp</span>()</span><br>        &#123;<br>            <span class=\"hljs-keyword\">var</span> settings = <span class=\"hljs-keyword\">new</span> CefSettings();<br>            Cef.Initialize(settings);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">WebBrowser_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> html = <span class=\"hljs-string\">@&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;<br>            webBrowser.LoadHtml(html, <span class=\"hljs-string\">&quot;https://localhost&quot;</span>);<br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">OnClosed</span>(<span class=\"hljs-params\">System.EventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-keyword\">base</span>.OnClosed(e);<br>            Cef.Shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在构造函数中，我们初始化了CefSharp引擎，并将<code>webBrowser.Loaded</code>事件处理器指向了<code>WebBrowser_Loaded</code>方法。这样，当<code>webBrowser</code>控件加载完成时，会触发该事件，然后在<code>WebBrowser_Loaded</code>方法中加载HTML内容。</p>\n<p>注意，在<code>WebBrowser_Loaded</code>方法中，我们将HTML代码赋值给<code>html</code>变量，然后通过<code>webBrowser.LoadHtml</code>方法加载到<code>webBrowser</code>控件中。</p>\n<p>现在，当启动此WPF应用程序时，它将在窗口加载完成后加载并显示<code>Hello, World!</code>的HTML内容。</p>\n<h3 id=\"外部文件绝对路径式-1\"><a href=\"#外部文件绝对路径式-1\" class=\"headerlink\" title=\"外部文件绝对路径式\"></a>外部文件绝对路径式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.IO;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> CefSharp;<br><span class=\"hljs-keyword\">using</span> CefSharp.Wpf;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">CefSharpDemo</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>            InitializeCefSharp();<br><br>            Loaded += MainWindow_Loaded;<br>            Closed += MainWindow_Closed;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitializeCefSharp</span>()</span><br>        &#123;<br>            <span class=\"hljs-keyword\">var</span> settings = <span class=\"hljs-keyword\">new</span> CefSettings();<br>            Cef.Initialize(settings);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> htmlFilePath = <span class=\"hljs-string\">@&quot;C:\\path\\to\\your\\html\\file.html&quot;</span>;<br>            LoadHtmlFromFile(htmlFilePath);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadHtmlFromFile</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> filePath</span>)</span><br>        &#123;<br>            <span class=\"hljs-keyword\">try</span><br>            &#123;<br>                <span class=\"hljs-built_in\">string</span> htmlContent = File.ReadAllText(filePath);<br>                webBrowser.LoadHtml(htmlContent, <span class=\"hljs-string\">&quot;https://localhost&quot;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">catch</span> (Exception ex)<br>            &#123;<br>                <span class=\"hljs-comment\">// 处理加载错误</span><br>                MessageBox.Show(<span class=\"hljs-string\">$&quot;Failed to load HTML file: <span class=\"hljs-subst\">&#123;ex.Message&#125;</span>&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Closed</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            Cef.Shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这个简化的示例中，我们假设要加载的HTML文件位于本地磁盘上的绝对路径<code>C:\\path\\to\\your\\html\\file.html</code>。在<code>MainWindow_Loaded</code>方法中，我们调用<code>LoadHtmlFromFile</code>方法，并将HTML文件的路径作为参数传递给它。</p>\n<p><code>LoadHtmlFromFile</code>方法读取指定路径的HTML文件内容，并使用<code>webBrowser.LoadHtml</code>方法将内容加载到<code>webBrowser</code>控件中。如果加载过程中出现错误，我们通过一个简单的消息框显示错误信息。</p>\n<p>在窗口关闭时，我们调用<code>Cef.Shutdown</code>方法来关闭CefSharp引擎。</p>\n<h3 id=\"外部文件相对路径式-1\"><a href=\"#外部文件相对路径式-1\" class=\"headerlink\" title=\"外部文件相对路径式\"></a>外部文件相对路径式</h3><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">using</span> System;<br><span class=\"hljs-keyword\">using</span> System.IO;<br><span class=\"hljs-keyword\">using</span> System.Reflection;<br><span class=\"hljs-keyword\">using</span> System.Windows;<br><span class=\"hljs-keyword\">using</span> CefSharp;<br><span class=\"hljs-keyword\">using</span> CefSharp.Wpf;<br><br><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">CefSharpDemo</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">partial</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainWindow</span> : <span class=\"hljs-title\">Window</span><br>    &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>            InitializeCefSharp();<br><br>            Loaded += MainWindow_Loaded;<br>            Closed += MainWindow_Closed;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitializeCefSharp</span>()</span><br>        &#123;<br>            <span class=\"hljs-keyword\">var</span> settings = <span class=\"hljs-keyword\">new</span> CefSettings();<br>            Cef.Initialize(settings);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Loaded</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class=\"hljs-built_in\">string</span> htmlFilePath = GetHtmlFilePath(<span class=\"hljs-string\">&quot;file.html&quot;</span>);<br>            LoadHtmlFromFile(htmlFilePath);<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">string</span> <span class=\"hljs-title\">GetHtmlFilePath</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> fileName</span>)</span><br>        &#123;<br>            <span class=\"hljs-comment\">//获取当前应用程序目录的路径</span><br>            <span class=\"hljs-built_in\">string</span> currentPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase).Replace(<span class=\"hljs-string\">@&quot;file:\\&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>);<br>            <span class=\"hljs-comment\">//获取HTML文件的绝对路径</span><br>            <span class=\"hljs-built_in\">string</span> htmlFilePath = Path.Combine(currentPath, fileName);<br>            <span class=\"hljs-keyword\">return</span> htmlFilePath;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LoadHtmlFromFile</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> filePath</span>)</span><br>        &#123;<br>            <span class=\"hljs-keyword\">try</span><br>            &#123;<br>                <span class=\"hljs-built_in\">string</span> htmlContent = File.ReadAllText(filePath);<br>                webBrowser.LoadHtml(htmlContent, <span class=\"hljs-string\">&quot;https://localhost&quot;</span>);<br>            &#125;<br>            <span class=\"hljs-keyword\">catch</span> (Exception ex)<br>            &#123;<br>                <span class=\"hljs-comment\">// 处理加载错误</span><br>                MessageBox.Show(<span class=\"hljs-string\">$&quot;Failed to load HTML file: <span class=\"hljs-subst\">&#123;ex.Message&#125;</span>&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MainWindow_Closed</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            Cef.Shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个简化的示例中，我们将要加载HTML文件放在程序的根目录下，并命名为<code>file.html</code>。在<code>MainWindow_Loaded</code>方法中，我们调用了<code>GetHtmlFilePath</code>方法，并将HTML文件名作为参数传递给它。</p>\n<p><code>GetHtmlFilePath</code>方法首先获取当前应用程序目录的路径，然后使用<code>Path.Combine</code>方法将HTML文件名与应用程序目录组合成完整路径，并返回该路径。</p>\n<p>随后，我们调用<code>LoadHtmlFromFile</code>方法，并将HTML文件的完整路径作为参数传递给它。该方法读取指定路径的HTML文件内容，并使用<code>webBrowser.LoadHtml</code>方法将内容加载到<code>webBrowser</code>控件中。</p>\n<p>如果加载过程中出现错误，我们通过一个简单的消息框显示错误信息。</p>\n<p>在窗口关闭时，我们调用<code>Cef.Shutdown</code>方法来关闭CefSharp引擎。</p>\n<p>请注意，我们使用了<code>Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase)</code>方法来获取当前目录的路径，而不是<code>Environment.CurrentDirectory</code>。这是因为当应用程序启动时，<code>Environment.CurrentDirectory</code>可能不是期望的路径。当然，如果你不在意的话，用<code>Environment.CurrentDirectory</code>也是可以的</p>\n<h3 id=\"直接加载-无C-代码-1\"><a href=\"#直接加载-无C-代码-1\" class=\"headerlink\" title=\"直接加载(无C#代码)\"></a>直接加载(无C#代码)</h3><p>填写窗口XAML文件<code>cefSharp</code>中的<code>Address</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cefSharp:ChromiumWebBrowser</span> <span class=\"hljs-attr\">x:Name</span>=<span class=\"hljs-string\">&quot;webBrowser&quot;</span> <span class=\"hljs-attr\">Address</span>=<span class=\"hljs-string\">&quot;https://sunrise-studio.gitee.io/&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>简单吧，但是不方便修改，这个只适合最简单基础的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clma1hhtg0000qk5g6pq5amt7","category_id":"clma2lvt80000jk5gf9lg3c1i","_id":"clma2lvt90003jk5gdakhd5yd"},{"post_id":"clmc1mnfd0000jk5g9x270cvu","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmc1mnfi0004jk5g62ns9t2n"},{"post_id":"clmc256tt00008o5gdr5a87v4","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmc256tx00028o5gba08hkee"},{"post_id":"clmc2cg6200007c5g72fs0hb0","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmc2cg6600027c5ghgli4x08"},{"post_id":"clmd9mnh700001w5g7wyoc4yl","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmd9mnha00021w5ghx040w0p"},{"post_id":"clmdad4sa0000io5g243bgsb3","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdad4se0002io5g2sfefwub"},{"post_id":"clmdav0ye0000qw5g94ko63xq","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdav0yh0002qw5g3cocgtbs"},{"post_id":"clmdclmh90000zo5gc7dwdtrv","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdclmhd0002zo5g7snp6srs"},{"post_id":"clmdd0naa0000945gdj3573bq","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdd0nad0002945ga4ek7r4e"},{"post_id":"clmdhfnfv0000805gf8130vhc","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdhfnfy0002805g3kc8drnm"},{"post_id":"clmdi4bxv0000x45g8jdm3rgf","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdi4bxy0002x45g3qkv5sof"},{"post_id":"clmdip5dw00001s5ghxak48vy","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdip5e000021s5gd60xbizr"},{"post_id":"clmdkqd1y0000l05g63kvdzdf","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdkqd210002l05g943g72f5"},{"post_id":"clmdl5yx70000h85g870nag79","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmdl8dq30001mw5gg2j03bvt"},{"post_id":"clmhsaq280000wg5gayll54zw","category_id":"clmc1mnfh0001jk5g20xt7b9r","_id":"clmhsaq2c0002wg5gaop6431w"}],"PostTag":[{"post_id":"clma1hhtg0000qk5g6pq5amt7","tag_id":"clma2lvt80001jk5g1cwc44kv","_id":"clma2lvt90002jk5gggsld608"},{"post_id":"clmc1mnfd0000jk5g9x270cvu","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmc1mnfi0003jk5ghs729tte"},{"post_id":"clmc256tt00008o5gdr5a87v4","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmc256tx00018o5ggwl1frj3"},{"post_id":"clmc2cg6200007c5g72fs0hb0","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmc2cg6600017c5g3lmdg291"},{"post_id":"clmd9mnh700001w5g7wyoc4yl","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmd9mnha00011w5g9efx85jk"},{"post_id":"clmdad4sa0000io5g243bgsb3","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdad4sd0001io5g1gjjc7am"},{"post_id":"clmdav0ye0000qw5g94ko63xq","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdav0yh0001qw5g09ef1rrt"},{"post_id":"clmdclmh90000zo5gc7dwdtrv","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdclmhd0001zo5ga3z8ai17"},{"post_id":"clmdd0naa0000945gdj3573bq","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdd0nad0001945ghnozgngb"},{"post_id":"clmdhfnfv0000805gf8130vhc","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdhfnfy0001805g4wq62wm5"},{"post_id":"clmdi4bxv0000x45g8jdm3rgf","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdi4bxy0001x45ggy416orr"},{"post_id":"clmdip5dw00001s5ghxak48vy","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdip5e000011s5ge5761fc3"},{"post_id":"clmdkqd1y0000l05g63kvdzdf","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdkqd210001l05g80ef48dy"},{"post_id":"clmdl5yx70000h85g870nag79","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmdl8dq20000mw5gbtf35ge6"},{"post_id":"clmhsaq280000wg5gayll54zw","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmhsaq2b0001wg5g863j631m"},{"post_id":"clmdad4sa0000io5g243bgsb3","tag_id":"clmhsggep0000h85gcgcd4cg0","_id":"clmhsgger0001h85ggftsg1ef"},{"post_id":"clmhtkqd80000ug5ghqom7hi4","tag_id":"clmc1mnfi0002jk5gh1wzeh96","_id":"clmhtkqdd0002ug5g7gdeg90o"},{"post_id":"clmhtkqd80000ug5ghqom7hi4","tag_id":"clmhsggep0000h85gcgcd4cg0","_id":"clmhtkqdd0003ug5g779j44uv"},{"post_id":"clmhtkqd80000ug5ghqom7hi4","tag_id":"clmhtkqdb0001ug5g4wjjdvzf","_id":"clmhtkqdd0004ug5g9gnz547p"}],"Tag":[{"name":"餐饮","_id":"clma2lvt80001jk5g1cwc44kv"},{"name":"编程","_id":"clmc1mnfi0002jk5gh1wzeh96"},{"name":"C#","_id":"clmhsf4rh0000n45g25oy2bvf"},{"name":"C-Sharp","_id":"clmhsggep0000h85gcgcd4cg0"},{"name":"HTML","_id":"clmhtkqdb0001ug5g4wjjdvzf"}]}}