<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PHP执行Shell</title>
    <link href="/2023/09/13/PHP%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/13/PHP%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP执行Shell"><a href="#PHP执行Shell" class="headerlink" title="PHP执行Shell"></a>PHP执行Shell</h1><p>PHP有多种执行Shell命令的方法，以下是其中一些常用(或能用)的方法：</p><h2 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-string">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这会在Shell中执行指定的命令，并将结果保存在变量<code>$result</code>中。</p><h2 id="shell-exec函数"><a href="#shell-exec函数" class="headerlink" title="shell_exec函数"></a>shell_exec函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">shell_exec</span>(<span class="hljs-string">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这与exec函数类似，但是会返回命令的完整输出结果。</p><h2 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;shell command&#x27;</span>, <span class="hljs-variable">$return_value</span>);<br></code></pre></td></tr></table></figure><p>该函数将命令的输出直接打印到屏幕上，并将返回值存储在<code>$return_value</code>中。</p><h2 id="passthru函数"><a href="#passthru函数" class="headerlink" title="passthru函数"></a>passthru函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">passthru</span>(<span class="hljs-string">&#x27;shell command&#x27;</span>);<br></code></pre></td></tr></table></figure><p>该函数直接将命令的输出打印到屏幕上，而不会返回任何结果。</p><p>是的，还有其他一些执行Shell命令的方法。以下是其中的一些：</p><h2 id="popen函数"><a href="#popen函数" class="headerlink" title="popen函数"></a>popen函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$handle</span> = <span class="hljs-title function_ invoke__">popen</span>(<span class="hljs-string">&#x27;shell command&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">fread</span>(<span class="hljs-variable">$handle</span>, <span class="hljs-number">8192</span>);<br><span class="hljs-title function_ invoke__">pclose</span>(<span class="hljs-variable">$handle</span>);<br></code></pre></td></tr></table></figure><p>这个函数可以打开一个管道，并执行Shell命令。您可以使用<code>fread</code>函数读取命令的输出，并使用<code>pclose</code>函数关闭管道。</p><h2 id="proc-open函数"><a href="#proc-open函数" class="headerlink" title="proc_open函数"></a>proc_open函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$descriptorspec</span> = <span class="hljs-keyword">array</span>(<br>   <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>),  <br>   <span class="hljs-number">1</span> =&gt; <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>),  <br>   <span class="hljs-number">2</span> =&gt; <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)   <br>);<br><br><span class="hljs-variable">$process</span> = <span class="hljs-title function_ invoke__">proc_open</span>(<span class="hljs-string">&#x27;shell command&#x27;</span>, <span class="hljs-variable">$descriptorspec</span>, <span class="hljs-variable">$pipes</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_resource</span>(<span class="hljs-variable">$process</span>)) &#123;<br>    <span class="hljs-variable">$output</span> = <span class="hljs-title function_ invoke__">stream_get_contents</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>]);<br>    <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-variable">$error</span> = <span class="hljs-title function_ invoke__">stream_get_contents</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">2</span>]);<br>    <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-title function_ invoke__">proc_close</span>(<span class="hljs-variable">$process</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数可以打开一个进程，并执行Shell命令。您可以使用<code>stream_get_contents</code>函数读取标准输出和错误输出。</p><h2 id="backtick操作符（反引号）"><a href="#backtick操作符（反引号）" class="headerlink" title="backtick操作符（反引号）"></a>backtick操作符（反引号）</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$result</span> = `shell command`;<br></code></pre></td></tr></table></figure><p>在PHP中，您可以使用backtick操作符将Shell命令嵌入到字符串中，然后将其执行。执行结果将作为字符串返回给变量<code>$result</code>。可以使用<code>echo $result;</code>来输出结果。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C++执行Shell</title>
    <link href="/2023/09/10/Objective-C++%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/Objective-C++%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="Objective-C-执行Shell"><a href="#Objective-C-执行Shell" class="headerlink" title="Objective-C++执行Shell"></a>Objective-C++执行Shell</h1><h2 id="使用-NSTask-类"><a href="#使用-NSTask-类" class="headerlink" title="使用 NSTask 类"></a>使用 NSTask 类</h2><p>NSTask 是一个 Objective-C 类，用于在 macOS 或 iOS 应用程序中执行外部命令。它可以创建一个子进程，并允许您设置命令、参数和环境变量。下面是一个示例代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;Foundation/Foundation.h&gt;<br><br>int main(int argc, const char * argv[]) &#123;<br>    @autoreleasepool &#123;<br>        NSTask *task = [[NSTask alloc] init];<br>        [task setLaunchPath:@&quot;/usr/bin/env&quot;];<br>        [task setArguments:@[@&quot;ls&quot;, @&quot;-l&quot;]];<br>        <br>        NSPipe *pipe = [NSPipe pipe];<br>        [task setStandardOutput:pipe];<br>        <br>        [task launch];<br>        [task waitUntilExit];<br>        <br>        NSData *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br>        NSString *output = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>        NSLog(@&quot;%@&quot;, output);<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，NSTask 用于运行 “ls -l” 命令，并将输出保存到一个 NSPipe 中。然后，我们读取管道中的数据并打印到控制台。</p><h2 id="使用-system-函数"><a href="#使用-system-函数" class="headerlink" title="使用 system() 函数"></a>使用 system() 函数</h2><p>C++ 中有一个名为 system() 的函数，可以用于执行 Shell 命令。在 Objective-C++ 中，您也可以使用该函数。下面是一个示例代码片段：</p><figure class="highlight objective-c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objective-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-type">int</span> result = system(<span class="hljs-string">&quot;ls -l&quot;</span>);<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Command execution failed.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-popen-函数"><a href="#使用-popen-函数" class="headerlink" title="使用 popen() 函数"></a>使用 popen() 函数</h2><p>popen() 函数可以用于执行 Shell 命令并获取输出。</p><figure class="highlight objective-c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        FILE *pipe = popen(<span class="hljs-string">&quot;ls -l&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> (pipe == <span class="hljs-literal">NULL</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Command execution failed.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">while</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), pipe) != <span class="hljs-literal">NULL</span>) &#123;<br>            std::cout &lt;&lt; buffer;<br>        &#125;<br>        <br>        pclose(pipe);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们使用 popen() 执行 “ls -l” 命令，并逐行读取输出并打印到控制台。</p><h2 id="使用-NSTask-的便捷方法"><a href="#使用-NSTask-的便捷方法" class="headerlink" title="使用 NSTask 的便捷方法"></a>使用 NSTask 的便捷方法</h2><p>NSTask 类提供了一些便捷方法来执行 Shell 命令，而无需手动设置 launch path 和 arguments。</p><figure class="highlight objective-c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c++"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSString</span> *output = [<span class="hljs-built_in">NSString</span> stringWithContentsOfURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://example.com&quot;</span>]<br>                                                    encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span><br>                                                       error:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, output);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们使用 <code>[NSString stringWithContentsOfURL:encoding:error:]</code> 方法执行了 <code>curl http://example.com</code> 命令，并将输出保存在 NSString 对象中。</p><ol start="5"><li>使用 system() 或 popen() 的 C++ 封装：您可以将 system() 或 popen() 函数进行封装，以便更方便地在 Objective-C++ 中使用。例如，可以创建一个 C++ 函数来执行 Shell 命令，并返回结果。下面是一个示例代码片段：</li></ol><figure class="highlight objective-c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objective-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br>std::string executeShellCommand(<span class="hljs-keyword">const</span> std::string &amp;command) &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">128</span>];<br>    std::string result = <span class="hljs-string">&quot;&quot;</span>;<br>    <br>    FILE *pipe = popen(command.c_str(), <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!pipe) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Command execution failed.&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), pipe) != <span class="hljs-literal">NULL</span>) &#123;<br>        result += buffer;<br>    &#125;<br>    <br>    pclose(pipe);<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        std::string output = executeShellCommand(<span class="hljs-string">&quot;ls -l&quot;</span>);<br>        std::cout &lt;&lt; output;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们定义了一个 <code>executeShellCommand()</code> 函数，它接受一个 Shell 命令，并返回执行结果。在 <code>main()</code> 函数中，我们调用该函数执行 “ls -l” 命令，并将输出打印到控制台。</p><h2 id="使用-POSIX-的-fork-和-exec-函数"><a href="#使用-POSIX-的-fork-和-exec-函数" class="headerlink" title="使用 POSIX 的 fork() 和 exec() 函数"></a>使用 POSIX 的 fork() 和 exec() 函数</h2><p>Objective-C++ 可以直接使用 POSIX 的 fork() 和 exec() 函数来创建子进程并执行外部命令。下面是一个示例代码片段：</p><figure class="highlight objective-c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objective-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        pid_t pid = fork();<br>        <br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to create child process.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Child process</span><br>            execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>);<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to execute command.&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Parent process</span><br>            wait(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们通过调用 fork() 函数创建了一个子进程，并在子进程中调用 execl() 函数来执行 “ls -l” 命令。父进程通过调用 wait() 函数等待子进程的结束。</p><h2 id="使用-NSTask-的便捷方法执行-Shell-脚本"><a href="#使用-NSTask-的便捷方法执行-Shell-脚本" class="headerlink" title="使用 NSTask 的便捷方法执行 Shell 脚本"></a>使用 NSTask 的便捷方法执行 Shell 脚本</h2><p>如果要执行复杂的 Shell 脚本，可以使用 NSTask 的便捷方法来执行脚本文件。下面是一个示例代码片段：</p><figure class="highlight objective-c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objective-c++"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSString</span> *scriptPath = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@&quot;script.sh&quot;</span> ofType:<span class="hljs-literal">nil</span>];<br>        <br>        <span class="hljs-built_in">NSTask</span> *task = [[<span class="hljs-built_in">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class="hljs-string">@&quot;/bin/sh&quot;</span>];<br>        [task setArguments:@[scriptPath]];<br>        <br>        <span class="hljs-built_in">NSPipe</span> *pipe = [<span class="hljs-built_in">NSPipe</span> pipe];<br>        [task setStandardOutput:pipe];<br>        <br>        [task launch];<br>        [task waitUntilExit];<br>        <br>        <span class="hljs-built_in">NSData</span> *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br>        <span class="hljs-built_in">NSString</span> *output = [[<span class="hljs-built_in">NSString</span> alloc] initWithData:data encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, output);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们使用 NSTask 执行一个名为 “script.sh” 的 Shell 脚本文件，并将输出保存到一个 NSPipe 中。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C执行Shell</title>
    <link href="/2023/09/10/Objective-C%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/Objective-C%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="Objective-C执行Shell"><a href="#Objective-C执行Shell" class="headerlink" title="Objective-C执行Shell"></a>Objective-C执行Shell</h1><h2 id="使用NSTask类"><a href="#使用NSTask类" class="headerlink" title="使用NSTask类"></a>使用NSTask类</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSTask</span> *task = [[<span class="hljs-built_in">NSTask</span> alloc] init];<br>[task setLaunchPath:<span class="hljs-string">@&quot;/bin/sh&quot;</span>];<br>[task setArguments:@[<span class="hljs-string">@&quot;-c&quot;</span>, <span class="hljs-string">@&quot;ls -al&quot;</span>]];<br><br><span class="hljs-built_in">NSPipe</span> *pipe = [<span class="hljs-built_in">NSPipe</span> pipe];<br>[task setStandardOutput:pipe];<br><br>[task launch];<br><br><span class="hljs-built_in">NSData</span> *data = [[pipe fileHandleForReading] readDataToEndOfFile];<br><span class="hljs-built_in">NSString</span> *output = [[<span class="hljs-built_in">NSString</span> alloc] initWithData:data encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Shell command output:\n%@&quot;</span>, output);<br></code></pre></td></tr></table></figure><p>代码创建了一个NSTask实例，设置它的启动路径为&#x2F;bin&#x2F;sh，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接着，我们调用lauch方法启动任务并等待它完成。最后，我们从管道的读取端读取所有数据，并使用UTF8编码将其转换为字符串，打印出执行结果。</p><h2 id="使用system函数"><a href="#使用system函数" class="headerlink" title="使用system函数"></a>使用system函数</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSString</span> *command = <span class="hljs-string">@&quot;ls -al&quot;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *cmd = [command UTF8String];<br>        <br>        <span class="hljs-type">int</span> status = system(cmd);<br>        <span class="hljs-keyword">if</span> (status == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Failed to execute shell command&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Shell command exited with status: %d&quot;</span>, status);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们通过NSString对象创建要执行的Shell命令，并将其转换为C字符串。然后，我们使用system函数来执行命令，并存储返回的状态码。最后，根据状态码打印相应的信息。</p><h2 id="NSTask任务-NSPipe实例"><a href="#NSTask任务-NSPipe实例" class="headerlink" title="NSTask任务+NSPipe实例"></a>NSTask任务+NSPipe实例</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSTask</span> *task = [[<span class="hljs-built_in">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class="hljs-string">@&quot;/bin/sh&quot;</span>];<br>        [task setArguments:@[<span class="hljs-string">@&quot;-c&quot;</span>, <span class="hljs-string">@&quot;ls -al&quot;</span>]];<br><br>        <span class="hljs-built_in">NSPipe</span> *pipe = [<span class="hljs-built_in">NSPipe</span> pipe];<br>        [task setStandardOutput:pipe];<br><br>        <span class="hljs-built_in">NSFileHandle</span> *file = [pipe fileHandleForReading];<br>        [task launch];<br>        <br>        <span class="hljs-built_in">NSData</span> *data = [file readDataToEndOfFile];<br>        <span class="hljs-built_in">NSString</span> *output = [[<span class="hljs-built_in">NSString</span> alloc] initWithData:data encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Shell command output:\n%@&quot;</span>, output);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中，我们使用NSTask创建一个任务，并设置其启动路径为<code>/bin/sh</code>，并将要执行的命令作为参数传递给它。然后，我们创建了一个NSPipe实例，并将其设置为任务的标准输出。接下来，我们获取管道的文件句柄，并启动任务。然后，我们从文件句柄中读取所有数据，并将其转换为字符串，最后打印出执行结果。</p><p>这种方式相对于之前的示例更灵活，可以更方便地处理任务的输入和输出。</p><h2 id="通过管道进行输入和输出的交互-NSTask"><a href="#通过管道进行输入和输出的交互-NSTask" class="headerlink" title="通过管道进行输入和输出的交互(NSTask)"></a>通过管道进行输入和输出的交互(NSTask)</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSTask</span> *task = [[<span class="hljs-built_in">NSTask</span> alloc] init];<br>        [task setLaunchPath:<span class="hljs-string">@&quot;/bin/sh&quot;</span>];<br>        <br>        <span class="hljs-built_in">NSPipe</span> *inputPipe = [<span class="hljs-built_in">NSPipe</span> pipe];<br>        <span class="hljs-built_in">NSPipe</span> *outputPipe = [<span class="hljs-built_in">NSPipe</span> pipe];<br>        <br>        [task setStandardInput:inputPipe];<br>        [task setStandardOutput:outputPipe];<br>        <br>        <span class="hljs-built_in">NSFileHandle</span> *inputHandle = [inputPipe fileHandleForWriting];<br>        <span class="hljs-built_in">NSFileHandle</span> *outputHandle = [outputPipe fileHandleForReading];<br>        <br>        [task launch];<br>        <br>        <span class="hljs-built_in">NSString</span> *command = <span class="hljs-string">@&quot;ls -al&quot;</span>;<br>        <span class="hljs-built_in">NSData</span> *commandData = [command dataUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>        [inputHandle writeData:commandData];<br>        [inputHandle closeFile];<br>        <br>        <span class="hljs-built_in">NSData</span> *outputData = [outputHandle readDataToEndOfFile];<br>        <span class="hljs-built_in">NSString</span> *output = [[<span class="hljs-built_in">NSString</span> alloc] initWithData:outputData encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Shell command output:\n%@&quot;</span>, output);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，创建了一个<code>NSTask</code>对象，并设置其启动路径为<code>/bin/sh</code>。然后，我们创建了两个管道，一个用于将命令输入给Shell，另一个用于获取Shell的输出。我们将这两个管道分别设置为任务的标准输入和标准输出。</p><p>接下来获取输入管道和输出管道的文件句柄，并启动任务。然后创建一个要执行的Shell命令，并将其转换为NSData对象。使用输入句柄，我们将命令数据写入输入管道，并关闭输入句柄。</p><p>最后，从输出句柄中读取所有数据，并将其转换为字符串。打印出Shell命令的输出结果。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript执行Shell</title>
    <link href="/2023/09/10/Typescript%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/Typescript%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="Typescript执行Shell"><a href="#Typescript执行Shell" class="headerlink" title="Typescript执行Shell"></a>Typescript执行Shell</h1><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a><code>exec()</code></h2><p>异步执行 Shell 命令，且不会保留子进程的输出结果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; exec &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span>;<br><br><span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出内容: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="execSync"><a href="#execSync" class="headerlink" title="execSync()"></a><code>execSync()</code></h2><p>同步执行 Shell 命令，并返回输出结果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; execSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> output = <span class="hljs-title function_">execSync</span>(<span class="hljs-string">&#x27;ls&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出内容: <span class="hljs-subst">$&#123;output.toString()&#125;</span>`</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn()"></a><code>spawn()</code></h2><p>异步执行 Shell 命令，并可以保留进程的输出结果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; spawn &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span>;<br><br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>);<br><br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出内容: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`错误输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`进程退出码: <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="spawnSync"><a href="#spawnSync" class="headerlink" title="spawnSync()"></a><code>spawnSync()</code></h2><p>同步执行 Shell 命令，并返回输出结果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; spawnSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span>;<br><br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawnSync</span>(<span class="hljs-string">&#x27;ls&#x27;</span>);<br><span class="hljs-keyword">if</span> (ls.<span class="hljs-property">error</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;ls.error.message&#125;</span>`</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出内容: <span class="hljs-subst">$&#123;ls.output.toString()&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="execFile"><a href="#execFile" class="headerlink" title="execFile()"></a><code>execFile()</code></h2><p>异步执行可执行文件，可以传入命令行参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; execFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span>;<br><br><span class="hljs-keyword">const</span> command = <span class="hljs-string">&#x27;cd&#x27;</span>;<br><span class="hljs-keyword">const</span> args = [<span class="hljs-string">&#x27;/d&#x27;</span>, <span class="hljs-string">&#x27;desktop&#x27;</span>];<br><br><span class="hljs-title function_">execFile</span>(command, args, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出内容: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="execFileSync"><a href="#execFileSync" class="headerlink" title="execFileSync()"></a><code>execFileSync()</code></h2><p>同步执行可执行文件，可以传入命令行参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; execFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span>;<br><br><span class="hljs-keyword">const</span> command = <span class="hljs-string">&#x27;cd&#x27;</span>;<br><span class="hljs-keyword">const</span> args = [<span class="hljs-string">&#x27;/d&#x27;</span>, <span class="hljs-string">&#x27;desktop&#x27;</span>];<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> output = <span class="hljs-title function_">execFileSync</span>(command, args);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出内容: <span class="hljs-subst">$&#123;output.toString()&#125;</span>`</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="execShellCommand"><a href="#execShellCommand" class="headerlink" title="execShellCommand()"></a><code>execShellCommand()</code></h2><p>自定义一个异步执行 Shell 命令的封装函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; exec &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">execShellCommand</span>(<span class="hljs-params">command: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">exec</span>(command, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-title function_">reject</span>(error);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">resolve</span>(stdout.<span class="hljs-title function_">trim</span>());<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> output = <span class="hljs-keyword">await</span> <span class="hljs-title function_">execShellCommand</span>(<span class="hljs-string">&#x27;ls&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出内容: <span class="hljs-subst">$&#123;output&#125;</span>`</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p>这个方法将 <code>exec</code> 包装在一个 Promise 中，使其可以轻松地使用 <code>await</code> 进行异步操作。</p><h2 id="spawnShellCommand"><a href="#spawnShellCommand" class="headerlink" title="spawnShellCommand()"></a><code>spawnShellCommand()</code></h2><p>自定义一个异步执行 Shell 命令的封装函数，支持参数和流式数据处理。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; spawn &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">spawnShellCommand</span>(<span class="hljs-params">command: <span class="hljs-built_in">string</span>, args: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">spawn</span>(command, args);<br><br>    <span class="hljs-keyword">let</span> output = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    child.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      output += data.<span class="hljs-title function_">toString</span>();<br>    &#125;);<br><br>    child.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(data.<span class="hljs-title function_">toString</span>());<br>    &#125;);<br><br>    child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(error);<br>    &#125;);<br><br>    child.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`命令执行失败，退出码: <span class="hljs-subst">$&#123;code&#125;</span>`</span>));<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">resolve</span>(output.<span class="hljs-title function_">trim</span>());<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> output = <span class="hljs-keyword">await</span> <span class="hljs-title function_">spawnShellCommand</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-lh&#x27;</span>]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出内容: <span class="hljs-subst">$&#123;output&#125;</span>`</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p>这个方法使用 <code>spawn</code> 创建子进程，并处理标准输出和标准错误流，最后返回整个输出结果。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>F#执行Shell</title>
    <link href="/2023/09/10/F-Sharp%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/F-Sharp%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="F-执行Shell"><a href="#F-执行Shell" class="headerlink" title="F#执行Shell"></a>F#执行Shell</h1><p>在F#中，可以使用<code>System.Diagnostics.Process</code>命名空间来执行Shell命令。以下是几种执行Shell命令的方式。</p><h2 id="使用System-Diagnostics-Process-Start方法"><a href="#使用System-Diagnostics-Process-Start方法" class="headerlink" title="使用System.Diagnostics.Process.Start方法"></a>使用<code>System.Diagnostics.Process.Start</code>方法</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> System.Diagnostics<br><br><span class="hljs-keyword">let</span> executeCommand (command<span class="hljs-operator">:</span> <span class="hljs-type">string</span>) <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">let</span> processStartInfo <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ProcessStartInfo(<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-built_in">sprintf</span> <span class="hljs-string">&quot;/C %s&quot;</span> command)<br>    processStartInfo.RedirectStandardOutput <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">true</span><br>    processStartInfo.UseShellExecute <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">false</span><br>    processStartInfo.CreateNoWindow <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">let</span> process <span class="hljs-operator">=</span> Process.Start(processStartInfo)<br>    <span class="hljs-keyword">let</span> output <span class="hljs-operator">=</span> process.StandardOutput.ReadToEnd()<br><br>    process.WaitForExit()<br>    output<br><br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> executeCommand <span class="hljs-string">&quot;dir&quot;</span><br><span class="hljs-built_in">printfn</span> <span class="hljs-string">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure><h2 id="使用System-Diagnostics-Process-Start方法-1"><a href="#使用System-Diagnostics-Process-Start方法-1" class="headerlink" title="使用System.Diagnostics.Process.Start方法"></a>使用<code>System.Diagnostics.Process.Start</code>方法</h2><p>获取标准输出和错误输出。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> System.Diagnostics<br><br><span class="hljs-keyword">let</span> executeCommand (command<span class="hljs-operator">:</span> <span class="hljs-type">string</span>) <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">let</span> processStartInfo <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ProcessStartInfo(<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-built_in">sprintf</span> <span class="hljs-string">&quot;/C %s&quot;</span> command)<br>    processStartInfo.RedirectStandardOutput <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">true</span><br>    processStartInfo.RedirectStandardError <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">true</span><br>    processStartInfo.UseShellExecute <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">false</span><br>    processStartInfo.CreateNoWindow <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">let</span> process <span class="hljs-operator">=</span> Process.Start(processStartInfo)<br>    <span class="hljs-keyword">let</span> output <span class="hljs-operator">=</span> process.StandardOutput.ReadToEnd()<br>    <span class="hljs-keyword">let</span> error <span class="hljs-operator">=</span> process.StandardError.ReadToEnd()<br><br>    process.WaitForExit()<br>    (output, error)<br><br><span class="hljs-keyword">let</span> (output, error) <span class="hljs-operator">=</span> executeCommand <span class="hljs-string">&quot;dir&quot;</span><br><span class="hljs-built_in">printfn</span> <span class="hljs-string">&quot;Output:\n%s&quot;</span> output<br><span class="hljs-built_in">printfn</span> <span class="hljs-string">&quot;Error:\n%s&quot;</span> error<br></code></pre></td></tr></table></figure><h2 id="使用System-Diagnostics-Process类"><a href="#使用System-Diagnostics-Process类" class="headerlink" title="使用System.Diagnostics.Process类"></a>使用<code>System.Diagnostics.Process</code>类</h2><p>直接执行命令并获取输出。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> System.Diagnostics<br><br><span class="hljs-keyword">let</span> executeCommand (command<span class="hljs-operator">:</span> <span class="hljs-type">string</span>) <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">let</span> process <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Process()<br>    process.StartInfo.FileName <span class="hljs-operator">&lt;-</span> <span class="hljs-string">&quot;cmd.exe&quot;</span><br>    process.StartInfo.Arguments <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">sprintf</span> <span class="hljs-string">&quot;/C %s&quot;</span> command<br>    process.StartInfo.UseShellExecute <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">false</span><br>    process.StartInfo.RedirectStandardOutput <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">true</span><br><br>    process.Start()<br>    <span class="hljs-keyword">let</span> output <span class="hljs-operator">=</span> process.StandardOutput.ReadToEnd()<br>    process.WaitForExit()<br>    output<br><br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> executeCommand <span class="hljs-string">&quot;dir&quot;</span><br><span class="hljs-built_in">printfn</span> <span class="hljs-string">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure><h2 id="使用FSharp-SystemCommand库"><a href="#使用FSharp-SystemCommand库" class="headerlink" title="使用FSharp.SystemCommand库"></a>使用<code>FSharp.SystemCommand</code>库</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> FSharp.SystemCommand<br><br><span class="hljs-keyword">let</span> executeCommand (command<span class="hljs-operator">:</span> <span class="hljs-type">string</span>) <span class="hljs-operator">=</span><br>    Command.create command<br>    <span class="hljs-operator">|&gt;</span> Command.run<br>    <span class="hljs-operator">|&gt;</span> Command.output<br><br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> executeCommand <span class="hljs-string">&quot;dir&quot;</span><br><span class="hljs-built_in">printfn</span> <span class="hljs-string">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure><p>请确保已将<code>FSharp.SystemCommand</code>库添加到项目引用中。</p><h2 id="使用Suave-Process库"><a href="#使用Suave-Process库" class="headerlink" title="使用Suave.Process库"></a>使用<code>Suave.Process</code>库</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> Suave.Process<br><br><span class="hljs-keyword">let</span> executeCommand (command<span class="hljs-operator">:</span> <span class="hljs-type">string</span>) <span class="hljs-operator">=</span><br>    command<br>    <span class="hljs-operator">|&gt;</span> Shell.exec<br>    <span class="hljs-operator">|&gt;</span> Shell.stdout<br><br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> executeCommand <span class="hljs-string">&quot;dir&quot;</span><br><span class="hljs-built_in">printfn</span> <span class="hljs-string">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure><p>请确保已将<code>Suave.Process</code>库添加到项目引用中。</p><h2 id="使用外部命令包装器"><a href="#使用外部命令包装器" class="headerlink" title="使用外部命令包装器"></a>使用外部命令包装器</h2><h3 id="Fake"><a href="#Fake" class="headerlink" title="Fake"></a>Fake</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> Fake<br><br>Target <span class="hljs-string">&quot;ExecuteCommand&quot;</span> (<span class="hljs-keyword">fun</span> _ <span class="hljs-operator">-&gt;</span><br>    <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> Shell.ExecRead <span class="hljs-string">&quot;dir&quot;</span> <span class="hljs-operator">|&gt;</span> String.concat <span class="hljs-string">&quot;\n&quot;</span><br>    <span class="hljs-built_in">printfn</span> <span class="hljs-string">&quot;%s&quot;</span> result<br>)<br><br>RunTargetOrDefault <span class="hljs-string">&quot;ExecuteCommand&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Paket-CommandRunners"><a href="#Paket-CommandRunners" class="headerlink" title="Paket.CommandRunners"></a>Paket.CommandRunners</h3><p>在F#脚本中引入<code>Paket.CommandRunners</code>命名空间，并使用相关函数来执行Shell命令。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">open</span> System<br><span class="hljs-keyword">open</span> System.IO<br><span class="hljs-keyword">open</span> Paket.CommandRunners<br><br><span class="hljs-keyword">let</span> executeCommand (command<span class="hljs-operator">:</span> <span class="hljs-type">string</span>) <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">let</span> runner <span class="hljs-operator">=</span> CommandRunners.createProcessRunner()<br>    <span class="hljs-keyword">let</span> output, exitCode <span class="hljs-operator">=</span> runner.RunCommand(command, <span class="hljs-string">&quot;&quot;</span>)<br>  <br>    <span class="hljs-keyword">match</span> exitCode <span class="hljs-keyword">with</span><br>    <span class="hljs-operator">|</span> <span class="hljs-number">0</span> <span class="hljs-operator">-&gt;</span> output<br>    <span class="hljs-operator">|</span> _ <span class="hljs-operator">-&gt;</span> <span class="hljs-built_in">sprintf</span> <span class="hljs-string">&quot;Command failed with exit code %d:\n%s&quot;</span> exitCode output<br><br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> executeCommand <span class="hljs-string">&quot;dir&quot;</span><br><span class="hljs-built_in">printfn</span> <span class="hljs-string">&quot;%s&quot;</span> result<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个<code>CommandRunners.createProcessRunner()</code>来创建一个进程托管器。然后使用<code>RunCommand</code>方法执行Shell命令，并获取输出和退出码。</p><p>请注意，<code>Paket.CommandRunners</code>会自动下载所需的依赖项，并将其复制到正确的位置。</p><p>这是使用<code>Paket.CommandRunners</code>在F#中执行Shell命令的方式。你可以根据实际需求进行调整，并使用适当的参数和选项来定制命令执行过程。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python执行Shell</title>
    <link href="/2023/09/10/Python%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/Python%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="Python执行Shell"><a href="#Python执行Shell" class="headerlink" title="Python执行Shell"></a>Python执行Shell</h1><p>在Python中，有多种方法可以执行Shell命令。以下是一些常用的方法。</p><h2 id="使用os-system函数"><a href="#使用os-system函数" class="headerlink" title="使用os.system函数"></a>使用<code>os.system</code>函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.system(<span class="hljs-string">&quot;shell 命令&quot;</span>)<br></code></pre></td></tr></table></figure><p>该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。</p><h2 id="使用subprocess-run函数"><a href="#使用subprocess-run函数" class="headerlink" title="使用subprocess.run函数"></a>使用<code>subprocess.run</code>函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>subprocess.run(<span class="hljs-string">&quot;shell 命令&quot;</span>, shell=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>该方法执行命令，并可以通过<code>subprocess.CompletedProcess</code>对象获取命令的返回值、输出和错误信息。</p><h2 id="使用subprocess-Popen类"><a href="#使用subprocess-Popen类" class="headerlink" title="使用subprocess.Popen类"></a>使用<code>subprocess.Popen</code>类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>process = subprocess.Popen(<span class="hljs-string">&quot;shell 命令&quot;</span>, shell=<span class="hljs-literal">True</span>, stdout=subprocess.PIPE)<br>output, _ = process.communicate()<br><span class="hljs-built_in">print</span>(output.decode())<br></code></pre></td></tr></table></figure><p>该方法也可执行命令，并通过<code>Popen</code>对象控制进程和获取输出。这里使用<code>communicate()</code>方法获取命令的输出。</p><h2 id="使用os-popen函数（已过时）"><a href="#使用os-popen函数（已过时）" class="headerlink" title="使用os.popen函数（已过时）"></a>使用<code>os.popen</code>函数（已过时）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>output = os.popen(<span class="hljs-string">&quot;shell 命令&quot;</span>).read()<br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><p>该方法执行命令，并返回命令的输出。但由于安全性和可维护性等问题，不推荐使用。</p><h2 id="使用os-system函数-1"><a href="#使用os-system函数-1" class="headerlink" title="使用os.system函数"></a>使用<code>os.system</code>函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.system(<span class="hljs-string">&quot;shell 命令&quot;</span>)<br></code></pre></td></tr></table></figure><p>该方法简单直接，执行命令后会将结果输出到标准输出。但不方便获取命令执行的返回值。</p><h2 id="使用subprocess-check-output函数"><a href="#使用subprocess-check-output函数" class="headerlink" title="使用subprocess.check_output函数"></a>使用<code>subprocess.check_output</code>函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>output = subprocess.check_output(<span class="hljs-string">&quot;shell 命令&quot;</span>, shell=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(output.decode())<br></code></pre></td></tr></table></figure><p>该方法执行命令，并返回命令的输出。但如果命令返回非零状态码，则会引发<code>subprocess.CalledProcessError</code>异常。</p><h2 id="使用subprocess-Popen类-1"><a href="#使用subprocess-Popen类-1" class="headerlink" title="使用subprocess.Popen类"></a>使用<code>subprocess.Popen</code>类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>process = subprocess.Popen(<span class="hljs-string">&quot;shell 命令&quot;</span>, shell=<span class="hljs-literal">True</span>, stdout=subprocess.PIPE)<br>output, _ = process.communicate()<br><span class="hljs-built_in">print</span>(output.decode())<br></code></pre></td></tr></table></figure><p>该方法也可执行命令，并通过<code>Popen</code>对象控制进程和获取输出。这里使用<code>communicate()</code>方法获取命令的输出。</p><p>当然，还有一些其他的方法可以执行Shell命令。以下是其中几种常见的方法：</p><h2 id="使用os-exec-系列函数"><a href="#使用os-exec-系列函数" class="headerlink" title="使用os.exec*系列函数"></a>使用<code>os.exec*</code>系列函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.<span class="hljs-built_in">exec</span>*(命令)<br></code></pre></td></tr></table></figure><p>这里的<code>*</code>代表不同的函数，例如<code>os.execlp</code>、<code>os.execvp</code>等。这些函数会替换当前进程，并直接执行指定的命令。</p><h2 id="使用第三方库"><a href="#使用第三方库" class="headerlink" title="使用第三方库"></a>使用第三方库</h2><h3 id="sh库"><a href="#sh库" class="headerlink" title="sh库"></a>sh库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sh<br><br><span class="hljs-comment"># 执行命令并获取输出</span><br>output = sh.shell命令()<br><span class="hljs-built_in">print</span>(output)<br><br><span class="hljs-comment"># 指定命令路径执行</span><br>output = sh.Command(<span class="hljs-string">&#x27;命令路径&#x27;</span>)()<br><span class="hljs-built_in">print</span>(output)<br><br><span class="hljs-comment"># 处理命令的输入和输出</span><br>command = sh.Command(<span class="hljs-string">&#x27;命令路径&#x27;</span>)<br>output = command(<span class="hljs-string">&#x27;输入内容&#x27;</span>)<br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><p>在示例中，我们通过导入<code>sh</code>模块或者使用<code>Command</code>类来执行Shell命令。可以直接调用Shell命令作为函数，并使用<code>()</code>传递输入内容。还可以使用<code>Command</code>类指定命令的路径。</p><p><code>sh</code>库提供了简洁和易用的方式来执行Shell命令，并自动处理了输入和输出。你可以根据具体的需求使用<code>sh</code>库来执行Shell命令。</p><h3 id="plumbum库"><a href="#plumbum库" class="headerlink" title="plumbum库"></a><code>plumbum</code>库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> plumbum <span class="hljs-keyword">import</span> local<br><br><span class="hljs-comment"># 执行命令并获取输出</span><br>output = local[<span class="hljs-string">&quot;shell 命令&quot;</span>]()<br><span class="hljs-built_in">print</span>(output)<br><br><span class="hljs-comment"># 指定工作目录执行命令</span><br><span class="hljs-keyword">with</span> local.cwd(<span class="hljs-string">&quot;/path/to/directory&quot;</span>):<br>    output = local[<span class="hljs-string">&quot;shell 命令&quot;</span>]()<br><br><span class="hljs-comment"># 处理命令的输入和输出</span><br>cmd = local[<span class="hljs-string">&quot;shell 命令&quot;</span>]<br>output = cmd(<span class="hljs-string">&quot;输入内容&quot;</span>)<br><span class="hljs-built_in">print</span>(output)<br><br><span class="hljs-comment"># 获取命令执行的返回码</span><br>cmd = local[<span class="hljs-string">&quot;shell 命令&quot;</span>]<br>cmd.run()  <span class="hljs-comment"># 执行命令</span><br>return_code = cmd.returncode  <span class="hljs-comment"># 获取返回码</span><br></code></pre></td></tr></table></figure><p>在示例中，我们通过导入<code>local</code>对象来执行Shell命令。使用<code>local</code>对象，我们可以像调用函数一样来执行Shell命令，并通过<code>()</code>传递输入内容。还可以使用<code>cwd</code>方法指定执行命令时的工作目录。可以通过<code>run()</code>方法执行命令，并使用<code>returncode</code>属性获取返回码。</p><p><code>plumbum</code>库提供了更加简洁和高级的方式来执行Shell命令。它支持输入输出、文件操作以及远程命令执行等功能，具有更好的可读性和易用性。你可以根据自己的需求使用<code>plumbum</code>库来执行Shell命令。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qml执行Shell</title>
    <link href="/2023/09/10/Qml%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/Qml%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="Qml执行Shell"><a href="#Qml执行Shell" class="headerlink" title="Qml执行Shell"></a>Qml执行Shell</h1><p>在QML中执行Shell命令的方法取决于你正在使用的QML框架和操作系统。以下是一种常见的方法：</p><h2 id="在Qt-Quick中使用Qt-createQmlObject方法"><a href="#在Qt-Quick中使用Qt-createQmlObject方法" class="headerlink" title="在Qt Quick中使用Qt.createQmlObject方法"></a>在Qt Quick中使用Qt.createQmlObject方法</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> QtQuick <span class="hljs-number">2.0</span><br><span class="hljs-keyword">import</span> QtQml <span class="hljs-number">2.0</span><br><br><span class="hljs-title">Item</span> &#123;<br>    <span class="hljs-attribute">Component.onCompleted</span>: &#123;<br>        <span class="hljs-keyword">var</span> command = <span class="hljs-string">&quot;ls&quot;</span><br>        <span class="hljs-keyword">var</span> process = Qt.createQmlObject(<span class="hljs-string">&#x27;import QtQuick 2.0; import QtQml 2.0; Process &#123; command: &quot;&#x27;</span> + command + <span class="hljs-string">&#x27;&quot; &#125;&#x27;</span>, <span class="hljs-built_in">parent</span>)<br>        process.start()<br>        process.waitForFinished()<br>        <span class="hljs-built_in">console</span>.log(process.standardOutput())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们使用<code>Qt.createQmlObject</code>方法创建了一个Process对象，并指定了要执行的Shell命令（这里是”ls”）。然后我们启动这个进程，并等待其完成。最后，我们通过<code>process.standardOutput()</code>获取命令的输出结果。</p><h2 id="使用Qt-Framework中的QProcess类："><a href="#使用Qt-Framework中的QProcess类：" class="headerlink" title="使用Qt Framework中的QProcess类："></a>使用Qt Framework中的QProcess类：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QGuiApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QQmlApplicationEngine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QProcess&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QGuiApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class="hljs-built_in">load</span>(<span class="hljs-built_in">QUrl</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class="hljs-string">&quot;ls&quot;</span>;<br>    process.<span class="hljs-built_in">start</span>(command);<br>    process.<span class="hljs-built_in">waitForFinished</span>();<br><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QString</span>(process.<span class="hljs-built_in">readAllStandardOutput</span>());<br><br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们在C++中创建了一个QProcess对象，并指定了要执行的Shell命令（这里是”ls”）。然后，我们启动进程，并等待其完成。最后，我们通过<code>process.readAllStandardOutput()</code>获取命令的输出结果。</p><h2 id="使用JavaScript的Qt-createQmlObject-函数："><a href="#使用JavaScript的Qt-createQmlObject-函数：" class="headerlink" title="使用JavaScript的Qt.createQmlObject()函数："></a>使用JavaScript的<code>Qt.createQmlObject()</code>函数：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">QtQuick</span> <span class="hljs-number">2.0</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">QtQml</span> <span class="hljs-number">2.0</span><br><br><span class="hljs-title class_">Item</span> &#123;<br>    <span class="hljs-title class_">Component</span>.<span class="hljs-property">onCompleted</span>: &#123;<br>        <span class="hljs-keyword">var</span> command = <span class="hljs-string">&quot;ls&quot;</span><br>        <span class="hljs-keyword">var</span> process = <span class="hljs-title class_">Qt</span>.<span class="hljs-title function_">createQmlObject</span>(<span class="hljs-string">&#x27;import QtQuick 2.0; import QtQml 2.0; Process &#123; command: &quot;&#x27;</span> + command + <span class="hljs-string">&#x27;&quot; &#125;&#x27;</span>, parent)<br>        process.<span class="hljs-title function_">start</span>()<br>        process.<span class="hljs-title function_">waitForFinished</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-title function_">standardOutput</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法与第一个示例相同，只是使用了JavaScript的字符串拼接来创建QML对象。</p><h2 id="使用Qt的QProcess类和信号槽机制："><a href="#使用Qt的QProcess类和信号槽机制：" class="headerlink" title="使用Qt的QProcess类和信号槽机制："></a>使用Qt的<code>QProcess</code>类和信号槽机制：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QGuiApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QQmlApplicationEngine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QProcess&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QGuiApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class="hljs-built_in">load</span>(<span class="hljs-built_in">QUrl</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class="hljs-string">&quot;ls&quot;</span>;<br><br>    QObject::<span class="hljs-built_in">connect</span>(&amp;process, &amp;QProcess::readyReadStandardOutput, [&amp;]() &#123;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QString</span>(process.<span class="hljs-built_in">readAllStandardOutput</span>());<br>    &#125;);<br><br>    process.<span class="hljs-built_in">start</span>(command);<br>    process.<span class="hljs-built_in">waitForFinished</span>();<br><br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子与前面提到的使用<code>QProcess</code>的方法类似，但是使用了信号-槽机制。通过连接<code>readyReadStandardOutput</code>信号和一个Lambda表达式，我们可以在Shell命令输出可读取时触发相应的操作。</p><p>除了前面提到的方法，还可以考虑以下几种在QML中执行Shell命令的方法：</p><h2 id="使用Qt的QProcess类"><a href="#使用Qt的QProcess类" class="headerlink" title="使用Qt的QProcess类"></a>使用Qt的<code>QProcess</code>类</h2><p>在C++代码中实现一个自定义的QML扩展类型（QML Extension Type）来执行Shell命令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ShellCommand.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QObject&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QProcess&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShellCommand</span> : <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    <span class="hljs-function">Q_OBJECT</span><br><span class="hljs-function">    <span class="hljs-title">Q_PROPERTY</span><span class="hljs-params">(QString command READ command WRITE setCommand NOTIFY commandChanged)</span></span><br><span class="hljs-function">    <span class="hljs-title">Q_PROPERTY</span><span class="hljs-params">(QString output READ output NOTIFY outputChanged)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span>:</span><br><span class="hljs-function">    explicit ShellCommand(QObject *parent =</span> <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-function">QString <span class="hljs-title">command</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; command)</span></span>;<br><br>    <span class="hljs-function">QString <span class="hljs-title">output</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">public</span> slots:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<br><br>signals:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commandChanged</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outputChanged</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    QString m_command;<br>    QString m_output;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ShellCommand.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class="hljs-built_in">ShellCommand</span>(QObject *parent)<br>    : <span class="hljs-built_in">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class="hljs-function">QString <span class="hljs-title">ShellCommand::command</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> m_command;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellCommand::setCommand</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; command)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m_command != command) &#123;<br>        m_command = command;<br>        <span class="hljs-function">emit <span class="hljs-title">commandChanged</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">QString <span class="hljs-title">ShellCommand::output</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> m_output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellCommand::execute</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QProcess process;<br>    process.<span class="hljs-built_in">start</span>(m_command);<br>    process.<span class="hljs-built_in">waitForFinished</span>();<br>    m_output = process.<span class="hljs-built_in">readAllStandardOutput</span>();<br>    <span class="hljs-function">emit <span class="hljs-title">outputChanged</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在QML中使用这个自定义的QML扩展类型：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> QtQuick <span class="hljs-number">2.0</span><br><br><span class="hljs-title">ShellCommand</span> &#123;<br>    <span class="hljs-attribute">id:</span><span class="hljs-string"> shellCmd</span><br>    <span class="hljs-attribute">command</span>: <span class="hljs-string">&quot;ls&quot;</span><br>    <span class="hljs-attribute">onOutputChanged</span>: <span class="hljs-built_in">console</span>.log(shellCmd.output)<br>    <br>    <span class="hljs-attribute">Component.onCompleted</span>: &#123;<br>        shellCmd.execute()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们在C++中定义了一个名为<code>ShellCommand</code>的自定义QML扩展类型，在其中使用<code>QProcess</code>来执行Shell命令，并将输出结果保存到<code>output</code>属性中。在QML中，我们创建了一个<code>ShellCommand</code>实例并指定要执行的命令，并通过监听<code>outputChanged</code>信号来打印输出结果。</p><h2 id="使用Qt的QProcess类并将输出结果绑定到一个QML属性"><a href="#使用Qt的QProcess类并将输出结果绑定到一个QML属性" class="headerlink" title="使用Qt的QProcess类并将输出结果绑定到一个QML属性"></a>使用Qt的<code>QProcess</code>类并将输出结果绑定到一个QML属性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QGuiApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QQmlApplicationEngine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QProcess&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QGuiApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    QQmlApplicationEngine engine;<br>    engine.<span class="hljs-built_in">load</span>(<span class="hljs-built_in">QUrl</span>(<span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">&quot;qrc:/main.qml&quot;</span>)));<br><br>    QProcess process;<br>    QString command = <span class="hljs-string">&quot;ls&quot;</span>;<br>    process.<span class="hljs-built_in">start</span>(command);<br>    process.<span class="hljs-built_in">waitForFinished</span>();<br><br>    engine.<span class="hljs-built_in">rootContext</span>()-&gt;<span class="hljs-built_in">setContextProperty</span>(<span class="hljs-string">&quot;shellOutput&quot;</span>, <span class="hljs-built_in">QString</span>(process.<span class="hljs-built_in">readAllStandardOutput</span>()));<br><br>    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们在C++中执行Shell命令，并将输出结果绑定到一个名为<code>shellOutput</code>的QML属性中。然后可以在QML中直接访问该属性来获取输出结果。</p><h2 id="在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML"><a href="#在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML" class="headerlink" title="在QML中执行Shell命令的方法是使用Qt的QProcess类并将输出结果通过信号传递给QML"></a>在QML中执行Shell命令的方法是使用Qt的<code>QProcess</code>类并将输出结果通过信号传递给QML</h2><p>首先，在C++代码中定义一个继承自<code>QObject</code>的类，用于执行Shell命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ShellCommand.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QObject&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QProcess&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShellCommand</span> : <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ShellCommand</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br><br><span class="hljs-keyword">public</span> slots:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; command)</span></span>;<br><br>signals:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outputReady</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; output)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ShellCommand.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class="hljs-built_in">ShellCommand</span>(QObject *parent)<br>    : <span class="hljs-built_in">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellCommand::execute</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; command)</span></span><br><span class="hljs-function"></span>&#123;<br>    QProcess process;<br>    process.<span class="hljs-built_in">start</span>(command);<br>    process.<span class="hljs-built_in">waitForFinished</span>();<br>    QString output = process.<span class="hljs-built_in">readAllStandardOutput</span>();<br>    <span class="hljs-function">emit <span class="hljs-title">outputReady</span><span class="hljs-params">(output)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在QML中引入该C++类，并使用<code>Connections</code>元素来处理信号：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> QtQuick <span class="hljs-number">2.0</span><br><br><span class="hljs-title">Item</span> &#123;<br>    <span class="hljs-attribute">id:</span><span class="hljs-string"> root</span><br>    <span class="hljs-keyword">property</span><span class="hljs-string"> string command</span>: <span class="hljs-string">&quot;ls&quot;</span><br>    <span class="hljs-keyword">property</span><span class="hljs-string"> string output</span>: <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-title">Connections</span> &#123;<br>        <span class="hljs-attribute">target</span>: shellCommand<br>        <span class="hljs-attribute">onOutputReady</span>: &#123;<br>            root.output = output<br>            <span class="hljs-built_in">console</span>.log(output)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title">ShellCommand</span> &#123;<br>        <span class="hljs-attribute">id:</span><span class="hljs-string"> shellCommand</span><br>    &#125;<br><br>    <span class="hljs-attribute">Component.onCompleted</span>: &#123;<br>        shellCommand.execute(root.command)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们在QML中创建了一个名为<code>shellCommand</code>的<code>ShellCommand</code>对象，并指定要执行的命令为<code>root.command</code>属性。通过使用<code>Connections</code>元素，我们连接了<code>shellCommand</code>对象的<code>outputReady</code>信号，并在信号触发时将输出结果赋值给<code>root.output</code>属性，并显示在控制台中。</p><p>使用这种方法，可以将Shell命令的执行与QML中其他元素的行为和状态关联起来。</p><h2 id="使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。"><a href="#使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。" class="headerlink" title="使用Qt的QProcess类和信号槽机制来执行Shell命令并获取输出结果。"></a>使用Qt的<code>QProcess</code>类和信号槽机制来执行Shell命令并获取输出结果。</h2><p>在C++代码中，定义一个继承自<code>QObject</code>的类，用于执行Shell命令并发送输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ShellCommand.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QObject&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QProcess&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShellCommand</span> : <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ShellCommand</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br><br><span class="hljs-keyword">public</span> slots:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; command)</span></span>;<br><br>signals:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outputReady</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; output)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ShellCommand.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ShellCommand.h&quot;</span></span><br><br>ShellCommand::<span class="hljs-built_in">ShellCommand</span>(QObject *parent)<br>    : <span class="hljs-built_in">QObject</span>(parent)<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellCommand::execute</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; command)</span></span><br><span class="hljs-function"></span>&#123;<br>    QProcess process;<br>    process.<span class="hljs-built_in">start</span>(command);<br>    process.<span class="hljs-built_in">waitForFinished</span>();<br>    QString output = process.<span class="hljs-built_in">readAllStandardOutput</span>();<br>    <span class="hljs-function">emit <span class="hljs-title">outputReady</span><span class="hljs-params">(output)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在QML中通过<code>Qt.createQmlObject()</code>函数创建一个匿名的JavaScript对象，并将其绑定到一个QML属性上：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> QtQuick <span class="hljs-number">2.0</span><br><br><span class="hljs-title">Item</span> &#123;<br>    <span class="hljs-attribute">id:</span><span class="hljs-string"> root</span><br>    <span class="hljs-keyword">property</span><span class="hljs-string"> string command</span>: <span class="hljs-string">&quot;ls&quot;</span><br>    <span class="hljs-keyword">property</span><span class="hljs-string"> string output</span>: <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-attribute">Component.onCompleted</span>: &#123;<br>        <span class="hljs-keyword">var</span> shellCommand = Qt.createQmlObject(<span class="hljs-string">&#x27;import QtQuick 2.0; QtObject &#123; signal outputReady(string output); function execute(command) &#123; var process = Qt.createQmlObject(&quot;import QtQuick 2.0; Process &#123; ... &#125;&quot;, this); process.command = command; process.finished.connect(function() &#123; outputReady(process.output); &#125;); process.start(); &#125;&#125;&#x27;</span>, root, <span class="hljs-string">&quot;shellCommand&quot;</span>);<br>        shellCommand.outputReady.connect(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">output</span>) </span>&#123;<br>            root.output = output;<br>            <span class="hljs-built_in">console</span>.log(output);<br>        &#125;);<br>        shellCommand.execute(root.command);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用<code>Qt.createQmlObject()</code>函数，我们在QML中动态创建了一个匿名的JavaScript对象，并将其绑定到<code>root</code>对象上。这个JavaScript对象具有一个<code>execute()</code>方法用于执行Shell命令，并且会发送一个<code>outputReady</code>信号来传递输出结果。</p><p>在这个例子中，当<code>Component.onCompleted</code>事件触发时，会创建该JavaScript对象并执行Shell命令。通过连接<code>outputReady</code>信号，我们可以更新<code>root.output</code>属性并在控制台中打印输出结果。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala执行Shell</title>
    <link href="/2023/09/10/Scala%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/Scala%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="Scala执行Shell"><a href="#Scala执行Shell" class="headerlink" title="Scala执行Shell"></a>Scala执行Shell</h1><p>在Scala中，可以使用以下几种方式执行shell命令：</p><h2 id="使用Java的ProcessBuilder类"><a href="#使用Java的ProcessBuilder类" class="headerlink" title="使用Java的ProcessBuilder类"></a>使用Java的<code>ProcessBuilder</code>类</h2><p>可以通过创建<code>ProcessBuilder</code>对象，并设置要执行的shell命令，然后使用<code>.start()</code>方法启动进程并执行命令。以下是一个示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> java.io._<br><br><span class="hljs-keyword">val</span> command = <span class="hljs-string">&quot;ls -l&quot;</span><br><span class="hljs-keyword">val</span> processBuilder = <span class="hljs-keyword">new</span> <span class="hljs-type">ProcessBuilder</span>(command.split(<span class="hljs-string">&quot;\\s+&quot;</span>): _*)<br><span class="hljs-keyword">val</span> process = processBuilder.start()<br><br><span class="hljs-keyword">val</span> inputStream = process.getInputStream<br><span class="hljs-keyword">val</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(inputStream))<br><br><span class="hljs-keyword">var</span> line: <span class="hljs-type">String</span> = <span class="hljs-literal">null</span><br><span class="hljs-keyword">while</span> (&#123;line = reader.readLine(); line != <span class="hljs-literal">null</span>&#125;) &#123;<br>  println(line)<br>&#125;<br><br>process.waitFor()<br></code></pre></td></tr></table></figure><p>这个示例中使用了<code>ls -l</code>命令来列出当前目录下的文件和文件夹。</p><h2 id="使用sys-process包"><a href="#使用sys-process包" class="headerlink" title="使用sys.process包"></a>使用<code>sys.process</code>包</h2><p>Scala提供了一个方便的<code>sys.process</code>包，可以使用其中的<code>Process</code>类来执行shell命令。以下是示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> sys.process._<br><br><span class="hljs-keyword">val</span> command = <span class="hljs-string">&quot;ls -l&quot;</span><br><span class="hljs-keyword">val</span> output = command.!!<br>println(output)<br></code></pre></td></tr></table></figure><p>这个示例中，<code>!!</code>操作符会执行shell命令并返回输出结果。</p><h2 id="使用scala-sys-process-Process类"><a href="#使用scala-sys-process-Process类" class="headerlink" title="使用scala.sys.process.Process类"></a>使用<code>scala.sys.process.Process</code>类</h2><p>和前面的方法类似，也是使用<code>Process</code>类执行shell命令。以下是示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.sys.process._<br><br><span class="hljs-keyword">val</span> command = <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>)<br><span class="hljs-keyword">val</span> process = <span class="hljs-type">Process</span>(command)<br><span class="hljs-keyword">val</span> output = process.!!<br>println(output)<br></code></pre></td></tr></table></figure><p>这个示例中使用了<code>Seq</code>来定义命令和参数，然后使用<code>!!</code>操作符执行命令并返回输出结果。</p><h2 id="使用java-lang-Runtime类"><a href="#使用java-lang-Runtime类" class="headerlink" title="使用java.lang.Runtime类"></a>使用<code>java.lang.Runtime</code>类</h2><p>Scala可以直接使用Java的<code>Runtime</code>类来执行shell命令。以下是示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> java.lang.<span class="hljs-type">Runtime</span><br><br><span class="hljs-keyword">val</span> command = <span class="hljs-string">&quot;ls -l&quot;</span><br><span class="hljs-keyword">val</span> runtime = <span class="hljs-type">Runtime</span>.getRuntime<br><span class="hljs-keyword">val</span> process = runtime.exec(command)<br><br><span class="hljs-keyword">val</span> inputStream = process.getInputStream<br><span class="hljs-keyword">val</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(inputStream))<br><br><span class="hljs-keyword">var</span> line: <span class="hljs-type">String</span> = <span class="hljs-literal">null</span><br><span class="hljs-keyword">while</span> (&#123;line = reader.readLine(); line != <span class="hljs-literal">null</span>&#125;) &#123;<br>  println(line)<br>&#125;<br><br>process.waitFor()<br></code></pre></td></tr></table></figure><p>这个示例中使用了<code>Runtime.getRuntime</code>获取当前运行时环境的<code>Runtime</code>对象，然后使用<code>exec</code>方法执行shell命令，并读取命令的输出结果。</p><h2 id="使用scala-sys-process-ProcessBuilder类"><a href="#使用scala-sys-process-ProcessBuilder类" class="headerlink" title="使用scala.sys.process.ProcessBuilder类"></a>使用<code>scala.sys.process.ProcessBuilder</code>类</h2><p>Scala的<code>sys.process</code>包还提供了<code>ProcessBuilder</code>类，它是对Java中的<code>ProcessBuilder</code>类的封装，提供了更加方便的链式调用方式。以下是示例代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.sys.process._<br><br><span class="hljs-keyword">val</span> command = <span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>)<br><span class="hljs-keyword">val</span> processBuilder = <span class="hljs-type">Process</span>(command)<br>  .run(<span class="hljs-type">ProcessLogger</span>(line =&gt; println(line)))<br><br>processBuilder.exitValue()<br></code></pre></td></tr></table></figure><p>这个示例中使用了<code>Process</code>类的<code>run</code>方法来执行shell命令，同时通过<code>ProcessLogger</code>指定了命令输出的处理方式，这里简单地将每一行输出打印出来。最后使用<code>exitValue</code>方法获取命令的退出值。</p><p>这些方法都可以根据具体的需求选择适合的方式来执行shell命令。请根据实际情况选择合适的方法，并注意处理命令执行可能出现的异常情况。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js执行Shell</title>
    <link href="/2023/09/10/Node%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/Node%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js执行Shell"><a href="#Node-js执行Shell" class="headerlink" title="Node.js执行Shell"></a>Node.js执行Shell</h1><p>在 Node.js 中执行 Shell 命令有多种方法。以下是几种常用的方法：</p><h2 id="child-process-模块："><a href="#child-process-模块：" class="headerlink" title="child_process 模块："></a><code>child_process</code> 模块：</h2><h3 id="使用-exec-方法执行-Shell-命令"><a href="#使用-exec-方法执行-Shell-命令" class="headerlink" title="使用 exec 方法执行 Shell 命令"></a>使用 exec 方法执行 Shell 命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ls -a&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`错误输出: <span class="hljs-subst">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="使用-spawn-方法执行-Shell-命令"><a href="#使用-spawn-方法执行-Shell-命令" class="headerlink" title="使用 spawn 方法执行 Shell 命令"></a>使用 spawn 方法执行 Shell 命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; spawn &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-a&#x27;</span>]);<br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`错误输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程退出码: <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="execSync-方法："><a href="#execSync-方法：" class="headerlink" title="execSync 方法："></a><code>execSync</code> 方法：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; execSync &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> stdout = <span class="hljs-title function_">execSync</span>(<span class="hljs-string">&#x27;ls -a&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shelljs模块："><a href="#shelljs模块：" class="headerlink" title="shelljs模块："></a><code>shelljs</code>模块：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shell = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;shelljs&#x27;</span>);<br><br><span class="hljs-comment">// 执行 Shell 命令，并获取输出</span><br><span class="hljs-keyword">const</span> result = shell.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ls -a&#x27;</span>);<br><span class="hljs-keyword">if</span> (result.<span class="hljs-property">code</span> !== <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;result.stderr&#125;</span>`</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;result.stdout&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h2 id="execa-模块"><a href="#execa-模块" class="headerlink" title="execa 模块"></a><code>execa</code> 模块</h2><p>提供了一个简单且强大的接口来执行外部命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> execa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;execa&#x27;</span>);<br><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; stdout &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">execa</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-a&#x27;</span>]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="node-pty-模块"><a href="#node-pty-模块" class="headerlink" title="node-pty 模块"></a><code>node-pty</code> 模块</h2><p>这是一个伪终端的库，允许你与 Shell 进行交互式通信</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br><span class="hljs-keyword">const</span> pty = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;node-pty&#x27;</span>);<br><br><span class="hljs-keyword">const</span> shell = os.<span class="hljs-title function_">platform</span>() === <span class="hljs-string">&#x27;win32&#x27;</span> ? <span class="hljs-string">&#x27;cmd.exe&#x27;</span> : <span class="hljs-string">&#x27;bash&#x27;</span>;<br><span class="hljs-keyword">const</span> ptyProcess = pty.<span class="hljs-title function_">spawn</span>(shell, [], &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xterm-color&#x27;</span>,<br>  <span class="hljs-attr">cols</span>: <span class="hljs-number">80</span>,<br>  <span class="hljs-attr">rows</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">cwd</span>: process.<span class="hljs-title function_">cwd</span>(),<br>  <span class="hljs-attr">env</span>: process.<span class="hljs-property">env</span><br>&#125;);<br><br>ptyProcess.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ptyProcess.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;ls -a\r&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="shelljs-exec-proxy-模块"><a href="#shelljs-exec-proxy-模块" class="headerlink" title="shelljs-exec-proxy 模块"></a><code>shelljs-exec-proxy</code> 模块</h2><p>这是一个对 <code>shelljs</code> 的封装，提供了更简洁的方式来执行 Shell 命令并处理输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shell = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;shelljs-exec-proxy&#x27;</span>);<br><br><span class="hljs-keyword">const</span> &#123; code, stdout, stderr &#125; = <span class="hljs-title function_">shell</span>(<span class="hljs-string">&#x27;ls -a&#x27;</span>);<br><span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;stderr&#125;</span>`</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h2 id="simple-git-模块"><a href="#simple-git-模块" class="headerlink" title="simple-git 模块"></a><code>simple-git</code> 模块</h2><p>这是一个用于管理 Git 仓库的库，它也提供了执行 Shell 命令的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> simpleGit = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;simple-git&#x27;</span>);<br><br><span class="hljs-keyword">const</span> git = <span class="hljs-title function_">simpleGit</span>();<br>git.<span class="hljs-title function_">raw</span>([<span class="hljs-string">&#x27;ls-files&#x27;</span>, <span class="hljs-string">&#x27;-z&#x27;</span>], <span class="hljs-function">(<span class="hljs-params">error, result</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="ssh2-模块"><a href="#ssh2-模块" class="headerlink" title="ssh2 模块"></a><code>ssh2</code> 模块</h2><p>这是一个用于通过 SSH 执行 Shell 命令的库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Client</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ssh2&#x27;</span>).<span class="hljs-property">Client</span>;<br><br><span class="hljs-keyword">const</span> conn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br>conn.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  conn.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ls -a&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, stream</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code, signal</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程退出码: <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>      conn.<span class="hljs-title function_">end</span>();<br>    &#125;).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>    &#125;).<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`错误输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>    &#125;);<br>  &#125;);<br>&#125;).<span class="hljs-title function_">connect</span>(&#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;example.com&#x27;</span>,<br>  <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;username&#x27;</span>,<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;password&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="cross-spawn-模块"><a href="#cross-spawn-模块" class="headerlink" title="cross-spawn 模块"></a><code>cross-spawn</code> 模块</h2><p>这是一个跨平台的库，可以在 Windows 和 Unix 系统上执行 Shell 命令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cross-spawn&#x27;</span>);<br><br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-a&#x27;</span>]);<br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`错误输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`子进程退出码: <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="shell-exec-模块"><a href="#shell-exec-模块" class="headerlink" title="shell-exec 模块"></a><code>shell-exec</code> 模块</h2><p>这是另一个对 Shell 命令的封装，它提供了一个简单的接口来执行命令并处理输出。</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shellExec = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;shell-exec&#x27;</span>);<br><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">shellExec</span>(<span class="hljs-string">&#x27;ls -a&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (result.<span class="hljs-property">code</span> !== <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;result.stderr&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;result.stdout&#125;</span>`</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>当然，还有一些其他的方法：</p><h2 id="node-pty-模块-1"><a href="#node-pty-模块-1" class="headerlink" title="node-pty 模块"></a><code>node-pty</code> 模块</h2><p>这是一个能够让你生成一个伪终端并与其中运行 Shell 命令的库。它在计算机和服务器上都可以工作，并使你能够与 Shell 交互。</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br><span class="hljs-keyword">const</span> pty = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;node-pty&#x27;</span>);<br><br><span class="hljs-keyword">const</span> term = pty.<span class="hljs-title function_">spawn</span>(os.<span class="hljs-title function_">platform</span>() === <span class="hljs-string">&#x27;win32&#x27;</span> ? <span class="hljs-string">&#x27;cmd.exe&#x27;</span> : <span class="hljs-string">&#x27;bash&#x27;</span>, [], &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xterm-color&#x27;</span>,<br>  <span class="hljs-attr">cwd</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">HOME</span>,<br>  <span class="hljs-attr">env</span>: process.<span class="hljs-property">env</span><br>&#125;);<br><br>term.<span class="hljs-title function_">onData</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`输出: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>term.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;ls\r&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="runas-模块"><a href="#runas-模块" class="headerlink" title="runas 模块"></a><code>runas</code> 模块</h2><p>这个库允许你在 Windows 系统上以管理员身份运行 Shell 命令。</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> runas = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;runas&#x27;</span>);<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-title function_">runas</span>(<span class="hljs-string">&#x27;%windir%\\system32\\ipconfig.exe /all&#x27;</span>, &#123;<br>    <span class="hljs-attr">admin</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">hide</span>: <span class="hljs-literal">true</span><br>  &#125;);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="node-cmd-模块"><a href="#node-cmd-模块" class="headerlink" title="node-cmd 模块"></a><code>node-cmd</code> 模块</h2><p>这是一个能够在 Node.js 中执行 Shell 命令的简单库，它提供了简洁的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> cmd = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;node-cmd&#x27;</span>);<br><br>cmd.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;ls -a&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`执行命令出错: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`标准输出: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`错误输出: <span class="hljs-subst">$&#123;stderr&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#执行Shell</title>
    <link href="/2023/09/10/C-Sharp%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/C-Sharp%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="C-执行Shell"><a href="#C-执行Shell" class="headerlink" title="C#执行Shell"></a>C#执行Shell</h1><p>在C#中执行Shell命令有多种方法</p><h2 id="使用System-Diagnostics-Process类："><a href="#使用System-Diagnostics-Process类：" class="headerlink" title="使用System.Diagnostics.Process类："></a>使用System.Diagnostics.Process类：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> command = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br>Process process = <span class="hljs-keyword">new</span> Process();<br>ProcessStartInfo startInfo = <span class="hljs-keyword">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class="hljs-string">&quot;cmd.exe&quot;</span>;<br>startInfo.Arguments = <span class="hljs-string">&quot;/c &quot;</span> + command; <span class="hljs-comment">// 如果是使用 PowerShell 命令，则将 &quot;/c&quot; 改为 &quot;/k&quot;</span><br>startInfo.RedirectStandardOutput = <span class="hljs-literal">true</span>;<br>startInfo.UseShellExecute = <span class="hljs-literal">false</span>;<br>startInfo.CreateNoWindow = <span class="hljs-literal">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class="hljs-built_in">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure><h2 id="使用System-Diagnostics-Process类和PowerShell："><a href="#使用System-Diagnostics-Process类和PowerShell：" class="headerlink" title="使用System.Diagnostics.Process类和PowerShell："></a>使用System.Diagnostics.Process类和PowerShell：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> command = <span class="hljs-string">&quot;Get-Process&quot;</span>;<br>Process process = <span class="hljs-keyword">new</span> Process();<br>ProcessStartInfo startInfo = <span class="hljs-keyword">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class="hljs-string">&quot;powershell.exe&quot;</span>;<br>startInfo.Arguments = command;<br>startInfo.RedirectStandardOutput = <span class="hljs-literal">true</span>;<br>startInfo.UseShellExecute = <span class="hljs-literal">false</span>;<br>startInfo.CreateNoWindow = <span class="hljs-literal">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class="hljs-built_in">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure><h2 id="使用System-Management命名空间的ManagementObject类（需要引用System-Management-dll）："><a href="#使用System-Management命名空间的ManagementObject类（需要引用System-Management-dll）：" class="headerlink" title="使用System.Management命名空间的ManagementObject类（需要引用System.Management.dll）："></a>使用System.Management命名空间的ManagementObject类（需要引用System.Management.dll）：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> command = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br>ManagementClass processClass = <span class="hljs-keyword">new</span> ManagementClass(<span class="hljs-string">&quot;Win32_Process&quot;</span>);<br><span class="hljs-built_in">object</span>[] methodArgs = &#123; command, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">object</span> result = processClass.InvokeMethod(<span class="hljs-string">&quot;Create&quot;</span>, methodArgs);<br><span class="hljs-built_in">int</span> exitCode = Convert.ToInt32(result);<br></code></pre></td></tr></table></figure><p>当然，还有其他一些执行Shell命令的方法。以下是其中的两种：</p><h2 id="使用System-Diagnostics-Process类和WMI（Windows-Management-Instrumentation）："><a href="#使用System-Diagnostics-Process类和WMI（Windows-Management-Instrumentation）：" class="headerlink" title="使用System.Diagnostics.Process类和WMI（Windows Management Instrumentation）："></a>使用System.Diagnostics.Process类和WMI（Windows Management Instrumentation）：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> command = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br>Process process = <span class="hljs-keyword">new</span> Process();<br>ProcessStartInfo startInfo = <span class="hljs-keyword">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class="hljs-string">&quot;cmd.exe&quot;</span>;<br>startInfo.Arguments = <span class="hljs-string">&quot;/c &quot;</span> + command; <span class="hljs-comment">// 如果是使用 PowerShell 命令，则将 &quot;/c&quot; 改为 &quot;/k&quot;</span><br>startInfo.RedirectStandardOutput = <span class="hljs-literal">true</span>;<br>startInfo.UseShellExecute = <span class="hljs-literal">false</span>;<br>startInfo.CreateNoWindow = <span class="hljs-literal">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class="hljs-built_in">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure><h2 id="使用Microsoft-VisualBasic-Interaction类："><a href="#使用Microsoft-VisualBasic-Interaction类：" class="headerlink" title="使用Microsoft.VisualBasic.Interaction类："></a>使用Microsoft.VisualBasic.Interaction类：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> command = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br><span class="hljs-built_in">string</span> output = Microsoft.VisualBasic.Interaction.Shell(command, AppWinStyle.Hide, <span class="hljs-literal">true</span>, <span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="使用System-Runtime-InteropServices引用DLL文件："><a href="#使用System-Runtime-InteropServices引用DLL文件：" class="headerlink" title="使用System.Runtime.InteropServices引用DLL文件："></a>使用System.Runtime.InteropServices引用DLL文件：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, SetLastError = true)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CreateProcess</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> lpApplicationName, <span class="hljs-built_in">string</span> lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-built_in">bool</span> bInheritHandles, <span class="hljs-built_in">uint</span> dwCreationFlags, IntPtr lpEnvironment, <span class="hljs-built_in">string</span> lpCurrentDirectory,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-keyword">ref</span> STARTUPINFO lpStartupInfo, <span class="hljs-keyword">out</span> PROCESS_INFORMATION lpProcessInformation</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, SetLastError = true)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WaitForSingleObject</span>(<span class="hljs-params">IntPtr hHandle, <span class="hljs-built_in">uint</span> dwMilliseconds</span>)</span>;<br><br><span class="hljs-keyword">struct</span> PROCESS_INFORMATION<br>&#123;<br>    <span class="hljs-keyword">public</span> IntPtr hProcess;<br>    <span class="hljs-keyword">public</span> IntPtr hThread;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwProcessId;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwThreadId;<br>&#125;<br><br><span class="hljs-keyword">struct</span> STARTUPINFO<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> cb;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> lpReserved;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> lpDesktop;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> lpTitle;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwX;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwY;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwXSize;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwYSize;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwXCountChars;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwYCountChars;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwFillAttribute;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> dwFlags;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> wShowWindow;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> cbReserved2;<br>    <span class="hljs-keyword">public</span> IntPtr lpReserved2;<br>    <span class="hljs-keyword">public</span> IntPtr hStdInput;<br>    <span class="hljs-keyword">public</span> IntPtr hStdOutput;<br>    <span class="hljs-keyword">public</span> IntPtr hStdError;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    <span class="hljs-built_in">string</span> command = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br>    STARTUPINFO startupInfo = <span class="hljs-keyword">new</span> STARTUPINFO();<br>    PROCESS_INFORMATION processInfo = <span class="hljs-keyword">new</span> PROCESS_INFORMATION();<br>    <br>    <span class="hljs-built_in">bool</span> success = CreateProcess(<span class="hljs-literal">null</span>, command, IntPtr.Zero, IntPtr.Zero, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, IntPtr.Zero, <span class="hljs-literal">null</span>, <span class="hljs-keyword">ref</span> startupInfo, <span class="hljs-keyword">out</span> processInfo);<br>    <span class="hljs-keyword">if</span> (success)<br>    &#123;<br>        WaitForSingleObject(processInfo.hProcess, <span class="hljs-number">0xFFFFFFFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法使用了Platform Invoke技术，可以直接调用Windows的API函数来执行Shell命令。请注意，使用此方法需要在代码中引用System.Runtime.InteropServices命名空间，并确保正确设置结构体和函数调用。同样地，在执行Shell命令时，需要谨慎处理输入内容和安全问题。</p><p>当然，还有一种方法可以执行Shell命令：</p><h2 id="使用System-Diagnostics-Process类和PowerShell-Core："><a href="#使用System-Diagnostics-Process类和PowerShell-Core：" class="headerlink" title="使用System.Diagnostics.Process类和PowerShell Core："></a>使用System.Diagnostics.Process类和PowerShell Core：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> command = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br>Process process = <span class="hljs-keyword">new</span> Process();<br>ProcessStartInfo startInfo = <span class="hljs-keyword">new</span> ProcessStartInfo();<br>startInfo.FileName = <span class="hljs-string">&quot;pwsh.exe&quot;</span>; <span class="hljs-comment">// PowerShell Core的可执行文件路径</span><br>startInfo.Arguments = <span class="hljs-string">&quot;-Command &quot;</span> + command;<br>startInfo.RedirectStandardOutput = <span class="hljs-literal">true</span>;<br>startInfo.UseShellExecute = <span class="hljs-literal">false</span>;<br>startInfo.CreateNoWindow = <span class="hljs-literal">true</span>;<br><br>process.StartInfo = startInfo;<br>process.Start();<br><br><span class="hljs-built_in">string</span> output = process.StandardOutput.ReadToEnd();<br><br>process.WaitForExit();<br></code></pre></td></tr></table></figure><p>这种方法使用了PowerShell Core的可执行文件（<code>pwsh.exe</code>）来执行Shell命令。需要注意，你需要先安装并配置好PowerShell Core，并将其可执行文件的路径正确填写到代码中(或者添加到环境变量中)。</p><p>以上是使用C#执行Shell命令的几种常见方法，可以根据具体需求选择适合的方法进行操作。请务必确保输入内容的安全性，并谨慎处理可能存在的风险。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust执行CMD</title>
    <link href="/2023/09/10/Rust%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/10/Rust%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust执行Shell"><a href="#Rust执行Shell" class="headerlink" title="Rust执行Shell"></a>Rust执行Shell</h1><p>使用Cargo创建一个Rust项目。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::process::Command;  <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;cmd.exe&quot;</span>).<span class="hljs-title function_ invoke__">arg</span>(<span class="hljs-string">&quot;/c&quot;</span>).<span class="hljs-title function_ invoke__">arg</span>(<span class="hljs-string">&quot;pause&quot;</span>).<span class="hljs-title function_ invoke__">status</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将 .arg(“pause”) 中的内容替换为其他命令。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++执行Shell</title>
    <link href="/2023/09/09/C++%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/09/C++%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="C-执行Shell"><a href="#C-执行Shell" class="headerlink" title="C++执行Shell"></a>C++执行Shell</h1><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string command = <span class="hljs-string">&quot;dir&quot;</span>; <span class="hljs-comment">// 将要执行的 cmd 命令(例如ipconfig，ping等)</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">system</span>(command.<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// 执行命令，并获得返回值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Command result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// 输出返回值</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码将执行 dir 命令，并输出命令的返回值。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C执行Shell</title>
    <link href="/2023/09/09/C%E6%89%A7%E8%A1%8CShell/"/>
    <url>/2023/09/09/C%E6%89%A7%E8%A1%8CShell/</url>
    
    <content type="html"><![CDATA[<h1 id="C执行Shell"><a href="#C执行Shell" class="headerlink" title="C执行Shell"></a>C执行Shell</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> command[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;dir&quot;</span>; <span class="hljs-comment">// 将要执行的 cmd 命令</span><br>    FILE *fp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> res[<span class="hljs-number">1024</span>];<br><br>    fp = popen(command, <span class="hljs-string">&quot;r&quot;</span>); <span class="hljs-comment">// 执行命令，并打开读取管道</span><br>     <br>    <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 判断是否成功打开管道</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;运行命令失败\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>     <br>    <span class="hljs-keyword">while</span> (fgets(res, <span class="hljs-keyword">sizeof</span>(res), fp) != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 从管道中读取输出结果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, res);<br>    &#125;<br>    <br>    pclose(fp); <span class="hljs-comment">// 关闭管道</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个示例代码将执行 dir 命令，并输出命令的输出结果。可以替换 command 变量的值为需要执行的命令。</p><p>这个实现使用了标准 C 库函数中的 popen() 和 pclose() 函数来执行命令和关闭读取管道。popen() 函数打开一个管道用于读取命令的输出，返回的文件指针 fp 可以用于读取管道中的内容。pclose() 函数关闭读取管道。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Basic调用Shell</title>
    <link href="/2023/09/09/Visual-Basic%E8%B0%83%E7%94%A8Shell/"/>
    <url>/2023/09/09/Visual-Basic%E8%B0%83%E7%94%A8Shell/</url>
    
    <content type="html"><![CDATA[<h1 id="Visual-Basic调用Shell"><a href="#Visual-Basic调用Shell" class="headerlink" title="Visual Basic调用Shell"></a>Visual Basic调用Shell</h1><p>使用Visual Studio创建一个Visual Basic项目，本文以控制台项目演示。</p><p>输入以下代码</p><figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs visual">Module Module1<br><br>    Sub Main()<br>        Shell(&quot;cmd.exe /c echo 1&amp;&amp;pause&quot;)<br>    End Sub<br><br>End Module<br></code></pre></td></tr></table></figure><p>Visual Studio可能自动生成了除shell以外的代码。</p><p>调整执行命令只需修改本代码段“echo 1”与“pause”即可。</p><hr><p>当然，以下是一个在 Windows 平台更好的方法。</p><p>代码如下：</p><figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs visual">Dim command As String<br>command = &quot;dir&quot;<br><br>Dim shell As Object<br>Set shell = CreateObject(&quot;WScript.Shell&quot;)<br><br>Dim exec As Object<br>Set exec = shell.Exec(&quot;cmd /c &quot; &amp; command)<br><br>Do While exec.Status = 0<br>    WScript.Sleep 100<br>Loop<br><br>Dim output As String<br>output = exec.StdOut.ReadAll<br><br>WScript.Echo output<br></code></pre></td></tr></table></figure><p>这段示例代码将执行 dir 命令，并在控制台输出命令的结果。你可以将需要执行的命令赋值给 command 变量。</p><p>本代码使用了 Windows Script Host 对象模型，通过 CreateObject() 函数创建了一个 WScript.Shell 对象，并调用其 Exec() 方法来执行 cmd 命令。Exec() 方法返回一个 WshScriptExec 对象，该对象的 Status 属性表示当前命令执行状态，StdOut 属性是一个 TextStream 对象，可以读取命令的输出结果。</p>]]></content>
    
    
    <categories>
      
      <category>各语言执行Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>针对九龙冰室的预制菜行为的反馈</title>
    <link href="/2023/09/08/%E9%92%88%E5%AF%B9%E4%B9%9D%E9%BE%99%E5%86%B0%E5%AE%A4%E7%9A%84%E9%A2%84%E5%88%B6%E8%8F%9C%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%8F%8D%E9%A6%88/"/>
    <url>/2023/09/08/%E9%92%88%E5%AF%B9%E4%B9%9D%E9%BE%99%E5%86%B0%E5%AE%A4%E7%9A%84%E9%A2%84%E5%88%B6%E8%8F%9C%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%8F%8D%E9%A6%88/</url>
    
    <content type="html"><![CDATA[<h1 id="针对九龙冰室不负责任的预制菜行为的回应"><a href="#针对九龙冰室不负责任的预制菜行为的回应" class="headerlink" title="针对九龙冰室不负责任的预制菜行为的回应"></a>针对九龙冰室不负责任的预制菜行为的回应</h1><p>本人(即灰风，不方便透露名字)在2023年8月31日中午十二点左右于上海市长宁区南丰城B1九龙冰室就餐，共消费62元，购买了一份鸡扒饭与灯胆奶茶。</p><p>在鸡扒饭上桌后，我尝了一下，边缘的米饭是凉的，我误以为是边缘处凉的较快，在之后我吃到里面的饭也是凉的，我感到十分不可思议。</p><p>在饭点，作为一家连锁粤菜餐厅，竟然上了一盘预制菜给我，这令我十分不解与震撼。当然，鸡扒饭里的肉和蛋都是当天现做，不过对于米饭预制这件事我由于当日下午还有其它事务没有与服务员过多纠缠，让他们热好就结账走了，九龙冰室服务员将他们灯胆奶茶的杯子赠与我以示歉意，我当时接受了，但我认为这是封口费。</p><p>事件讲述完毕，对此，我的回应是从2023年九月开始，本人以及所有工作室成员不会再前往九龙冰室，同时，也会与周边人士通知此事，祝你们品牌关门大吉！</p>]]></content>
    
    
    <categories>
      
      <category>公告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>餐饮</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
